<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DockerFile</title>
    <link href="/cxlittlecute/f61655ea.html"/>
    <url>/cxlittlecute/f61655ea.html</url>
    
    <content type="html"><![CDATA[<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>Dockerfile是用来构建docker镜像的文件的命令参数脚本。</p><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><p>1、 编写一个dockerfile文件</p><p>2、 docker build 构建称为一个镜像</p><p>3、 docker run运行镜像</p><p>4、 docker push发布镜像（DockerHub 、阿里云仓库)</p><p>我们可以通过DockerHub查看官网所构建的一些dockerfile文件。</p><h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、#表示注释</p><p>4、每一个指令都会创建一个新的镜像层并提交。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><pre><code class="hljs shell">FROM# from:基础镜像，一切从这里开始构建MAINTAINER# maintainer:镜像是谁写的， 姓名+邮箱RUN# run:镜像构建的时候需要运行的命令ADD# add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR# workdir:镜像的工作目录VOLUME# volume:挂载的目录EXPOSE# expose:保留端口配置CMD# cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT# entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD# onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令COPY# copy:类似ADD，将我们文件拷贝到镜像中ENV# env:构建的时候设置环境变量！</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802184453.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker具名和匿名挂载</title>
    <link href="/cxlittlecute/d367fe76.html"/>
    <url>/cxlittlecute/d367fe76.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker具名和匿名挂载"><a href="#Docker具名和匿名挂载" class="headerlink" title="Docker具名和匿名挂载"></a>Docker具名和匿名挂载</h1><p>挂载对于docker的使用是很重要的一个操作，因为我们可以通过挂载，将容器中的数据同步到本地主机上，这样就实现了容器数据的持久化或者数据共享。</p><h2 id="挂载方式"><a href="#挂载方式" class="headerlink" title="挂载方式"></a>挂载方式</h2><ol><li>直接使用命令挂载 -v分为以下几种情况：</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 三种挂载： 匿名挂载、具名挂载、指定路径挂载</span>-v 容器内路径#匿名挂载-v 卷名：容器内路径  #具名挂载-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</code></pre><ol start="2"><li>还可以使用DockerFile实现自动挂载。</li><li>以及使用数据卷容器进行挂载。</li></ol><h2 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span><span class="hljs-meta">#</span><span class="bash"> -v 容器内路径!</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx01 -v /etc/nginx nginx</span><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls    </span>DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c</code></pre><p>这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径。</p><h2 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 具名挂载 -P:表示随机映射端口</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls                  </span>DRIVER              VOLUME NAMElocal               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802clocal               juming-nginx #多了一个名字<span class="hljs-meta">#</span><span class="bash"> 通过 -v 卷名：查看容器内路径</span><span class="hljs-meta">#</span><span class="bash"> 查看一下这个卷</span><span class="hljs-meta">$</span><span class="bash"> docker volume inspect juming-nginx</span>[    &#123;        "CreatedAt": "2020-05-23T13:55:34+08:00",        "Driver": "local",        "Labels": null,        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data", #默认目录        "Name": "juming-nginx",        "Options": null,        "Scope": "local"    &#125;]</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/自定义的卷名/_data</strong>下。</p><p>如果指定了目录，也就是第三种指定路径挂载通过-v /宿主机路径：容器内路径，docker volume ls 是查看不到的。</p><p>那么我们都可以通过docker inspect去查看宿主机的挂载目录。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span>ro #readonly 只读rw #readwrite 可读可写<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span></code></pre><p>我们经常会看到以上的这两个用法，区别就是：ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！默认是rw。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker常用命令（转载）</title>
    <link href="/cxlittlecute/c8b964af.html"/>
    <url>/cxlittlecute/c8b964af.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker常用命令（转载）"><a href="#Docker常用命令（转载）" class="headerlink" title="Docker常用命令（转载）"></a>Docker常用命令（转载）</h1><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802123615.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs shell">attach  Attach to a running container      #当前shell下attach下连接指定运行镜像build   Build an image form a Dockerfile   #通过Dockerfile定制镜像commit  Create a new image form a container changes #提交当前容器为新的镜像cp Copy file/folders from the containers filesystem to the host path # 容器中拷贝指定文件或者目录到宿主机上create  Create a new Container            #创建一个新的容器，同run，但是不会启动容器diff  Inspect changes on a Container’s filesystem #查看docker 容器的变化exec  Run a Command in an existing container  #在已存在的容器上运行命令export   Stream the contents of a container as a tar archive   #导出容器的内容作为一个tar 归档文件[对应import]history    Show the history of an image     # 展示一个镜像形成历史images     List images    #列出系统当前镜像import     Create a new filesystem image form the contents of a tarball # 从tar包中的内容创建一个新的文件系统镜像[对应export]info     Display system-while information       # 显示系统相关信息inspect    Return low—level  information on a container    # 查看容器详细信息kill   kill a running container      # kill 指定docker 容器load    Load an image from a tar archive      # 从一个tar包中加载一个镜像[对应save]login   Register or login to the docker registry server    # 注册或者登陆一个Docker源服务器logout    Log out from a Docker registry server    # 从当前Docker registry  退出logs     Fetch  the logs of a container      # 输出当前容器日志信息port     Lookup  the public-facing port which  is NAT-ed to PRIVATE-PORT   # 查看映射端口对应的容器内部源端口pause   Pause all processes within a container   # 暂停容器ps     List containers         # 列出容器列表pull   Pull an image or a repository from the docker registry server  # 从docker镜像服务器拉取指定镜像或者库镜像push   Push  an image or a repository from the docker registry server  # 推送指定镜像或者库镜至docker 源服务器restart  Restart a running container       # 重启运行的容器rm    Remove  one or more container        # 移除一个或者多个容器rmi   Remove  one or more images           # 移除一个或多个镜像[无容器使用该镜像才可以删除，否则需删除相关容器才可继续  或者-f强制删除]run    Run a  command  in a new container       # 创建一个新的容器并运行一个命令save   Save an image  to a tar archive          # 保存一个镜像为一个tar包[对应load]search  Search for an image on the Docker Hub   # 在docker hub 中搜索镜像start   Start a  stoped containers              # 启动容器stop    Stop  a running container               # 停止容器tag     Tag an image into a repository          # 给源中镜像打标签top     Lookup the running proesses of a container # 查看容器中运行的进程信息unpause  Unpause a paused container             # 取消暂停容器version  Show the docker version information    # 查看docker版本号wait   Block until a container stops, then print its exit code # 截取容器停止时的退出状态值</code></pre><p>笔记出自bilibili 博主：遇见狂神说</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（七）-分词</title>
    <link href="/cxlittlecute/3cc92c66.html"/>
    <url>/cxlittlecute/3cc92c66.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（七）-分词"><a href="#Elasticsearch（七）-分词" class="headerlink" title="Elasticsearch（七）-分词"></a>Elasticsearch（七）-分词</h1><p>分词的作用就是将一段话，分为一个个单词，利用单词的相关性匹配，最终完成我们的全文检索功能。</p><p>分词在ES中是使用分词器进行的，一个 tokenizer (分词器)接收一个字符流,将之分割为独立的 tokens (词元，通常是独立的单词)，然后输出 tokens流。</p><p>例如, whitespace tokenizer 遇到空白字符时分割文本。它会将文本”Quick brown fox!”分割为[Quick， brown， fox!l。</p><p>该 tokenizer (分词器)还负责记录各个 term (词条)的顺序或 position位置(用于 phrase短语和 word proximity 词近邻查询) ，以及 term (词条)所代表的原始 word (单词)的 start(起始)和 end (结束)的 character offsets (字符偏移量) (用于高亮显示搜索的内容)。</p><p>Elasticsearch 提供了很多内置的分词器，可以用来构建 custom analyzers (自定义分词器) </p><h2 id="测试-ES-默认的标准分词器"><a href="#测试-ES-默认的标准分词器" class="headerlink" title="测试 ES 默认的标准分词器"></a>测试 ES 默认的标准分词器</h2><pre><code class="hljs shell">POST _analyze&#123;  "analyzer": "standard",  "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."&#125;</code></pre><p>我们可以将上面那段话分为如下的形式：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801152017.png" srcset="/img/loading.gif" alt=""></p><p>但是我们需要注意的是，ES中内置的分词器都是对英文很友好，使用中文进行分词的话，它就会将一个个的字分开。</p><p>我们执行下面这一条语句看一下：</p><pre><code class="hljs shell">POST _analyze&#123;  "analyzer": "standard",  "text": "pafcmall电商项目"&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801152301.png" srcset="/img/loading.gif" alt=""></p><p>所以我们要进行其他分词器的安装。</p><h2 id="安装-ik-分词器"><a href="#安装-ik-分词器" class="headerlink" title="安装 ik 分词器"></a>安装 ik 分词器</h2><p>IK版本对应ES。</p><p>1、进入 es 容器内部 plugins 目录</p><pre><code class="hljs shell">docker exec -it 容器id /bin/bashwget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</code></pre><p>如果没有安装wget，就只有通过git下载zip后再上传到相应挂载的目录。用wget下载可能很慢，建议先下载zip后使用XFtp上传。</p><ol start="2"><li>unzip 下载文件并解压</li></ol><p>使用 unzip 解压 elasticsearch-analysis-ik-7.4.2.zip 发现 unzip 命令还未安装，先安装 unzip.</p><pre><code class="hljs shell">yum install unzip</code></pre><p>我使用的是Xftp上传。</p><ol start="3"><li><p>修改文件名，给对应目录修改权限。</p><pre><code class="hljs shell">将文件名改为ik。chmod -R 777 ik/</code></pre></li><li><p>安装并重启docker<br>进入ES的bin目录</p></li></ol><pre><code class="hljs shell">elasticsearch-plugin list</code></pre><p>执行安装，然后重启docker。最终执行结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801160226.png" srcset="/img/loading.gif" alt=""></p><p>官方文档位置:<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html</a></p><h2 id="自定义扩展词库"><a href="#自定义扩展词库" class="headerlink" title="自定义扩展词库"></a>自定义扩展词库</h2><p>我们发现虽然我们安装了ik分词器，但是我们的分词效果并不明显，因为它不能很好的按照我们的想法去进行分词。</p><p>所以，我们要进行自定义扩展词库。</p><p>要自定义拓展词库，可以修改 ik 分词器的配置文件，指定一个远程词库，让 ik 分词器向远程发送请求，要到一些最新的单词，这样最新的单词就会作为最新的词源进行分解。<br>自定义词库有两种方式实现：</p><ol><li>自己实现一个服务，处理 ik 分词器的请求，让 ik 分词器的给自定义的项目发送请求</li><li>搭建一个 nginx 服务器，将最新词库放到 nginx 中，让 ik 分词器给 nginx 发送请求，由 nginx 给 ik 分词器返回最新的词库，这样 ik 分词器就可以将原来的词库和新词库合并起来。</li></ol><p>我们主要讲解第二种方式：</p><ol><li><p>创建之前我们首先要安装好nginx。</p></li><li><p>我们在nginx/html目录下，创建一个es的文件夹，并且在里面创建一个txt文件。</p></li><li><p>我们可以通过浏览器路径直接访问我们的txt文件内容。例如：<a href="http://47.106.192.255/es/fenci.txt" target="_blank" rel="noopener">http://47.106.192.255/es/fenci.txt</a></p></li><li><p>如果访问成功,接下来我们就需要修改我们ik分词器的配置。</p><ul><li>修改分词器ik/config文件下的配置文件IKAnalyzer.cfg.xml。</li></ul></li></ol><p>xml中的修改情况如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801181856.png" srcset="/img/loading.gif" alt=""></p><p>注意：</p><ul><li>如果打开 IKAnalyzer.cfg.xml 为乱码的话，可以在先退出当前文件，在命令行输入 vi /etc/virc，然后在文件添加 set encoding=utf-8，保存退出，重新打开 IKAnalyzer.cfg.xml 即可。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801182052.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果出现nginx访问txt出现乱码情况。在nginx.conf中增加如下配置：然后nginx -s reload，重新加载或者重启容器。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802100655.png" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>最后我们需要重启ES容器。然后使用Kibana进行分词测试。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（六）-映射&amp;数据迁移</title>
    <link href="/cxlittlecute/6e27786d.html"/>
    <url>/cxlittlecute/6e27786d.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（六）-映射-amp-数据迁移"><a href="#Elasticsearch（六）-映射-amp-数据迁移" class="headerlink" title="Elasticsearch（六）-映射&amp;数据迁移"></a>Elasticsearch（六）-映射&amp;数据迁移</h1><p>首先我们需要知道ES7以后的一个改动：</p><p>ES7 及以上移除了 type 的概念。</p><p>关系型数据库中两个数据表是独立的，即使他们里面有相同名称的列也不影响使用，但ES中不是这样的。 elasticsearch 是基于 Lucene 开发的搜索引擎，而 ES 中不同type下名称相同的 filed 最终在 Lucene 中的处理方式是一样的。<br>两个不同 type 下的两个 user_name，在ES同一个索引下其实被认为是同一个 filed，你必须在两个不同的 type 中定义相同的 filed 映射。否则，不同 type 中的相同字段名称就会在处理中出现冲突的情况，导致 Lucene 处理效率下降。</p><p>去掉type就是为了提高 ES 处理数据的效率。</p><p>Elasticsearch 7.x：<br>URL中的 type 参数为可选。比如，索引一个文档不再要求提供文档类型。<br>Elasticsearch 8.x：<br>不再支持URL中的type参数。</p><h2 id="1）字段类型"><a href="#1）字段类型" class="headerlink" title="1）字段类型"></a>1）字段类型</h2><h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><ul><li>字符串（string）<br>text，keyword</li><li>数字类型（Numeric）<br>long, integer, short, byte, double, float, half_float, scaled_float</li><li>日期类型（Date）<br>date</li><li>布尔类型（Boolean）<br>boolean</li><li>二进制类型（Binary）<br>binary</li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul><li>数组类型（Array）<br>Array 支持不针对特定的数据类型</li><li>对象类型（Object）<br>object 用于单个JSON对象的对象</li><li>嵌套类型（Nested）<br>nested 用于JSON对象的数组</li></ul><h3 id="地理类型（Geo）"><a href="#地理类型（Geo）" class="headerlink" title="地理类型（Geo）"></a>地理类型（Geo）</h3><ul><li>地理坐标（Geo-point）<br>geo_point 纬度/经度坐标</li><li>地理圆形（Geo-shape）<br>geo_shape 用于多边形等复杂形状</li></ul><h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><ul><li>IP 类型（IP）<br>ip 用于描述 IPv4 和 IPv6 地址</li><li>补全类型（Completion）<br>completion 提供自动完成提示</li><li>令牌计数类型（Token count）<br>token_count 用来统计字符串中词条的数量</li><li>附件类型（attachment）<br>参考 mapper-attachments 插件，支持将附件例如Microsoft Office格式，open document格式，ePub，HTML等索引为 attachment 数据类型。</li><li>抽取类型（Percolator）<br>接受来自领域特定语言（query-dsl）的查询</li></ul><p>可参考文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</a></p><h2 id="2）映射"><a href="#2）映射" class="headerlink" title="2）映射"></a>2）映射</h2><p>映射是定义文档及其包含的字段的存储和索引方式的过程。</p><ul><li>哪些字符串字段应视为全文字段。</li><li>哪些字段包含数字，日期或地理位置。</li><li>日期值的格式。</li><li>自定义规则，用于控制动态添加字段的映射 。</li></ul><h2 id="3）使用"><a href="#3）使用" class="headerlink" title="3）使用"></a>3）使用</h2><h5 id="查看-mapping-信息："><a href="#查看-mapping-信息：" class="headerlink" title="查看 mapping 信息："></a>查看 mapping 信息：</h5><p>GET bank/_mapping</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801110112.png" srcset="/img/loading.gif" alt=""></p><ul><li>创建索引并指定映射：</li></ul><pre><code class="hljs shell">PUT /my-index&#123;  "mappings": &#123;//映射规则    "properties": &#123;      "age":    &#123; "type": "integer" &#125;,        "email":  &#123; "type": "keyword"  &#125;,//keyword不会进行全文检索       "name":   &#123; "type": "text"  &#125;//text保存的时候进行分词，搜索的时候进行全文检索       &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801111205.png" srcset="/img/loading.gif" alt=""></p><p>如果不设置mapping信息，那么ES会根据你的值自动设置相应的类型。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801112343.png" srcset="/img/loading.gif" alt=""></p><h5 id="添加新的字段映射"><a href="#添加新的字段映射" class="headerlink" title="添加新的字段映射"></a>添加新的字段映射</h5><pre><code class="hljs shell">PUT /my-index/_mapping&#123;  "properties": &#123;    "employee-id": &#123;      "type": "keyword",      "index": false//索引选项控制是否对字段值建立索引。 它接受true或false，默认为true。未索引的字段不可查询。也就是控制这个字段是否参与检索。    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801120301.png" srcset="/img/loading.gif" alt=""></p><h5 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h5><p>对于已经存在的映射字段，我们不能更新。更新必须创建新的索引进行数据迁移。</p><h2 id="4）数据迁移"><a href="#4）数据迁移" class="headerlink" title="4）数据迁移"></a>4）数据迁移</h2><p>先创建出 twitter 的正确映射。然后使用如下方式进行数据迁移:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7.x 之后的写法</span>POST _reindex//固定写法&#123;  "source": &#123;//老索引    "index": "twitter"  &#125;,  "dest": &#123;//目标索引    "index": "new_twitter"  &#125;&#125;<span class="hljs-meta">#</span><span class="bash"> 7.x之前的带 <span class="hljs-built_in">type</span> 的写法</span>将旧索引的 type 下的数据进行迁移POST _reindex//固定写法&#123;  "source": &#123;    "index": "twitter", //老索引    "type": "twitter",  //老类型  &#125;,  "dest": &#123;//目标索引    "index": "new_twitter"  &#125;&#125;</code></pre><p>举例：<br>将bank索引下，account类型的数据进行迁移。</p><ol><li>创建一个新的索引：<pre><code class="hljs shell">PUT /newbank&#123;  "mappings": &#123;    "properties": &#123;      "account_number": &#123;        "type": "long"      &#125;,      "address": &#123;        "type": "text"      &#125;,      "age": &#123;        "type": "integer"      &#125;,      "balance": &#123;        "type": "long"      &#125;,      "city": &#123;        "type": "keyword"      &#125;,      "email": &#123;        "type": "keyword"      &#125;,      "employer": &#123;        "type": "keyword"      &#125;,      "firstname": &#123;        "type": "text"      &#125;,      "gender": &#123;        "type": "keyword"      &#125;,      "lastname": &#123;        "type": "text"      &#125;,      "state": &#123;        "type": "keyword"      &#125;    &#125;  &#125;&#125;</code></pre><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801145343.png" srcset="/img/loading.gif" alt=""></li></ol><ol start="2"><li><p>数据迁移：</p><pre><code class="hljs shell">POST _reindex&#123;  "source": &#123;    "index": "bank",    "type": "account"  &#125;,  "dest": &#123;    "index": "newbank"  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801145422.png" srcset="/img/loading.gif" alt=""></p></li><li><p>查看迁移后的结果：</p></li></ol><pre><code class="hljs shell">GET newbank/_search</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801145614.png" srcset="/img/loading.gif" alt=""></p><p>详情请参考文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（五）-聚合分析</title>
    <link href="/cxlittlecute/6765e78b.html"/>
    <url>/cxlittlecute/6765e78b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（五）-聚合分析"><a href="#Elasticsearch（五）-聚合分析" class="headerlink" title="Elasticsearch（五）-聚合分析"></a>Elasticsearch（五）-聚合分析</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面我们已经了解了ES的存储、检索功能，那么还剩下第三个强大的分析功能。</p><h4 id="aggregations-执行聚合"><a href="#aggregations-执行聚合" class="headerlink" title="aggregations (执行聚合)"></a>aggregations (执行聚合)</h4><p>聚合提供了从数据中分组和提取数据的能力。<br>最简单的聚合方法大致等于 SQL GROUP BY 和 SQL 聚合函数。</p><pre><code class="hljs shell">"aggregations" : &#123;    "&lt;aggregation_name&gt;" : &#123;        "&lt;aggregation_type&gt;" : &#123;            &lt;aggregation_body&gt;        &#125;        [,"meta" : &#123;  [&lt;meta_data_body&gt;] &#125; ]?        [,"aggregations" : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]?    &#125;    [,"&lt;aggregation_name_2&gt;" : &#123; ... &#125; ]*&#125;</code></pre><p>聚合分析有四种：<br>metrics：指标分析聚合<br>bucket：分桶类型<br>pipeline：管道分析<br>matrix：矩阵分析</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><h5 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h5><ul><li>搜索address中包含mill的所有人的年龄分布以及平均年龄，但不显示这些人的详情。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123; //查询    "match": &#123;      "address": "mill"    &#125;  &#125;,  "aggs": &#123; //聚合    "ageAgg": &#123; //年龄分布      "terms": &#123;        "field": "age",        "size": 10 //只取10中聚合的结果      &#125;    &#125;,    "ageAvg":&#123;//平均年龄，基于上一次的结果      "avg": &#123;        "field": "age"      &#125;    &#125;,    "balanceAvg":&#123;//平均薪资      "avg": &#123;        "field": "balance"      &#125;    &#125;  &#125;,  "size": 0 //不显示搜索数据，只显示聚合结果&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801092324.png" srcset="/img/loading.gif" alt=""></p><p>aggs，执行聚合。聚合语法如下：</p><pre><code class="hljs shell">"aggs":&#123;"ages_name 这次聚合的名字,方便展示在结果集中":&#123;"AGG-TYPE 聚合的类型(avg,term,terms) ":&#123;&#125;&#125;&#125;</code></pre><h5 id="复杂聚合"><a href="#复杂聚合" class="headerlink" title="复杂聚合"></a>复杂聚合</h5><ul><li>按照年龄聚合，并且请求这些年龄段的这些人的平均薪资（使用一个子聚合）</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "aggs": &#123;    "ageAgg": &#123;      "terms": &#123;//年龄范围分布聚合        "field": "age",        "size": 100//返回100中情况      &#125;,      "aggs": &#123;//基于ageAgg的结果做聚合        "ageAvg": &#123;          "avg": &#123;//求balance的平均值            "field": "balance"          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801093745.png" srcset="/img/loading.gif" alt=""></p><ul><li>查出所有年龄分布，并且这些年龄段中M的平均薪资和F的平均薪资以及这个年龄段的总体平均新资。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "aggs": &#123;//聚合    "ageAgg":&#123;      "terms": &#123;//年龄分布        "field": "age",        "size": 100      &#125;,      "aggs": &#123;//基于ageAgg做聚合        "genderAgg": &#123;//性别分布          "terms": &#123;            //文本字段聚合使用keyword进行精确匹配，否则会报错            "field": "gender.keyword",            "size": 10          &#125;,          "aggs": &#123;//基于genderAgg做聚合            "balanceAvg": &#123;//求性别为M和F的各自的平均薪资              "avg": &#123;                "field": "balance"              &#125;            &#125;          &#125;        &#125;,        "ageBalanceAvg":&#123;//基于ageAgg，求各个年龄段的平均薪资          "avg": &#123;            "field": "balance"          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801102703.png" srcset="/img/loading.gif" alt=""></p><p>聚合分析的其他用法可以参考官方文档或者以下博客：</p><p><a href="https://www.cnblogs.com/xiaobaozi-95/p/9197616.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaobaozi-95/p/9197616.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（四）-检索</title>
    <link href="/cxlittlecute/8fb22cc.html"/>
    <url>/cxlittlecute/8fb22cc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（四）-检索"><a href="#Elasticsearch（四）-检索" class="headerlink" title="Elasticsearch（四）-检索"></a>Elasticsearch（四）-检索</h1><h2 id="1-检索"><a href="#1-检索" class="headerlink" title="1. 检索"></a>1. 检索</h2><p>ES 支持两种基本方式检索：</p><ul><li>一个是通过使用 REST request URI 发送搜索参数(uri+检索参数)</li><li>另一个是通过使用 REST requestbody 来发送它们(uri+请求体)</li></ul><p>一切检索从_search开始</p><ol><li>uri+检索参数 进行检索：</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731095204.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731095315.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>uri+请求体 进行检索:</li></ol><pre><code class="hljs java">GET /bank/_search&#123;  <span class="hljs-string">"query"</span>: &#123;    <span class="hljs-string">"match_all"</span>: &#123;&#125;  &#125;,  <span class="hljs-string">"sort"</span>: [    &#123;      <span class="hljs-string">"account_number"</span>: <span class="hljs-string">"asc"</span>    &#125;,    &#123;      <span class="hljs-string">"balance"</span>: <span class="hljs-string">"desc"</span>    &#125;  ]&#125;</code></pre><p>这种查询风格，我们称为Query DSL。</p><p>可以参照ES文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></p><h2 id="2-Query-DSL"><a href="#2-Query-DSL" class="headerlink" title="2. Query DSL"></a>2. Query DSL</h2><h4 id="1）基本语法："><a href="#1）基本语法：" class="headerlink" title="1）基本语法："></a>1）基本语法：</h4><p>Elastisearch 提供了一个可以执行查询的 Json 风格的 DSl (domain-specific language 领域特定语言) 。这个被称为Query DSL。该查询语言非常全面。</p><ul><li>查询语句的典型结构<pre><code class="hljs shell">&#123;QUERY_NAME:&#123;ARGUMENT: VALUE,ARGUMENT: VALUE,...&#125;&#125;</code></pre>例如查询所有：</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;&#125;</code></pre><ul><li>如果是针对某个字段,那么它的结构如下：</li></ul><pre><code class="hljs shell">&#123;QUERY_NAME:&#123;FIELD_NAME:&#123;ARGUMENT: VALUE,ARGUMENT: VALUE,...&#125;&#125;&#125;</code></pre><p>例如下面我们指定字段进行排序：</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "sort": [    &#123;      "balance": &#123;        "order": "desc"      &#125;    &#125;  ],  "from": 0,  "size": 5&#125;</code></pre><ul><li>query 定义如何查询；</li><li>match_all 查询类型【代表查询所有的所有】， es 中可以在 query 中组合非常多的查询类型完成复杂查询</li><li>除了 query 参数之外，我们也可以传递其它的参数以改变查询结果。如 sort，size；</li><li>from+size 限定，完成分页功能；</li><li>sort 排序，多字段排序，会在前序字段相等时后续字段内部排序，否则以前序为准.</li></ul><h4 id="2-返回部分字段"><a href="#2-返回部分字段" class="headerlink" title="2) 返回部分字段"></a>2) 返回部分字段</h4><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "sort": [    &#123;      "balance": &#123;        "order": "desc"      &#125;    &#125;  ],  "from": 0,  "size": 5,  "_source": ["balance","firstname"]&#125;</code></pre><p>只返回 _source 中指定的字段，类似于 MySQL 中的 select field_1,field_2,… from table。</p><h4 id="3）match【匹配查询】"><a href="#3）match【匹配查询】" class="headerlink" title="3）match【匹配查询】"></a>3）match【匹配查询】</h4><ul><li>基本类型（非字符串），精确匹配</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "account_number": 20    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731103245.png" srcset="/img/loading.gif" alt=""></p><ul><li>字符串，全文检索</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "address": "Kings"    &#125;  &#125;&#125;</code></pre><p>最终查询出 address 中包含 Kings 单词的所有记录，当搜索字符串类型的时候，会进行全文检索，并且每条记录有相关性得分。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731103406.png" srcset="/img/loading.gif" alt=""></p><ul><li>字符串，多个单词（分词+全文检索）</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "address": "Mill Lane"    &#125;  &#125;&#125;</code></pre><p>最终查询出 address 中包含 Mill 或者 Lane 或者 Mill Lane 的所有记录,并给出相关性得分.最后的结果也是按照得分的高低进行排序的。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731103655.png" srcset="/img/loading.gif" alt=""></p><h4 id="4）match-phrase-【短语匹配】"><a href="#4）match-phrase-【短语匹配】" class="headerlink" title="4）match_phrase 【短语匹配】"></a>4）match_phrase 【短语匹配】</h4><p>将需要匹配的值当成一个整体单词(不分词)进行检索。</p><p>举例：查出 address 中包含 mill road 的所有记录，并给出相关性得分。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_phrase": &#123;      "address": "mill road"    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731104445.png" srcset="/img/loading.gif" alt=""></p><h4 id="5）multi-match-【多字段匹配】"><a href="#5）multi-match-【多字段匹配】" class="headerlink" title="5）multi_match 【多字段匹配】"></a>5）multi_match 【多字段匹配】</h4><p>举例：检索在address 或 state 字段包含 mill的。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "multi_match": &#123;      "query": "mill",      "fields": ["address","state"]    &#125;  &#125;&#125;</code></pre><p>只要有一个字段包含，就能检索出数据。多字段匹配仍然进行了分词。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731105103.png" srcset="/img/loading.gif" alt=""></p><h4 id="6）bool-【复合查询】"><a href="#6）bool-【复合查询】" class="headerlink" title="6）bool 【复合查询】"></a>6）bool 【复合查询】</h4><p>复合语句可以合并任何其它查询语句，包括复合语句，了解这一点是很重要的。<br>这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p><ul><li>must：必须达到 must 列举的所有条件。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;          "match": &#123;            "gender": "F"          &#125;        &#125;,        &#123;          "match": &#123;            "address": "Mill"          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731110610.png" srcset="/img/loading.gif" alt=""></p><ul><li>must_not：子句（查询）不得出现在匹配的文档中。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;          "match": &#123;            "gender": "F"          &#125;        &#125;,        &#123;          "match": &#123;            "address": "Mill"          &#125;        &#125;      ],      "must_not": [        &#123;"match": &#123;          "age": 30        &#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731110842.png" srcset="/img/loading.gif" alt=""></p><ul><li>should：子句（查询）应出现在匹配的文档中。（should表示有最好，没有也可以）。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;          "match": &#123;            "gender": "M"          &#125;        &#125;,        &#123;          "match": &#123;            "address": "Mill"          &#125;        &#125;      ],      "must_not": [        &#123;"match": &#123;          "age": 30        &#125;&#125;      ],      "should": [        &#123;"match": &#123;          "lastname": "Holland"        &#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731110936.png" srcset="/img/loading.gif" alt=""></p><h4 id="7-filter-【结果过滤】"><a href="#7-filter-【结果过滤】" class="headerlink" title="7) filter 【结果过滤】"></a>7) filter 【结果过滤】</h4><p>在 filter 元素下指定的查询对得分没有影响-得分以 0 形式返回。分数仅受指定查询的影响。must和filter的不同就是，使用filter查询出的结果和must查询出的结果是一致的，差异仅是没有相关性得分。</p><p>Filter子句在filter上下文中执行，这意味着计分被忽略，并且子句被考虑用于缓存。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;"range": &#123;          "age": &#123;            "gte": 18,            "lte": 30          &#125;        &#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731112923.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "filter": &#123;        "range": &#123;          "age": &#123;            "gte": 18,            "lte": 30          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731113054.png" srcset="/img/loading.gif" alt=""></p><p>所以我们可以在最后进行filter条件过滤。</p><h4 id="8-term"><a href="#8-term" class="headerlink" title="8) term"></a>8) term</h4><p>和 match 一样。匹配某个属性的值。全文检索字段用 match，其他非 text 字段匹配用 term。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "term": &#123;      "age":28    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731113922.png" srcset="/img/loading.gif" alt=""></p><p>match 的 xxx.keyword，文本的精确匹配检索:</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "address.keyword": "789 Madison"    &#125;  &#125;&#125;</code></pre><p>和match_phrase的区别在于，xxx.keyword是必须文本内容完全相同，而match_phrase是只要文本中出现了这个完整句子就可以。</p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（三）-数据操作</title>
    <link href="/cxlittlecute/bfd63ba9.html"/>
    <url>/cxlittlecute/bfd63ba9.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（三）-数据操作"><a href="#Elasticsearch（三）-数据操作" class="headerlink" title="Elasticsearch（三）-数据操作"></a>Elasticsearch（三）-数据操作</h1><p> ES将所有请求都封装成了 REST API，因此我们可以使用 postman 和图形化界面kibana来访问它。</p><p> 使用 postman 或者在浏览器地址栏输入请求路径：</p><pre><code>http://IP:端口/_cat/xxx</code></pre><p>###1. _cat (节点信息查看)</p><ul><li>GET /_cat/nodes:查看所有节点</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105612.png" srcset="/img/loading.gif" alt=""></p><ul><li>GET /_cat/health:查看es健康状况</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105720.png" srcset="/img/loading.gif" alt=""></p><ul><li>GET /_cat/master:查看主节点</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105841.png" srcset="/img/loading.gif" alt=""></p><ul><li>GET /_cat/indices:查看所有索引 ；相当于 MySQL 的 show databases;</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105913.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-put-amp-post-（新增数据）"><a href="#2-put-amp-post-（新增数据）" class="headerlink" title="2. put&amp;post （新增数据）"></a>2. put&amp;post （新增数据）</h3><ul><li><p>索引一个文档(对应成Mysql就是保存一条记录)</p><p>  保存一个数据，保存在哪个索引的哪个类型下，指定用哪个唯一标识PUT customer/external/1。</p><p>  在 customer 索引下的 external 类型下保存 1 号数据为：</p>  <pre><code class="hljs json">&#123;“name”:“lohn Doe”&#125;</code></pre><p>那么我们可以使用postman发送这个Json请求。</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730110736.png" srcset="/img/loading.gif" alt=""></p><p>返回体的内容,返回一些基本信息：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730110853.png" srcset="/img/loading.gif" alt=""></p><p>注意：<br>PUT 和 POST 都可以。<br>POST 新增。如果不指定id，会自动生成 id。指定 id 如果第二次提交就会修改这个数据，并新增版本号；<br>PUT 可以新增也可以修改。PUT 必须指定 id；由于 PUT 需要指定 id，我们一般都用来做修改；</p><h3 id="3-get-（查询数据）-amp-乐观锁字段"><a href="#3-get-（查询数据）-amp-乐观锁字段" class="headerlink" title="3. get （查询数据）&amp;乐观锁字段"></a>3. get （查询数据）&amp;乐观锁字段</h3><p>我们通过GET 索引/类型/ID查询数据</p><p>查询结果：</p><pre><code class="hljs json">&#123;    “_index”: “customer”, //在哪个索引    “_type”: “external”, //在哪个类型    “_id”: “1”, //记录id    “_version”: 4, //版本号    “_seq_no”: 5, //并发控制字段,每次更新就会+1,用来做乐观锁    “_primary_term”: 1, //同上,主分片重新分配,如重启,就会变化    “found”: true, //表示找到了数据    “_source”: &#123; //数据内容        “name”: “lohn Doe”    &#125;&#125;</code></pre><p>我们可以看到在查询结果中有我们的乐观锁字段“_seq_no”,它是为了保证我们多线程访问的情况下，保证数据的一致性。</p><p>我们要使用乐观锁修改，我们就需要在 put 或 post 请求的路径中加上?if_seq_no=0&amp;if_primary_term=1字段。</p><p>这样就可以根据去判断版本是否对应，是否能够修改成功。</p><p>如果访问版本不对应的数据会出现以下报错：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730113015.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-put-amp-post-更新文档"><a href="#4-put-amp-post-更新文档" class="headerlink" title="4. put&amp;post (更新文档)"></a>4. put&amp;post (更新文档)</h3><p>更新的操作主要分为三种：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730113722.png" srcset="/img/loading.gif" alt=""></p><p>不同：</p><ol><li>POST带_update操作会对比源文档数据,如果相同不会有什么操作,文档 version 、_seq_no 不增加;</li><li>POST不带_update和PUT操作都不会检查源数据，都会迭代版本更新。</li></ol><p>更新同时增加属性：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730114255.png" srcset="/img/loading.gif" alt=""></p><p>总之：带_update操作就会对比源文档数据，其他的只会直接更新。</p><h3 id="5-DELETE-（删除数据）"><a href="#5-DELETE-（删除数据）" class="headerlink" title="5. DELETE （删除数据）"></a>5. DELETE （删除数据）</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730114745.png" srcset="/img/loading.gif" alt=""></p><p>注意：在ES中，一个索引下有很多种类型，但是 ES 没有提供删除类型的方法，删除了索引，就会删除所有类型。</p><h3 id="6-bulk批量操作"><a href="#6-bulk批量操作" class="headerlink" title="6. bulk批量操作"></a>6. bulk批量操作</h3><p>语法格式：</p><pre><code class="hljs shell">&#123;action: &#123;metadata&#125;&#125;\n&#123;request body&#125;\n&#123;action: &#123;metadata&#125;&#125;\n&#123;request body&#125;\n</code></pre><p>action:(行为)<br>create:文档不存在时创建<br>update:更新文档<br>index:创建新文档或替换已有文档<br>delete:删除一个文档<br>metadata:_index,_type,_id</p><p>create和index的区别:<br>如果数据存在,使用create操作失败,会提示文档已经存在,使用index可以成功执行。</p><p>1.批量添加:</p><pre><code class="hljs shell">POST /lib2/books/_bulk&#123;"index":&#123;"_id":1&#125;&#125;&#123;"title":"Java","price":55&#125;&#123;"index":&#123;"_id":2&#125;&#125;&#123;"title":"Html5","price":45&#125;&#123;"index":&#123;"_id":3&#125;&#125;&#123;"title":"Php","price":35&#125;&#123;"index":&#123;"_id":4&#125;&#125;&#123;"title":"Python","price":50&#125;</code></pre><ol start="2"><li>批量获取:</li></ol><pre><code class="hljs shell">GET /lib2/books/_mget&#123;  "ids":["1","2","3","4"]&#125;</code></pre><ol start="3"><li><p>批量删除:没有请求体<br>POST /_bulk<br>{“delete”:{“_index”:“website”,”_type”:“blog”,”_id”:“123”}}</p></li><li><p>批量修改</p></li></ol><p>{“update”:{“_index”:“website”,”_type”:“blog”,”_id”:“123”}}<br>{“doc”:{“title”:“My updated blog post”}}</p><p>我们可以在kibana 的控制台，选择 DevTools，完成我们的bulk批量操作。</p><p>下面是ES官方提供的样本数据：<br><a href="https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（二）-镜像下载启动</title>
    <link href="/cxlittlecute/f2c898fb.html"/>
    <url>/cxlittlecute/f2c898fb.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（二）-镜像下载启动"><a href="#Elasticsearch（二）-镜像下载启动" class="headerlink" title="Elasticsearch（二）-镜像下载启动"></a>Elasticsearch（二）-镜像下载启动</h1><p>本文主要记录自己在docker安装Elasticsearch时出现的问题，以及解决方式。</p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><pre><code class="hljs shell">docker pull elasticsearch:7.4.2 # 存储和检索数据</code></pre><h2 id="挂载配置文件"><a href="#挂载配置文件" class="headerlink" title="挂载配置文件"></a>挂载配置文件</h2><p>在挂载配置文件的时候可能会出现两个问题：</p><ol><li>虚拟机中的文件权限不足。</li><li>挂载的文件路径错误。</li></ol><p>解决问题：<br>问题一：修改虚拟机中挂载的文件权限。<br>问题二：核对挂载的文件路径是否正确。</p><pre><code class="hljs shell">mkdir -p /mydata/elasticsearch/config # 在mydata文件夹下创建es的config文件夹，将docker中es的配置挂载在外部，当我们在linux虚拟机中修改es的配置文件时，就会同时修改docker中的es的配置mkdir -p /mydata/elasticsearch/data #在mydata文件夹下创建es的data文件夹echo "http.host: 0.0.0.0" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml # [http.host: 0.0.0.0]允许任何远程机器访问es，并将其写入es的配置文件中chmod -R 777 /mydata/elasticsearch/ # 保证权限问题</code></pre><p>启动容器：</p><pre><code class="hljs shell">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \-e "discovery.type=single-node" \-e ES_JAVA_OPTS="-Xms64m -Xmx512m" \-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-d elasticsearch:7.4.2<span class="hljs-meta">#</span><span class="bash"> docker run --name elasticsearch 创建一个es容器并起一个名字；</span><span class="hljs-meta">#</span><span class="bash"> -p 9200:9200 将linux的9200端口映射到docker容器的9200端口，用来给es发送http请求</span><span class="hljs-meta">#</span><span class="bash"> -p 9300:9300 9300是es在分布式集群状态下节点之间的通信端口  \ 换行符</span><span class="hljs-meta">#</span><span class="bash"> -e 指定一个参数，当前es以单节点模式运行</span><span class="hljs-meta">#</span><span class="bash"> *注意，ES_JAVA_OPTS非常重要，指定开发时es运行时的最小和最大内存占用为64M和128M，否则就会占用全部可用内存</span><span class="hljs-meta">#</span><span class="bash"> -v 挂载命令，将虚拟机中的路径和docker中的路径进行关联</span><span class="hljs-meta">#</span><span class="bash"> -d 后台启动服务</span></code></pre><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><p>在我启动容器后，没有出现报错，但是使用命令docker ps，发现容器并没有启动成功，也就是没有正常运行。</p><p>解决：</p><p> 使用docker logs -f 容器ID查看容器运行的日志。</p><p> 发现出现以下问题：</p><pre><code>OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0....</code></pre><p>这是由于jdk版本太低造成的，jdk版本需要在9.0以上，因此需要重新安装jdk。重新安全JDK后就可以正常启动了。<br>还有就是允许任何远程机器访问es中的http.host: 0.0.0.0是有空格的，如果没有空格它也会报错elasticsearch.yml有问题。</p><p>使用IP+端口访问es,出现下图说明安装成功：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730091722.png" srcset="/img/loading.gif" alt=""></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>最后我们也可以安装es的可视化界面-kibana。</p><pre><code class="hljs shell">docker pull kibana:7.4.2</code></pre><pre><code class="hljs shell">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://47.106.192.255:9200 -p 5601:5601 \-d kibana:7.4.2</code></pre><p>注意修改将IP和端口，修改对应为你自己ES的IP和端口。</p><p>最后我们可以通过IP和端口进行访问：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730102948.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（一）- 基本概念</title>
    <link href="/cxlittlecute/c2de7423.html"/>
    <url>/cxlittlecute/c2de7423.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（一）-基本概念"><a href="#Elasticsearch（一）-基本概念" class="headerlink" title="Elasticsearch（一）- 基本概念"></a>Elasticsearch（一）- 基本概念</h1><h2 id="什么是Elasticsearch"><a href="#什么是Elasticsearch" class="headerlink" title="什么是Elasticsearch"></a>什么是Elasticsearch</h2><p>Elasticsearch是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。</p><h2 id="什么是全文检索"><a href="#什么是全文检索" class="headerlink" title="什么是全文检索"></a>什么是全文检索</h2><p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>Index（索引）： Elasticsearch 数据管理的顶层单位，相当于Mysql中的库。每个Index的名字必须是小写。</p></li><li><p>Type（类型）：可以在Index中定义一个或多个类型，它是虚拟的逻辑分组，用来过滤 Document，类似Mysql中的数据表。</p></li><li><p>Document（文档）：Index里面单条的记录称为 Document（文档），文档是JSON格式的，Document就像是Mysql中的某个Table里面的内容。</p></li><li><p>倒排索引（Inverted Index）：倒排索引以字或词为关键字进行索引，索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。Elasticsearch能够实现快速、高效的搜索功能，正是基于倒排索引原理。</p></li><li><p>文档编号(Document ID)：在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。</p></li><li><p>单词编号(Word ID)：与文档编号类似，搜索引擎内部以唯一的编号来表示某个单词，单词编号可以作为某个单词的唯一表示。</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729170338.png" srcset="/img/loading.gif" alt=""></p><p>保存和检索的时候都是先进行分词，然后在倒排索引表中进行插入和检索，最后根据相关性得分进行得到最后的数据。</p><ul><li><p>单词词典(Lexicon)：单词词典是由文档集合中出现过的所有单词构成的字符串集合。搜索引擎的通常索引单位是单词，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</p></li><li><p>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</p></li><li><p>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</p></li></ul><p>上面三者的关系我们可以通过下图清楚的看出：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729201139.png" srcset="/img/loading.gif" alt=""></p><p>参考：<br><a href="https://blog.csdn.net/starzhou/article/details/87519973" target="_blank" rel="noopener">https://blog.csdn.net/starzhou/article/details/87519973</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树折纸问题</title>
    <link href="/cxlittlecute/9672ca82.html"/>
    <url>/cxlittlecute/9672ca82.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树折纸问题"><a href="#二叉树折纸问题" class="headerlink" title="二叉树折纸问题"></a>二叉树折纸问题</h1><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729144138.png" srcset="/img/loading.gif" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们根据输出的结果分析，需要把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。</p><p>这棵树有这样的特点：</p><ol><li>根结点为下折痕；</li><li>每一个结点的左子结点为下折痕；</li><li>每一个结点的右子结点为上折痕；</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729144428.png" srcset="/img/loading.gif" alt=""></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>定义结点类</li><li>构建深度为N的折痕树；</li><li>使用中序遍历，打印出树中所有结点的内容。</li></ol><p>构建深度为N的折痕树：</p><ol><li>第一次对折，只有一条折痕，创建根结点；</li><li>如果不是第一次对折，则使用队列保存根结点；</li><li>循环遍历队列：</li><li>1 从队列中拿出一个结点；</li><li>2 如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；</li><li>3 如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</li><li>4 判断当前结点的左子结点和右子结点是否都为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperFolding</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//构建折痕树</span>        Node tree = createTree(<span class="hljs-number">2</span>);        <span class="hljs-comment">//遍历折痕树，并打印</span>        printTree(tree);    &#125;    <span class="hljs-comment">// 定义结点类</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-comment">//存储结点元素</span>        String item;        <span class="hljs-comment">//左子结点</span>        Node left;        <span class="hljs-comment">//右子结点</span>        Node right;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String item, Node left, Node right)</span> </span>&#123;            <span class="hljs-keyword">this</span>.item = item;            <span class="hljs-keyword">this</span>.left = left;            <span class="hljs-keyword">this</span>.right = right;        &#125;    &#125;    <span class="hljs-comment">// 使用中序遍历，打印树中的所有节点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(Node tree)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (tree.left != <span class="hljs-keyword">null</span>) &#123;            printTree(tree.left);        &#125;        System.out.print(tree.item + <span class="hljs-string">" "</span>);        <span class="hljs-keyword">if</span> (tree.right != <span class="hljs-keyword">null</span>) &#123;            printTree(tree.right);        &#125;    &#125;    <span class="hljs-comment">// 构建深度为N的折痕树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Node root = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//1.第一次对折，只有一条折痕，创建根结点；</span>                root = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">"down"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//2.如果不是第一次对折，则使用队列保存根结点；</span>                Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;&gt;();                queue.enqueue(root);                <span class="hljs-comment">//3.循环遍历队列：</span>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    <span class="hljs-comment">//3.1从队列中拿出一个结点</span>                    Node tmp = queue.dequeue();                    <span class="hljs-comment">//3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中</span>                    <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>) &#123;                        queue.enqueue(tmp.left);                    &#125;                    <span class="hljs-comment">//3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中</span>                    <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>) &#123;                        queue.enqueue(tmp.right);                    &#125;                    <span class="hljs-comment">//3.4判断当前结点的左子结点和右子结点是否都为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</span>                    <span class="hljs-keyword">if</span> (tmp.left == <span class="hljs-keyword">null</span> &amp;&amp; tmp.right == <span class="hljs-keyword">null</span>) &#123;                        tmp.left = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">"down"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                        tmp.right = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">"up"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树最大深度和最小深度问题</title>
    <link href="/cxlittlecute/bb5d33c4.html"/>
    <url>/cxlittlecute/bb5d33c4.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树最大深度和最小深度问题"><a href="#二叉树最大深度和最小深度问题" class="headerlink" title="二叉树最大深度和最小深度问题"></a>二叉树最大深度和最小深度问题</h1><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>最大深度：树的根节点到最远叶子结点的最长路径上的结点数。</p><p>实现步骤：</p><ol><li>如果根结点为空，则最大深度为0；</li><li>计算左子树的最大深度；</li><li>计算右子树的最大深度；</li><li>当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 计算指定树x的最大深度</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node x)</span></span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// x的最大深度</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 左子树的最大深度</span>    <span class="hljs-keyword">int</span> maxL = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 右子树的最大深度</span>    <span class="hljs-keyword">int</span> maxR = <span class="hljs-number">0</span>;    <span class="hljs-comment">//2.计算左子树的最大深度；</span>    <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;        maxL = maxDepth(x.left);    &#125;    <span class="hljs-comment">//3.计算右子树的最大深度；</span>    <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;        maxR = maxDepth(x.right);    &#125;    <span class="hljs-comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span>    max = maxL &gt; maxR ? maxL + <span class="hljs-number">1</span> : maxR + <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h2 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h2><p>最小深度：从根节点到最近叶节点的最短路径上的节点数。</p><p>实现步骤：</p><ol><li>如果根结点为空，则最小深度为0；</li><li>如果左子树为空，右子树不为空，最小深度=右子树的最小深度+1；</li><li>如果右子树为空，左子树不为空，最小深度=左子树的最小深度+1；</li><li>当前树的最小深度=左子树的最小深度和右子树的最小深度中的较小者+1。</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> minDepth(root);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(Node x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> minDepth(x.right) + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> minDepth(x.left) + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> Math.min(minDepth(x.left), minDepth(x.right)) + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的基本遍历</title>
    <link href="/cxlittlecute/86071d60.html"/>
    <url>/cxlittlecute/86071d60.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的基本遍历"><a href="#二叉树的基本遍历" class="headerlink" title="二叉树的基本遍历"></a>二叉树的基本遍历</h1><p>树需要我们选择用什么样的搜索路径进行遍历。</p><p>我们可以把树看做一个根节点、一个左子树、一个右子树组成，按照根节点什么时候被访问，我们可以分为以下四种情况：</p><ol><li>前序遍历:<br>先访问根结点，然后再访问左子树，最后访问右子树。</li><li>中序遍历:<br>先访问左子树，中间访问根节点，最后访问右子树。</li><li>后序遍历:<br>先访问左子树，再访问右子树，最后访问根节点。</li><li>层序遍历:<br>从根节点（第一层）开始，依次向下，获取每一层所有结点的值。</li></ol><p>通过以下的图例我们可以得到三种遍历的结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200728142006.png" srcset="/img/loading.gif" alt=""></p><p>那么接下来我们就通过代码分别实现这三种遍历方式。</p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>实现步骤：</p><ol><li>把当前结点的key放入到队列中;</li><li>找到当前结点的左子树，如果不为空，递归遍历左子树;</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用前序遍历，获取整个树中的所有键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">preErgodic</span><span class="hljs-params">()</span> </span>&#123;    Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    preErgodic(root, keys);    <span class="hljs-keyword">return</span> keys;&#125;<span class="hljs-comment">// 使用前序遍历，把指定树x中的所有键放入到keys队列中</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preErgodic</span><span class="hljs-params">(Node x, Queue&lt;Key&gt; keys)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 1.将当前结点的key放入结点中</span>    keys.add((Key) x.key);    <span class="hljs-comment">// 2.找到当前结点的左子树，如果不为空，递归遍历左子树</span>    <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;        preErgodic(x.left, keys);    &#125;    <span class="hljs-comment">// 3.找到当前结点的右子树，如果不为空，递归遍历右子树</span>    <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;        preErgodic(x.right, keys);    &#125;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.preErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>实现步骤：</p><ol><li>找到当前结点的左子树，如果不为空，递归遍历左子树；</li><li>把当前结点的key放入到队列中;</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用中序遍历，获取整个树中的所有键</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">midErgodic</span><span class="hljs-params">()</span> </span>&#123;     Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();     midErgodic(root, keys);     <span class="hljs-keyword">return</span> keys; &#125; <span class="hljs-comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midErgodic</span><span class="hljs-params">(Node x, Queue&lt;Key&gt; keys)</span> </span>&#123;     <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;     &#125;     <span class="hljs-comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span>     <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;         midErgodic(x.left, keys);     &#125;     <span class="hljs-comment">//2.把当前结点的key放入到队列中;</span>     keys.add((Key) x.key);     <span class="hljs-comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span>     <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;         midErgodic(x.right, keys);     &#125; &#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.midErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>实现步骤：</p><ol><li>找到当前结点的左子树，如果不为空，递归遍历左子树;</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树;</li><li>把当前结点的key放入到队列中。</li></ol><pre><code class="hljs java"><span class="hljs-comment">//使用后序遍历，获取整个树中的所有键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">afterErgodic</span><span class="hljs-params">()</span></span>&#123;    Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    afterErgodic(root,keys);    <span class="hljs-keyword">return</span> keys;&#125;<span class="hljs-comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span></span>&#123;    <span class="hljs-keyword">if</span> (x==<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span>    <span class="hljs-keyword">if</span> (x.left!=<span class="hljs-keyword">null</span>)&#123;        afterErgodic(x.left,keys);    &#125;    <span class="hljs-comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span>    <span class="hljs-keyword">if</span> (x.right!=<span class="hljs-keyword">null</span>)&#123;        afterErgodic(x.right,keys);    &#125;    <span class="hljs-comment">//3. 把当前结点的key放入到队列中;</span>    keys.add((Key) x.key);&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.afterErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200728154653.png" srcset="/img/loading.gif" alt=""></p><p>层序遍历结果为： EBGADFHC</p><p>对上图进行层序遍历图例分析：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200728155023.png" srcset="/img/loading.gif" alt=""></p><p>实现步骤：</p><ol><li>创建队列，存储每一层的结点；</li><li>使用循环从队列中弹出一个结点：<br> 2.1 获取当前结点的key；<br> 2.2 如果当前结点的左子结点不为空，则把左子结点放入到队列中。<br> 2.3 如果当前结点的右子结点不为空，则把右子结点放入到队列中。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用层序遍历得到树中所有的键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">layerErgodic</span><span class="hljs-params">()</span> </span>&#123;    Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Queue&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    nodes.add(root);    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;        Node x = nodes.poll();        keys.add((Key) x.key);        <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;            nodes.add(x.left);        &#125;        <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;            nodes.add(x.right);        &#125;    &#125;    <span class="hljs-keyword">return</span> keys;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.layerErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉查找树的创建</title>
    <link href="/cxlittlecute/16592e4a.html"/>
    <url>/cxlittlecute/16592e4a.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h1><h2 id="二叉树的基本定义"><a href="#二叉树的基本定义" class="headerlink" title="二叉树的基本定义"></a>二叉树的基本定义</h2><p>首先我们来回顾一下什么是二叉树，二叉树有哪些分类。</p><ul><li><p>二叉树：<br>  二叉树就是度不超过 2的树(每个结点最多有两个子结点)。</p><p>  <img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727153402.png" srcset="/img/loading.gif" alt=""></p></li><li><p>满二叉树：<br>  一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。节点数的计算n=2^k - 1,k表示深度，也就是层数，第i层的节点数n= 2^(i- 1),它的节点数是一系列固定的数，如果节点数不是序列中的数的话，就不是满二叉树</p><p>  <img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727153507.png" srcset="/img/loading.gif" alt=""></p></li><li><p>完全二叉树<br>  叶节点只能出现在最下层和次下层，当二叉树的深度为h时，它的h层节点必须都是连续靠左并不可隔开的(满二叉树也符合)，并且1～h-1层的结点数都达到最大个数(即1~h-1层为一个满二叉树)。<br>  （也就是说我们往完全二叉树放元素的时候，我们都是在非满的一层从左往右放结点）</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727154354.png" srcset="/img/loading.gif" alt=""></p><p>注意：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。</p><h2 id="二叉查找树的创建-1"><a href="#二叉查找树的创建-1" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h2><p>我们根据上面的图看出，树其实就是一个个结点组成的，那么我们就利用面向对象的思想，来设计二叉树。</p><ol><li><p>创建Node结点类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">Key</span>, <span class="hljs-title">Value</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Node left;    <span class="hljs-comment">// 记录左子结点</span>    <span class="hljs-keyword">public</span> Node right;   <span class="hljs-comment">// 记录左子结点</span>    <span class="hljs-keyword">public</span> Key key;      <span class="hljs-comment">// 存储键</span>    <span class="hljs-keyword">public</span> Value value;  <span class="hljs-comment">// 存储值</span>    <span class="hljs-comment">// 创建Node对象</span>    Node(Key key, Value value, Node left, Node right) &#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;</code></pre></li><li><p>插入方法put（）实现分析：</p><ul><li><p>如果当前树中没有任何一个结点，则直接把新结点当做根结点使用。</p></li><li><p>如果当前树不为空，则从根结点开始：（三种情况）</p><ul><li>如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</li><li>如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</li><li>如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</li></ul></li></ul></li></ol><pre><code class="hljs java"><span class="hljs-comment">//向树中添加元素key-value</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key, Value value)</span> </span>&#123;    root = put(root, key, value);&#125;<span class="hljs-comment">//向指定的树x中添加key-value,并返回添加元素后新的树</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x, Key key, Value value)</span> </span>&#123;    <span class="hljs-comment">//如果x子树为空，</span>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        N++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key, value, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//如果x子树不为空</span>    <span class="hljs-comment">//比较x结点的键和key的大小：</span>    <span class="hljs-keyword">int</span> cmp = key.compareTo(x.key);    <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key大于x结点的键，则继续找x结点的右子树</span>        x.right = put(x.right, key, value);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>        x.left = put(x.left, key, value);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果key等于x结点的键，则替换x结点的值为value即可</span>        x.value = value;    &#125;    <span class="hljs-keyword">return</span> x;&#125;</code></pre><ol start="3"><li><p>查询方法get实现分析：</p><p> 从根节点开始：</p><ul><li>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</li><li>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</li><li>如果要查询的key等于当前结点的key，则树中返回当前结点的value。</li></ul></li></ol><pre><code class="hljs java"><span class="hljs-comment">//查询树中指定key对应的value</span><span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Key key)</span> </span>&#123;    <span class="hljs-keyword">return</span> get(root, key);&#125;<span class="hljs-comment">//从指定的树x中，查找key对应的值</span><span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Node x, Key key)</span> </span>&#123;    <span class="hljs-comment">//x树为null</span>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//x树不为null</span>    <span class="hljs-comment">//比较key和x结点的键的大小</span>    <span class="hljs-keyword">int</span> cmp = key.compareTo(x.key);    <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key大于x结点的键，则继续找x结点的右子树</span>        <span class="hljs-keyword">return</span> get(x.right, key);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>        <span class="hljs-keyword">return</span> get(x.left, key);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可</span>        <span class="hljs-keyword">return</span> x.value;    &#125;&#125;</code></pre><ol start="4"><li><p>删除方法delete()实现分析：</p><ul><li>找到被删除结点；</li><li>找到被删除结点右子树中的最小结点minNode</li><li>删除右子树中的最小结点</li><li>让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树</li><li>让被删除结点的父节点指向最小结点minNode</li></ul></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span>&lt;<span class="hljs-title">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Key</span>&gt;, <span class="hljs-title">Value</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Node root; <span class="hljs-comment">//记录根结点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> N; <span class="hljs-comment">//记录树中元素的个数</span>    <span class="hljs-comment">// 向树中插入一个键值对</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key, Value value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.root = put(root, key, value);    &#125;    <span class="hljs-comment">// 给指定树x上，添加键一个键值对，并返回添加后的新树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x, Key key, Value val)</span> </span>&#123;        <span class="hljs-comment">// 如果root为空也就是没有root结点，则将当前结点作为root结点</span>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            N++;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node&lt;Key, Value&gt;(key, val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-comment">// 如果不为空，就需要比较结点的key大小</span>        <span class="hljs-keyword">int</span> cmp = key.compareTo((Key) x.key);        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;            x.right = put(x.right, key, val);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>            x.left = put(x.left, key, val);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果key等于x结点的键，则替换x结点的值为value即可</span>            x.value = val;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-comment">// 根据key，从树中找出对应的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Key key)</span> </span>&#123;        <span class="hljs-keyword">return</span> get(root, key);    &#125;    <span class="hljs-comment">// 从指定的树x中，找出key对应的值</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Node x, Key key)</span> </span>&#123;        <span class="hljs-comment">// x为null</span>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// x树不为空</span>        <span class="hljs-comment">// 比较key和x结点的键的大小</span>        <span class="hljs-keyword">int</span> cmp = key.compareTo((Key) x.key);        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果key大于x结点的键，则继续找x结点的右子树</span>            <span class="hljs-keyword">return</span> get(x.right, key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>            <span class="hljs-keyword">return</span> get(x.left, key);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可</span>            <span class="hljs-keyword">return</span> (Value) x.value;        &#125;    &#125;    <span class="hljs-comment">// 根据key，删除树中对应的键值对</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Key key)</span> </span>&#123;        delete(root, key);    &#125;    <span class="hljs-comment">// 删除指定树x上的键为key的键值对，并返回删除后的新树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node x, Key key)</span> </span>&#123;        <span class="hljs-comment">// x树为null</span>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// x树不为null</span>        <span class="hljs-keyword">int</span> cmp = key.compareTo((Key) x.key);        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果key大于x结点的键，则继续找x结点的右子树</span>            x.right = delete(x.right, key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>            x.left = delete(x.left, key);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 让元素个数-1</span>            N--;            <span class="hljs-comment">//如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；</span>            <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 右子树为空</span>                <span class="hljs-keyword">return</span> x.left;            &#125;            <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 左子树为空</span>                <span class="hljs-keyword">return</span> x.right;            &#125;            <span class="hljs-comment">// 得找到右子树中最小的结点</span>            Node minNode = x.right;            <span class="hljs-keyword">while</span> (minNode.left != <span class="hljs-keyword">null</span>)&#123;                minNode = minNode.left;            &#125;            <span class="hljs-comment">// 删除右子树中最小的结点</span>            Node n = x.right;            <span class="hljs-keyword">while</span> (n.left != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">if</span> (n.left.left == <span class="hljs-keyword">null</span>)&#123;                    n.left = <span class="hljs-keyword">null</span>;                &#125;<span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 变换n结点即可</span>                    n = n.left;                &#125;            &#125;            <span class="hljs-comment">// 让x结点的左子树成为minNode的左子树</span>            minNode.left = x.left;            <span class="hljs-comment">// 让x结点的右子树成为minNode的右子树</span>            minNode.right = x.right;            <span class="hljs-comment">// 让x结点的父结点指向minNode</span>            x = minNode;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-comment">// 获取树中元素的个数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> N;    &#125;&#125;</code></pre><ol start="5"><li>测试：<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BinaryTree&lt;Integer, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-number">4</span>, <span class="hljs-string">"二哈"</span>);        bt.put(<span class="hljs-number">1</span>, <span class="hljs-string">"张三"</span>);        bt.put(<span class="hljs-number">3</span>, <span class="hljs-string">"李四"</span>);        bt.put(<span class="hljs-number">5</span>, <span class="hljs-string">"王五"</span>);        System.out.println(bt.size());        bt.put(<span class="hljs-number">1</span>,<span class="hljs-string">"老三"</span>);        System.out.println(bt.get(<span class="hljs-number">1</span>));        System.out.println(bt.size());        bt.delete(<span class="hljs-number">1</span>);        System.out.println(bt.size());        System.out.println(bt.get(<span class="hljs-number">1</span>));    &#125;&#125;</code></pre></li></ol><h2 id="二叉查找树的其他方法："><a href="#二叉查找树的其他方法：" class="headerlink" title="二叉查找树的其他方法："></a>二叉查找树的其他方法：</h2><h3 id="查找二叉树中的最小和最大值"><a href="#查找二叉树中的最小和最大值" class="headerlink" title="查找二叉树中的最小和最大值"></a>查找二叉树中的最小和最大值</h3><p>在某些情况下，我们需要查找出树中存储所有元素的键的最小和最大值，比如我们的树中存储的是学生的排名和姓名数据，那么需要查找出排名最高最低是谁。</p><pre><code class="hljs java"><span class="hljs-comment">//查找整个树中最小的键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (Key) min(root).key;&#125;<span class="hljs-comment">//在指定树x中找出最小键所在的结点</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">min</span><span class="hljs-params">(Node x)</span> </span>&#123;    <span class="hljs-comment">//需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点</span>    <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> min(x.left);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> x;    &#125;&#125;<span class="hljs-comment">//在整个树中找到最大的键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (Key) max(root).key;&#125;<span class="hljs-comment">//在指定的树x中，找到最大的键所在的结点</span><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">max</span><span class="hljs-params">(Node x)</span> </span>&#123;    <span class="hljs-comment">//判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点</span>    <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> max(x.right);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本定义和相关术语</title>
    <link href="/cxlittlecute/291a9097.html"/>
    <url>/cxlittlecute/291a9097.html</url>
    
    <content type="html"><![CDATA[<h1 id="树的基本定义和相关术语"><a href="#树的基本定义和相关术语" class="headerlink" title="树的基本定义和相关术语"></a>树的基本定义和相关术语</h1><p>树的一些基本定义和术语还是很重要的，再次总结它，是为了更好的向别人描述清楚树是什么东西，而不是停留在感觉自己懂，但是讲不清楚的状态。</p><h2 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h2><p>树是一种非常重要的数据结构，主要是它能大量应用于我们生活中的一些事物，例如：家族和单位的组织架构等等。</p><p>树是由（n&gt;=1)个有限结点组成的一个具有层次关系的集合。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727145343.png" srcset="/img/loading.gif" alt=""></p><h2 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h2><ol><li>每个结点有零个或多个子结点。</li><li>根节点没有父节点。</li><li>每一个非根结点只有一个父结点。</li><li>我们可以把每个结点及其子结点整体上看做是一棵树，称为当前结点的父结点的一个子树。</li></ol><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><h4 id="结点的度"><a href="#结点的度" class="headerlink" title="结点的度"></a>结点的度</h4><p>一个结点拥有子结点的数量称为该结点的度。</p><h4 id="叶结点"><a href="#叶结点" class="headerlink" title="叶结点"></a>叶结点</h4><p>度为0的结点称为叶结点，也可以叫做终端结点。</p><h4 id="分支结点"><a href="#分支结点" class="headerlink" title="分支结点"></a>分支结点</h4><p>度不为0的结点称为分支结点，也可以叫做非终端结点。</p><h4 id="结点的层次"><a href="#结点的层次" class="headerlink" title="结点的层次"></a>结点的层次</h4><p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。</p><h4 id="结点的层序编号"><a href="#结点的层序编号" class="headerlink" title="结点的层序编号"></a>结点的层序编号</h4><p> 将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p><h4 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h4><p>树中所以结点的度的最大值。</p><h4 id="树的高度-深度"><a href="#树的高度-深度" class="headerlink" title="树的高度(深度)"></a>树的高度(深度)</h4><p>树中结点的最大层次</p><h4 id="孩子结点"><a href="#孩子结点" class="headerlink" title="孩子结点"></a>孩子结点</h4><p>一个结点的直接后继结点称为该结点的孩子结点。</p><h4 id="双亲结点-父结点"><a href="#双亲结点-父结点" class="headerlink" title="双亲结点(父结点)"></a>双亲结点(父结点)</h4><p>一个结点的直接前驱称为该结点的双亲结点。</p><h4 id="兄弟结点"><a href="#兄弟结点" class="headerlink" title="兄弟结点"></a>兄弟结点</h4><p>同一双亲结点的孩子结点间互称兄弟结点。</p><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><p>m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727151238.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hashcode和equals方法为什么要重写</title>
    <link href="/cxlittlecute/910e2ef6.html"/>
    <url>/cxlittlecute/910e2ef6.html</url>
    
    <content type="html"><![CDATA[<h1 id="hashcode和equals方法为什么要重写"><a href="#hashcode和equals方法为什么要重写" class="headerlink" title="hashcode和equals方法为什么要重写"></a>hashcode和equals方法为什么要重写</h1><p>我们知道Java的顶级父类Object中有两个方法，经常被重写，一个是equals()另一个是hashcode。而且只要我们重写了equals方法我们就必须重写hashcode。</p><p>那么我们的疑问就是为什么要这样，如果我们不同时重写它们两个方法又会发生什么事情了？</p><h2 id="Object源码分析"><a href="#Object源码分析" class="headerlink" title="Object源码分析"></a>Object源码分析</h2><p>我们首先来看一看在Object类中的equals和hashcode：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == var1;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;</code></pre><p>我们可以看到Object类中的equals方法，在不被重写的情况下，使用是和我们==比较是一样的。比较的是非空对象的引用地址，而非对象本身的字符串内容或数值是否相同。</p><p>（==和equals的区别可查看我的另一篇文章：<a href="http://ccctop.cn/cxlittlecute/f30662c7.html）" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/f30662c7.html）</a></p><p>hashcode方法被native关键字修饰，如果不了解native关键字下面简单介绍了一下：</p><p>1、一个native方法就是一个Java调用非Java代码的接口。一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。</p><p>2、在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外面实现的。</p><p>3、因为JAVA无法对操作系统底层进行操作，但是可以通过jni(java native interface)调用其他语言来实现底层的访问。</p><p>hashCode方法本质就是一个哈希函数，就是将我们对象的地址映射为Integer类型的哈希值。</p><p>同时在Object类中规定：当我们将equals方法重写后有必要将hashCode方法也重写，这样做才能保证不违背hashCode方法中“相同对象必须有相同哈希值”的约定。</p><h2 id="为什么要遵循相同对象必须有相同哈希值的约定了？"><a href="#为什么要遵循相同对象必须有相同哈希值的约定了？" class="headerlink" title="为什么要遵循相同对象必须有相同哈希值的约定了？"></a>为什么要遵循相同对象必须有相同哈希值的约定了？</h2><p>在hashCode方法注释中，我们可以知道：</p><ol><li>一个对象多次调用它的hashCode方法，应当返回相同的integer（哈希值）。</li><li>两个对象如果通过equals方法判定为相等，那么就应当返回相同integer。</li><li>两个地址值不相等的对象调用hashCode方法不要求返回不相等的integer。</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200726184559.png" srcset="/img/loading.gif" alt=""></p><p>也就是说这是一条规范，如果不这样做就会导致Object类无法结合所有基于散列的集合（HashMap,HashSet,HashTable）一起正常运作。</p><p>如果相同的对象也就是，重写了equals比较返回true的对象，不重写hashcode,导致具有不同的hashCode，那么将对象放入hashMap中，对象会被存放到不同的桶中，当去get 时，虽然是同一个对象，但是由于生成的hashCode不同，会到不同的桶中去找，此时便找不到那个对象。</p><p>所以我们的equals方法必须要和hashcode配套使用。hashcode方法要做的事情就是，当equals方法认定为相同的对象时，要返回相同的哈希值。</p><h2 id="为什么说不重写它们两个方法在集合中就不能使用了？"><a href="#为什么说不重写它们两个方法在集合中就不能使用了？" class="headerlink" title="为什么说不重写它们两个方法在集合中就不能使用了？"></a>为什么说不重写它们两个方法在集合中就不能使用了？</h2><p>根据上面我们知道了，hashCode方法是根据对象的地址生成的一个Integer整数，默认它和地址一一对应的，如果不重写，那么只有对象地址一样的情况下，哈希值才相等。</p><p>equals默认用来比较地址是否相同，但当集合中元素增多时，再使用equals判断，效率是比较低的；而哈希值是可以快速定位到指定的元素的，所以默认Java就使用哈希值来比较定位，因此有了Object.hashCode的约定。</p><p>总结：除非你能保证你重写equals的类不被Set,Map使用，否则你就必须同时重写equals和hashCode。</p><p>1.使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</p><p>2.保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</p><h2 id="如何重写equals与hashCode？"><a href="#如何重写equals与hashCode？" class="headerlink" title="如何重写equals与hashCode？"></a>如何重写equals与hashCode？</h2><ol><li>重写equals：<ul><li>通过==判断是否是同一个引用</li><li>通过instanceof判断是否是相同类型</li><li>把参数转为正确的类型</li><li>对比双方各个属性值是否相同<pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;     <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;     Goods goods = (Goods) o;     <span class="hljs-keyword">return</span> Double.compare(goods.price, price) == <span class="hljs-number">0</span> &amp;&amp;             Objects.equals(name, goods.name); &#125;</code></pre></li></ul></li></ol><ol start="2"><li>重写hashCode<ul><li>hashCode方法应该为“不相等的对象产生不相等的哈希值”</li><li>计算是根据你equals中用来比较的属性的hashCode组合计算的，不过目前JDK和一些类库已经给我提供了很好的重写方式<pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Objects.hash(name, price);&#125;</code></pre>或者使用lombok：<pre><code class="hljs java"><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>, <span class="hljs-title">Comparator</span> </span>&#123;&#125;</code></pre></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；</li><li>重写equals()必须重写hashCode()，二者参与计算的自身属性字段应该相同；</li><li>hash类型的存储结构，添加元素重复性校验的标准就是先取hashCode值，后判断equals()；</li><li>equals()相等的两个对象，hashcode()一定相等；</li><li>反过来：hashcode()不等，一定能推出equals()也不等；<br>hashcode()相等，equals()可能相等，也可能不等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的DFS和BFS</title>
    <link href="/cxlittlecute/e494e2f9.html"/>
    <url>/cxlittlecute/e494e2f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h1><p>上一篇博客记录了自己初次学习图遍历的代码实现方法，有朋友评论讲的过于细致化，今天刚好重新参考看了一篇博客的实现，相比来说确实要简单明了很多，于是再次记录关于DFS和BFS的相关内容。</p><p>上一篇博客：<a href="http://ccctop.cn/cxlittlecute/f1a8c9e2.html" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/f1a8c9e2.html</a></p><p>如果上一篇博客没有太明白的朋友，可以参考看一看这一篇。</p><p>上一篇博客我们说了图的实现方式主要是邻接矩阵和邻接表，那么今天我们就用邻接表再次分析图的DFS和BFS过程。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725204054.png" srcset="/img/loading.gif" alt=""></p><h2 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h2><ul><li>使用一个大小为V的数组 List<Integer>[] head（通图adj[]），把索引看做是顶点</li><li>每个索引处head[v]存储了一个数组或队列，该队列中存储的是所有与该顶点相邻的其他顶点</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> Graph2</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 14:12</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph2</span> </span>&#123;    <span class="hljs-comment">// 记录顶点的个数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> V;    <span class="hljs-comment">// 保存头结点</span>    List&lt;Integer&gt;[] head;    <span class="hljs-comment">// 记录边的数量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;    Graph2(<span class="hljs-keyword">int</span> V) &#123;        <span class="hljs-keyword">this</span>.V = V;        <span class="hljs-keyword">this</span>.E = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> ArrayList[V];        <span class="hljs-comment">// 初始化邻接表中的队列</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; V ;i++)&#123;            head[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        &#125;    &#125;    <span class="hljs-comment">// 获取图中顶点的数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">V</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> V;    &#125;    <span class="hljs-comment">// 获取图中边的数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">E</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> E;    &#125;    <span class="hljs-comment">// 向图中添加一条边</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;        head[v].add(w);        head[w].add(v);        E++;    &#125;    <span class="hljs-comment">//获取和顶点v相邻的所有顶点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">adj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;        <span class="hljs-keyword">return</span> head[v];    &#125;&#125;</code></pre><h2 id="DFS的实现"><a href="#DFS的实现" class="headerlink" title="DFS的实现"></a>DFS的实现</h2><p>所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205248.png" srcset="/img/loading.gif" alt=""></p><p>我们可以根据上图清楚的知道DFS的一个执行顺序。<br>很明显，在由于边是没有方向的，所以，如果 4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true，<br>如果没有搜索，标记为false；</p><p>主要有两点需要注意：</p><ol><li>如果已经访问过的会直接跳过。</li><li>由于是DFS是深度优先，所以我们每次遍历都会以邻接结点为下一次遍历的头。（特点）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearch</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 17:42</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepthFirstSearch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    DepthFirstSearch(Graph2 G,<span class="hljs-keyword">int</span> s)&#123;        <span class="hljs-keyword">this</span>.marked  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        dfs(G,s);    &#125;    <span class="hljs-comment">// 使用深度优先搜索找出G图中v顶点的所有相通顶点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Graph2 G, <span class="hljs-keyword">int</span> v)</span></span>&#123;        System.out.print(v+<span class="hljs-string">"-&gt;"</span>);        <span class="hljs-comment">// 把v顶点标识为以搜索</span>        marked[v] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (Integer w : G.adj(v)) &#123;            <span class="hljs-comment">// 判断有没有被搜索过，如果没有被搜索过则递归调用dfs进行深度搜索</span>            <span class="hljs-keyword">if</span> (!marked[w])&#123;                dfs(G, w);            &#125;        &#125;        count++;    &#125;    <span class="hljs-comment">// 判断w顶点与s顶点是否相通</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">marked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;        <span class="hljs-keyword">return</span> marked[w];    &#125;    <span class="hljs-comment">// 获取与顶点s相通的所有顶点的总数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>照着下面的图片进行建图然后测试：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205322.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearchTest</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 18:32</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepthFirstSearchTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备图</span>        Graph2 graph2 = <span class="hljs-keyword">new</span> Graph2(<span class="hljs-number">13</span>);        <span class="hljs-comment">// 准备结点</span>        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);                graph2.addEdge(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        <span class="hljs-comment">// 准备要DFS搜索的对象</span>        DepthFirstSearch depthFirstSearch = <span class="hljs-keyword">new</span> DepthFirstSearch(graph2, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 测试与某个顶点相同的顶点数量</span>        <span class="hljs-keyword">int</span> count = depthFirstSearch.count();        System.out.println(count);        <span class="hljs-comment">// 测试某个顶点是否与起点想通</span>        <span class="hljs-keyword">boolean</span> marked = depthFirstSearch.marked(<span class="hljs-number">5</span>);        System.out.println(marked);    &#125;&#125;</code></pre><h2 id="BFS实现"><a href="#BFS实现" class="headerlink" title="BFS实现"></a>BFS实现</h2><p>而BFS刚好相反，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205105.png" srcset="/img/loading.gif" alt=""></p><p>如果我们现在以0为顶点，它会先去找0这个顶点的邻接表，也就是有6、2、1、5这几个相邻的顶点，然后我们分别以这几个相邻的点为顶点去找它们的邻接表。（类似于二叉树的层序遍历）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205132.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> BreadthFirstSearch</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 21:02</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadthFirstSearch</span> </span>&#123;    <span class="hljs-comment">// 索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;    <span class="hljs-comment">// 记录有多少个顶点与s顶点相通</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">// 用来存储待搜索邻接表的点</span>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; waitSearch;    <span class="hljs-comment">// 构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点</span>    BreadthFirstSearch(Graph2 G, <span class="hljs-keyword">int</span> s) &#123;        <span class="hljs-keyword">this</span>.marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.waitSearch = <span class="hljs-keyword">new</span> Queue&lt;Integer&gt;();        bfs(G, s);    &#125;    <span class="hljs-comment">// 使用广度优先搜索找出G图中v顶点的所有相邻顶点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Graph2 G, <span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-comment">// 把当前顶点标记为已搜索</span>        marked[v] = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 让顶点v进入队列，待搜索</span>        waitSearch.enqueue(v);        <span class="hljs-comment">// 通过循环，如果队列不为空，则从队列中，则从队列汇总弹出一个待搜索的顶点，进行搜索</span>        <span class="hljs-keyword">while</span> (!waitSearch.isEmpty()) &#123;            <span class="hljs-comment">// 弹出待搜索的顶点</span>            <span class="hljs-keyword">try</span> &#123;                Integer wait = waitSearch.dequeue();                <span class="hljs-comment">// 遍历wait顶点的邻接表</span>                <span class="hljs-keyword">for</span> (Integer w : G.adj(wait)) &#123;                    <span class="hljs-comment">// 判断是否被搜索</span>                    <span class="hljs-keyword">if</span> (!marked[w])&#123;                        bfs(G, w);                    &#125;                &#125;                <span class="hljs-comment">/* 第二种方式：</span><span class="hljs-comment">                for (Integer w : G.adj(wait)) &#123;</span><span class="hljs-comment">                    if (!marked[w])&#123;</span><span class="hljs-comment">                        System.out.print(w+"-&gt;");</span><span class="hljs-comment">                        waitSearch.enqueue(w);</span><span class="hljs-comment">                        marked[w] = true;</span><span class="hljs-comment">                    &#125;</span><span class="hljs-comment">                &#125;*/</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-comment">// 想通的结点+1</span>        count++;    &#125;    <span class="hljs-comment">// 判断w顶点与s顶点是否相通</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">marked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span> </span>&#123;        <span class="hljs-keyword">return</span> marked[w];    &#125;    <span class="hljs-comment">// 获取与顶点s相通的所有顶点的总数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><p>注意：BFS会把兄弟结点访问完毕了，也就是队列中的结点，然后再以队列中的每个结点为头找他们的子结点。</p><p>测试：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearchTest</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 18:32</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadFirstSearchTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备图</span>        Graph2 graph2 = <span class="hljs-keyword">new</span> Graph2(<span class="hljs-number">13</span>);        <span class="hljs-comment">// 准备结点</span>        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        <span class="hljs-comment">// 准备要DFS搜索的对象</span>        BreadthFirstSearch search = <span class="hljs-keyword">new</span> BreadthFirstSearch(graph2, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 测试与某个顶点相同的顶点数量</span>        <span class="hljs-keyword">int</span> count = search.count();        System.out.println(count);        <span class="hljs-comment">// 测试某个顶点是否与起点想通</span>        <span class="hljs-keyword">boolean</span> marked = search.marked(<span class="hljs-number">5</span>);        System.out.println(marked);    &#125;&#125;</code></pre><p>这样的方式实现就会更加明了简单，如果还没有明白的朋友可以debug一下跑一跑。如果还有任何优化建议的朋友，可以在评论区留言，我会第一时间回复。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/cxlittlecute/f1a8c9e2.html"/>
    <url>/cxlittlecute/f1a8c9e2.html</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>所谓的图的遍历就是对图中结点的访问，一个图有很多的结点，我们如何去遍历它们了？</p><p>那么需要我们制定相应的访问策略：</p><ul><li>方式一：深度优先遍历（DFS）</li><li>方式二：广度优先遍历（BFS)</li></ul><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><h3 id="DFS思想"><a href="#DFS思想" class="headerlink" title="DFS思想"></a>DFS思想</h3><ul><li>深度优先遍历，从你定的初始访问结点出发，那么我们初始访问结点可能有很多邻接结点，深度优先遍历的策略就是：首先访问第一个邻接结点，然后再以这个被访问的临界点作为初始结点，访问它的第一个邻接结点。（总之，就是每次访问完当前结点后首先访问当前结点的第一个邻接结点）</li></ul><p>举例：如果说v1-&gt;v2-&gt;v3同时v1-&gt;v3,那么通过DFS仍然是通过v2才访问到v3的。</p><ul><li>我们可以通过上面的例子看到，这种访问策略是优先向纵向挖掘深度，而不是对一个结点的所有邻接结点进行横向访问。</li><li>DFS是一个递归过程。</li></ul><h3 id="DFS算法步骤"><a href="#DFS算法步骤" class="headerlink" title="DFS算法步骤"></a>DFS算法步骤</h3><ol><li>访问初始结点v,并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当成一个另一个v，进行123操作）</li><li>若w已经被访问了，查找结点v的邻接结点w的下一个邻接结点，进入步骤3</li></ol><h3 id="DFS举例分析"><a href="#DFS举例分析" class="headerlink" title="DFS举例分析"></a>DFS举例分析</h3><p>那么我们举例来分析一下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724144623.png" srcset="/img/loading.gif" alt=""></p><p>我们在集合中存放结点的顺序是ABCDE。<br>那么我们通过DFS遍历的步骤是：</p><ol><li>A的邻接结点为B，B存在同时未被访问，这样就遍历到了B</li><li>接着对B进行DFS递归，把B当成初始结点同上访问到了C</li><li>这个时候我们已经把C当做了初始结点了，C的下一个邻接结点应该是D，但是它们并不是连通的</li><li>于是D就不能马上输出，则执行DFS算法步骤的第3步，从v的下一个结点继续，也就是从B继续</li><li>这个时候发现C已经被访问了，则会查找B的邻接结点C的下一个邻接结点也就是D，这样就能完成我们的DFS遍历。</li></ol><h3 id="DFS代码实现"><a href="#DFS代码实现" class="headerlink" title="DFS代码实现"></a>DFS代码实现</h3><ol><li>定义给数组boolean[],记录某个结点是否被访问过:<pre><code class="hljs java"><span class="hljs-comment">//定义给数组boolean[],记录某个结点是否被访问过</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isVisited;</code></pre></li><li>得到第一个邻接结点的下标w<pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 得到第一个邻接结点的下标w</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 当前结点的下标</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果存在就返回对应下标，否则返回-1</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFirstNeighbor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexList.size(); j++) &#123;        <span class="hljs-keyword">if</span> (edges[index][j] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据矩阵中的值大于0说明当前结点的下一个邻接结点是存在的</span>            <span class="hljs-keyword">return</span> j;        &#125;    &#125;    <span class="hljs-comment">//如果存在就返回对应的下0标否则返回-1</span>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></li><li>根据前一个邻接结点的下标来获取下一个邻接结点 等同于第五步<pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据前一个邻接结点的下标来获取下一个邻接结点 等同于第五步</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v1 结点v</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v2 结点v的邻接结点w</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNeighhor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v2 + <span class="hljs-number">1</span>; j &lt; vertexList.size(); j++) &#123;        <span class="hljs-keyword">if</span> (edges[v1][j] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> j;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></li><li>深度优先遍历算法实现(部分方法衔接 博客：图-<a href="http://ccctop.cn/cxlittlecute/ee040603.html" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/ee040603.html</a>)</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *深度优先遍历算法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isVisited</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i 第一次就是0,等于说进入步骤第一步</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-comment">//首先我们访问该结点，输出</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">"-&gt;"</span>); <span class="hljs-comment">//返回结点i（下标）对应的数据0-&gt;"A"  1-&gt;"B"  2-&gt;"c"</span>    <span class="hljs-comment">//将已经访问的结点设置为已经访问过</span>    isVisited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//查找结点i的第一个邻接结点w  等于步骤第二步</span>    <span class="hljs-keyword">int</span> w = getFirstNeighbor(i);    <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//说明有邻接结点 使用while循环的原因是如果存在就会继续往下递归</span>        <span class="hljs-keyword">if</span> (!isVisited[w]) &#123; <span class="hljs-comment">// 说明没有被访问</span>            dfs(isVisited, w);        &#125;        <span class="hljs-comment">//如果w这个结点已经被访问过,我们就应该访问邻接结点的下一个结点</span>        w = getNextNeighhor(i, w);    &#125;&#125;</code></pre><p>但是写到这里并没有结束，因为我们第3步中-回到第1步，将从v的下一个结点继续，这一步骤还未完成,不然会出现中间有一个结点走不下去程序就结束了。</p><pre><code class="hljs java"><span class="hljs-comment">// 对dfs进行重载</span><span class="hljs-comment">// 因为我们第3步中-回到第1步，将从v的下一个结点继续，这一步骤还未完成,不然会出现中间有一个结点走不下去程序就结束了</span><span class="hljs-comment">// 遍历我们所有的结点，并进行dfs</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 遍历所有的结点，进行dfs【回溯】</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            dfs(isVisited, i);        &#125;    &#125;&#125;</code></pre><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><h3 id="BFS思想"><a href="#BFS思想" class="headerlink" title="BFS思想"></a>BFS思想</h3><p>BFS需要使用一个队列，用来保存访问过的结点的顺序，类似于一个分层搜索的过程，我们使用这个顺序来访问这些结点的邻接结点。</p><h3 id="BFS算法步骤"><a href="#BFS算法步骤" class="headerlink" title="BFS算法步骤"></a>BFS算法步骤</h3><ol><li>访问初始结点v并标记结点v为已访问</li><li>将结点v加入队列</li><li>当队列非空时，继续执行，否则算法结束（这里的算法结束指的是对v这个结点的算法结束）。</li><li>出队列，取得头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行下面三个步骤：<br> 6.1 若结点w未被访问，则访问w并标记为已访问。<br> 6.2 结点w入队列。(w的访问顺序同样也被记录在队列中)<br> 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol><h3 id="BFS举例分析"><a href="#BFS举例分析" class="headerlink" title="BFS举例分析"></a>BFS举例分析</h3><p>我们同样来举例分析一下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724180549.png" srcset="/img/loading.gif" alt=""></p><ol><li>我们还是从A开始，先访问自己，A就输出了</li><li>接着看A的下一个邻接结点B，判断B能访问于是B也就被输出了</li><li>接着就和DFS不一样的地方出现了，我们DFS中时根据B作为新的初始结点去访问C，而我们的BFS中仍是以A为初始结点，去找B结点的邻接结点也就是C，发现C同样也能访问，于是就访问到了C。</li><li>然后再去通过c找它的后继结点，发现找不到了。</li><li>这个时候我们的B已经在队列中，A访问过后已经被弹出了队列，然后就从队列中弹出B（它现在位于队列头）。</li><li>然后根据B去找，发现访问过的就跳过，跳过AC后发现能访问到D，然后又能访问到E。</li><li>最后把剩下的CDE都作为队列头走一圈，发现都访问过了，就退出了。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs java"><span class="hljs-comment">//对一个节点进行广度优先遍历的方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//表示队列头结点对应下标</span>    <span class="hljs-keyword">int</span> w;<span class="hljs-comment">//邻接结点w</span>    <span class="hljs-comment">//队列,记录结点访问的顺序</span>    LinkedList queue = <span class="hljs-keyword">new</span> LinkedList();    <span class="hljs-comment">//访问结点,输出结点信息</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">"-&gt;"</span>);    <span class="hljs-comment">//标记为已访问</span>    isVisited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//将结点加入队列</span>    queue.addLast(i);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-comment">//取出队列的头结点下标</span>        u = (Integer) queue.removeFirst();        <span class="hljs-comment">//得到第一个邻接点的下标 w</span>        w = getFirstNeighbor(u);        <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找到</span>            <span class="hljs-comment">//是否访问过</span>            <span class="hljs-keyword">if</span> (!isVisited[w]) &#123;                System.out.println(getValueByIndex(w) + <span class="hljs-string">"=&gt;"</span>);                <span class="hljs-comment">//标记已经访问</span>                isVisited[w] = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">//入队列</span>                queue.addLast(w);            &#125;            <span class="hljs-comment">//如果访问过了，以U为前驱结点，找w后面的下一个结点</span>            w = getNextNeighhor(u, w);<span class="hljs-comment">//体现了广度优先</span>        &#125;    &#125;&#125;<span class="hljs-comment">//遍历所有的结点，都进行广度优先搜索</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            bfs(isVisited, i);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/cxlittlecute/ee040603.html"/>
    <url>/cxlittlecute/ee040603.html</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>最近复习数据结构和算法，对一些基础知识进行总结和深化。</p><h2 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h2><p>图是一种数据结构，它不同于我们学习的线性表和树，我们的线性表局限于一个直接前驱和一个直接后继的关系，树也只有一个直接前驱的父节点。</p><p>当我们要表示多对多关系的时候我们就需要用到树。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li>顶点（结点）：可以有零个或多个相邻元素。</li><li>边 ：两个结点的连接称为边。</li><li>路径 ： 一个结点到另一个结点的边和。</li></ul><p>无向图：顶点之间的连接没有方向。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112212.png" srcset="/img/loading.gif" alt=""></p><p>有向图：顶点之间有连接方向。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112244.png" srcset="/img/loading.gif" alt=""></p><p>带权图：带有权值的图也称为网。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112325.png" srcset="/img/loading.gif" alt=""></p><h2 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h2><ul><li>方式一：邻接矩阵（二维数组表示）<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724113306.png" srcset="/img/loading.gif" alt=""></li></ul><p>矩阵外的编号代表，图中的编号，0和0也就是自己和自己连，一般用0或者∞表示。1就代表可以直接连接。</p><p>邻接矩阵需要为每个顶点都分配n个边的空间，我们可以发现很多边是没有必要存在的，这样就会造成空间上的浪费。</p><ul><li>方式二：邻接表（链表表示）<br>邻接表的实现只关心存在的边，因此没有空间上的浪费，由数组+链表组成。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724113938.png" srcset="/img/loading.gif" alt=""></p><h2 id="举例创建图"><a href="#举例创建图" class="headerlink" title="举例创建图"></a>举例创建图</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724115625.png" srcset="/img/loading.gif" alt=""></p><p>思路分析：</p><ol><li>创建存储顶点的集合、存储图对应的邻接矩阵、表示该结点有多少条边。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="hljs-comment">//存储顶点集合</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;<span class="hljs-comment">//存储图对应的，邻结矩阵</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;<span class="hljs-comment">//表示边的数目</span></code></pre><p>初始化矩阵：</p><pre><code class="hljs java"><span class="hljs-comment">//构造器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//初始化矩阵和ArrayList</span>    edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];    vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);    numOfEdges = <span class="hljs-number">0</span>;&#125;</code></pre><p>编写方法：</p><pre><code class="hljs java"><span class="hljs-comment">//插入顶点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;    vertexList.add(vertex);&#125;<span class="hljs-comment">//添加边</span><span class="hljs-comment">//v1表示点的下标表示第几个顶点</span><span class="hljs-comment">//v2表示第二个顶点的下标</span><span class="hljs-comment">//weight表示他们之间的关联关系</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;    edges[v1][v2] = weight;    edges[v2][v1] = weight;    numOfEdges++; <span class="hljs-comment">// 每添加一个关系就增加一条边</span>&#125;</code></pre><p>这样一个图的基本构造就出来了，接下来我们再举例几个常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">//图中常用的方法：</span><span class="hljs-comment">//返回结点个数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfVertex</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> vertexList.size();&#125;<span class="hljs-comment">//得到边的数目</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfEdges</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> numOfEdges;&#125;<span class="hljs-comment">//返回结点i（下标）对应的数据0-&gt;"A"  1-&gt;"B"  2-&gt;"c"</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValueByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> vertexList.get(i);&#125;<span class="hljs-comment">//返回v1和v2的权值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;    <span class="hljs-keyword">return</span> edges[v1][v2];&#125;<span class="hljs-comment">//显示图对应的矩阵</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] link : edges) &#123;        System.out.println(Arrays.toString(link));    &#125;&#125;</code></pre><p>最后在main方法中进行真正的构建:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-comment">//结点的个数</span>    String VertexValue[] = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;    <span class="hljs-comment">//创建图对象</span>    Graph graph = <span class="hljs-keyword">new</span> Graph(n);    <span class="hljs-comment">//循环的添加顶点</span>    <span class="hljs-keyword">for</span> (String value : VertexValue) &#123;        graph.insertVertex(value);    &#125;    <span class="hljs-comment">//添加边</span>    <span class="hljs-comment">//A-B A-C B-C B-D B-E</span>    graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//显示</span>    graph.showGraph();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP实现</title>
    <link href="/cxlittlecute/3d4e4ac2.html"/>
    <url>/cxlittlecute/3d4e4ac2.html</url>
    
    <content type="html"><![CDATA[<h1 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h1><p>总结一下使用根据最大长度表实现KMP算法。</p><p>首先，KMP是一个解决模式串在文本串是否出现过，以及若是出现时，最早出现的位置的经典算法。</p><p>我们惯用的思路都是属于暴力匹配：</p><ul><li>如果当前字符匹配成功（即s1[i] == s2[j]），则i++，j++，继续匹配下一个字符；</li><li>如果失配（即s1[i] == s2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 暴力匹配</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">violenceMatch</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] s1 = str1.toCharArray();    <span class="hljs-keyword">char</span>[] s2 = str2.toCharArray();    <span class="hljs-keyword">int</span> s1length = s1.length;    <span class="hljs-keyword">int</span> s2length = s2.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// i指向s1</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// j指向s2</span>    <span class="hljs-keyword">while</span> (i &lt; s1length &amp;&amp; j &lt;s2length) &#123;        <span class="hljs-keyword">if</span> (s1[i] == s2[j]) &#123;            i++;            j++;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有匹配成功</span>            i = i - j + <span class="hljs-number">1</span>;            j = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">// 判断是否匹配成功</span>    <span class="hljs-keyword">if</span> (j == s2length)&#123;        <span class="hljs-keyword">return</span> i - j;    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>如果用暴力方法解决的话就会有大量的回溯造成，因为我们不匹配的时候会j 被置为0，i往后移动一位，但是我们通过分析可以清楚的知道，中间已经匹配过的字符是不用再次匹配的，也就是说不可能匹配上的，但是还是回溯回去做了相同的工作，这样就造成了时间上的大量浪费。</p><p>所以，kmp方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String str1 = <span class="hljs-string">"BBC ABCDAB ABCDABCDABDE"</span>;    <span class="hljs-comment">// String str2 = "ABCDABD";</span>    String str2 = <span class="hljs-string">"ABCDABD"</span>;    <span class="hljs-keyword">int</span>[] next = kmpNext(<span class="hljs-string">"ABCDABD"</span>);    <span class="hljs-comment">//System.out.println(Arrays.toString(next));</span>    <span class="hljs-keyword">int</span> index = kmpSearch(str1, str2, next);    System.out.println(<span class="hljs-string">"index"</span> + index);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kmpSearch</span><span class="hljs-params">(String str1, String str2, <span class="hljs-keyword">int</span>[] next)</span> </span>&#123;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 失配时模式串移动的位数</span>        &#125;        <span class="hljs-keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;            j++;        &#125;        <span class="hljs-keyword">if</span> (j == str2.length()) &#123;            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取到一个字符串（子串）的部分匹配值表（最大长度表）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] kmpNext(String dest) &#123;    <span class="hljs-comment">// 创建一个next数组保存部分匹配值</span>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[dest.length()];    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果字符串的长度为1 部分匹配值就是0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; dest.length(); i++) &#123;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;            j = next[j - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;            j++;        &#125;        next[i] = j;    &#125;    <span class="hljs-keyword">return</span> next;&#125;</code></pre><p>以上方法的KMP实现只需要大家掌握两个地方：</p><ul><li>什么是最大长度表，它是如何计算的（参考下面链接）。</li><li>失配时应该怎么计算模式串移动的位数：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。</li></ul><p>本文只是对KMP进行了简单实现，如果想深入了解可以参考看一下下面的链接，感谢原作者的付出。</p><p>参考链接：<br><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈StringBuilder和StringBuffer</title>
    <link href="/cxlittlecute/b1c49b5c.html"/>
    <url>/cxlittlecute/b1c49b5c.html</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈StringBuilder和StringBuffer"><a href="#浅谈StringBuilder和StringBuffer" class="headerlink" title="浅谈StringBuilder和StringBuffer"></a>浅谈StringBuilder和StringBuffer</h1><p>一个很常见的面试题相信大家都看过，也就是询问StringBuilder和StringBuffer的区别是什么，这个问题大部分人只会考虑线程安不安全的方面。</p><p>也就说StringBuilder:线程不安全，StringBuffer：线程安全。</p><p>那么在这里我们需要多想一下：为什么安全以及不安全，同时它们的内部是如何实现扩容的，它们的toString（）方法的构建是否有区别。</p><h3 id="为什么StringBuffer线程安全？"><a href="#为什么StringBuffer线程安全？" class="headerlink" title="为什么StringBuffer线程安全？"></a>为什么StringBuffer线程安全？</h3><p>线程安全是由于StringBuffer类中的方法都被synchronized关键字所修饰。synchronized修饰在方法上也称为对象锁，多个线程调用同一个对象的同步方法会阻塞，调用不同对象的同步方法不会阻塞。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722215902.png" srcset="/img/loading.gif" alt=""></p><p>所以也就保证了它在多线程的情况下不会出现线程安全问题。</p><p>那么我们接着来分析一下：</p><h3 id="StringBuilder不安全的点又在哪里？"><a href="#StringBuilder不安全的点又在哪里？" class="headerlink" title="StringBuilder不安全的点又在哪里？"></a>StringBuilder不安全的点又在哪里？</h3><p>首先我们根据源码可知StringBuffer和StringBuilder都是继承于AbstractStringBuilder父类。</p><p>父类中有重要的两个变量:</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-keyword">char</span>[] value; <span class="hljs-comment">// 通过字符数组存储字符串的具体内容</span>    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 记录已使用字符数组的数量</span>&#125;</code></pre><p>接着我们看一看StringBuilder方法中append是如何实现的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">super</span>.append(var1);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>它通过调用父类的append方法，那我们接着进去看一看。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.appendNull();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> var2 = var1.length();        <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.count + var2); <span class="hljs-comment">// 确保数组的容量足够，如果容量不够，将对value数组进行扩容</span>        var1.getChars(<span class="hljs-number">0</span>, var2, <span class="hljs-keyword">this</span>.value, <span class="hljs-keyword">this</span>.count);<span class="hljs-comment">// 将需要拼接的StringBuffer型变量str拼接到value数组中</span>        <span class="hljs-keyword">this</span>.count += var2;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><p>那么由于我们的方法没有被synchronized修饰，也就无法保证我们是原子操作。那么当我们多个线程进行数据修改的时候，可能不造成拿到的值，不是另一个线程已经修改的最新值，导致结果出现错误。</p><p>看到这里大家一定也看到了这个ensureCapacityInternal（）方法。</p><h3 id="ensureCapacityInternal（）方法在这里有什么作用？"><a href="#ensureCapacityInternal（）方法在这里有什么作用？" class="headerlink" title="ensureCapacityInternal（）方法在这里有什么作用？"></a>ensureCapacityInternal（）方法在这里有什么作用？</h3><p>ensureCapacityInternal（）方法是检查StringBuilder的对象的原字符数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity（）方法对字符数组进行扩容。</p><p>AbstractStringBuilder类的各个append()方法大同小异。append()方法在追加字符到value数组中之前都会调用ensureCapacityInternal()方法来确保value数组有足够的容量，然后才把字符追加到value数组中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 - <span class="hljs-keyword">this</span>.value.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.value = Arrays.copyOf(<span class="hljs-keyword">this</span>.value, <span class="hljs-keyword">this</span>.newCapacity(var1));    &#125;&#125;</code></pre><p>通过Arrays.copyOf（）函数将原数组的内容复制到新数组，最后将新数组的指针重新指向value。</p><h3 id="StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同"><a href="#StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同" class="headerlink" title="StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同"></a>StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同</h3><p>StringBuffer代码片段：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.toStringCache == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.toStringCache = Arrays.copyOfRange(<span class="hljs-keyword">this</span>.value, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.count);     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">this</span>.toStringCache, <span class="hljs-keyword">true</span>); &#125;</code></pre><p>StringBuilder代码片段：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">this</span>.value, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.count);&#125;</code></pre><p>toString()方法返回一个表示该字符序列的字符串。在StringBuffer中当toStringCache缓存不为null时（表示该StringBuffer对象未被修改），直接返回一个表示该字符序列的字符串。<br>反之，当toStringCache缓存为null时（表示该StringBuffer对象已被修改），调用Arrays类的copyOfRange()静态方法来创建一个新数组和拷贝value数组中的字符到新数组，并将toStringCache指向新数组，然后才返回一个表示该字符序列的字符串。</p><p>通过使用toStringCache缓存，当StringBuffer对象未被修改时，减少了一次创建新数组和拷贝数组的开销。</p><p>而StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p><h3 id="如何扩容？"><a href="#如何扩容？" class="headerlink" title="如何扩容？"></a>如何扩容？</h3><p>我们可以根据源码可知不管是StringBuilder还是StringBuffer都是调用父类的构造方法创建字符数组。<br>默认构造方法设置了value数组的初始容量为16。<br>其他情况概述为设置value数组的初始容量为对象的长度+16，并把String对象中的字符添加到value数组中</p><p>我们在上面提到了他们都会调用父类的ensureCapacityInternal（）方法去检测value数组的容量是否足够，如果不够就涉及到我们的数组扩容，用expandCapacity()方法进行扩容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;        value = Arrays.copyOf(value,                newCapacity(minimumCapacity));    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>; <span class="hljs-comment">// 乘2再加2</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;        newCapacity = minCapacity;    &#125;    <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)        ? hugeCapacity(minCapacity)        : newCapacity;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError(); <span class="hljs-comment">//防溢出</span>    &#125;    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125;</code></pre><p>扩容方式为先将容量乘2再加2，再与所需容量进行比较，若小于所需容量，则取所需容量，后面还有防止溢出的操作，写得非常严谨，获得更新后的容量后，新建一个新的容量的数组，并将之前的数据用Arrays.copyOf()方法复制进去，并更新为新的成员变量value。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建多线程的四种方式</title>
    <link href="/cxlittlecute/459fe412.html"/>
    <url>/cxlittlecute/459fe412.html</url>
    
    <content type="html"><![CDATA[<h1 id="创建多线程的四种方式"><a href="#创建多线程的四种方式" class="headerlink" title="创建多线程的四种方式"></a>创建多线程的四种方式</h1><p>在这里总结一下Java创建多线程的四种方式。</p><p>在Jdk1.5之前创建线程的方式主要是继承Thread类的方式和实现Runnable接口的方式。</p><h2 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h2><ol><li>定义子类继承Thread类</li><li>子类重写Thread类中的run方法。</li><li>创建Thread对象，则创建了线程的对象。</li><li>调用线程的Start方法启动线程，调用run方法。（注意：这里如果是直接用对象调用run方法是不会有新的线程创建的）</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        TestThread tt = <span class="hljs-keyword">new</span> TestThread();        tt.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">":"</span>+i);        &#125;    &#125;&#125;</code></pre><p>注意：<br>生成新的对象并且调用Start方法都是我们主线程做的，当我们调用完start后新的线程就开始执行它的run方法了。</p><h2 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h2><ol><li>定义子类实现Runnable接口。</li><li>子类中重写Runnable接口中的run方法。</li><li>通过Thread类含参构造器创建线程对象。</li><li>将Runnable接口的子类对象作为参数传递给Thread类的构造器中。</li><li>调用Thread类的start方法：开启线程，调用Runnable子类接口中的run方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-meta">@Override</span>　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  　　 System.out.println(<span class="hljs-string">"MyThread"</span>);  　　&#125;  &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        MyThread myThread = <span class="hljs-keyword">new</span> MyThread();          Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);          thread.start();      &#125;&#125;</code></pre><p>那么已经看了两种创建线程的方式了，它们的区别也是很明显的，一个需要继承Thread类，另一个需要实现Runnable接口，那么建议使用的肯定是实现接口的方式去创建线程，原因有主要有两个：</p><ol><li>实现接口可以避免单继承的局限性。</li><li>(重点)多个线程可以共享同一个接口实现类的对象，反之继承的话只能通过static修饰后才能共享对象信息，使用接口的实现非常适合相同线程来处理同一份资源。</li></ol><h2 id="方法三：实现Callable接口"><a href="#方法三：实现Callable接口" class="headerlink" title="方法三：实现Callable接口"></a>方法三：实现Callable接口</h2><ol><li>创建一个实现Callable接口的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象。</li><li>将FutureTask对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start（）</li><li>如果想要返回值。就通过futureTask对象获取Callable中call方法的返回值。</li></ol><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre><p>说到FutureTask类我们就要看一下Future接口，FutureTask类是这个接口的唯一实现类。</p><p>可以对具体的Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。</p><p>FutureTask实现了RunnableFuture这个接口，这个RunnableFuture继承了Runnable, Future接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722164536.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>举例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();        <span class="hljs-comment">// 这里需要借助于FutureTask类</span>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(testThread);        <span class="hljs-keyword">new</span> Thread(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            Object sum = futureTask.get(); <span class="hljs-comment">// 通过get()方法就能获取Callable实现类重写call（）方法中的执行结果</span>            System.out.println(<span class="hljs-string">"获取结果总和为:"</span>+sum);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                sum += i;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程强大？</p><ul><li>重写call（）方法后，可以有返回值。</li><li>这个方法可以抛出异常。</li><li>支持泛型的返回值。</li><li>可以借助于FutureTask类实现更多的功能，比如获取返回结果。</li></ul><h2 id="方法四：实现线程池"><a href="#方法四：实现线程池" class="headerlink" title="方法四：实现线程池"></a>方法四：实现线程池</h2><p>通过Executors工具类、线程池的工厂类，可以创建返回不同类型的线程池。</p><ul><li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池。</li><li>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池。</li><li>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池。</li><li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li></ul><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p><ol><li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行<br>Runnable</li><li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行<br>Callable</li><li>void shutdown() ：关闭连接池</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);        executorService.execute(<span class="hljs-keyword">new</span> NumberThread1()); <span class="hljs-comment">// 适用于Runnable</span>        Future&lt;Integer&gt; submit = executorService.submit(<span class="hljs-keyword">new</span> NumberThread2()); <span class="hljs-comment">// 适用于Callable</span>        Integer integer = submit.get();        System.out.println(integer);        executorService.shutdown();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;            System.out.println(i);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;            sum += i;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据类型 包装类 String之间的相互转换</title>
    <link href="/cxlittlecute/8a035673.html"/>
    <url>/cxlittlecute/8a035673.html</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型-包装类-String之间的相互转换"><a href="#基本数据类型-包装类-String之间的相互转换" class="headerlink" title="基本数据类型 包装类 String之间的相互转换"></a>基本数据类型 包装类 String之间的相互转换</h1><p>类型转换是我们经常会遇到的问题，今天通过本博客进一步总结它的用法。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200721230535.png" srcset="/img/loading.gif" alt=""></p><ul><li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征。</li><li>基本数据类型转变为了包装类，就可以调用类中的方法。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722091807.png" srcset="/img/loading.gif" alt=""></p><p>注意：除了Boolean和Character(没有父类)其他包装类的父类都是Number，我们可以根据以下的源码看出：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722091736.png" srcset="/img/loading.gif" alt=""></p><h2 id="基本数据类型-gt-包装类"><a href="#基本数据类型-gt-包装类" class="headerlink" title="基本数据类型-&gt;包装类"></a>基本数据类型-&gt;包装类</h2><ul><li>调用包装类的构造器</li><li>通过字符串参数</li><li>自动装箱</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 调用包装类的构造器</span>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    Integer integer1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);    System.out.println(integer1.toString());    <span class="hljs-comment">//  通过字符串参数</span>    Integer integer2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"123"</span>);    System.out.println(integer2.toString());&#125;</code></pre><p>但是需要注意，使用字符串转换的时候，如果是以Number为父类的包装类，使用字符串的构造器，里面的参数如果是又有数字又有字母会报错(也就是说参数想转什么类型，参数就必须符合这种结构)，但是Boolean支持这样，只会判断为false。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Integer integer3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"asb123"</span>); <span class="hljs-comment">// 报错，参数必须对应包装类的类型</span>    System.out.println(integer3.toString());    Boolean asb123 = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-string">"asb123"</span>);    System.out.println(asb123); <span class="hljs-comment">// 不会报错，结果为false</span>&#125;</code></pre><p>为什么会这样叻？<br>我们来看看Boolean的源码:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Boolean</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>(parseBoolean(var1));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parseBoolean</span><span class="hljs-params">(String var0)</span> </span>&#123;    <span class="hljs-keyword">return</span> var0 != <span class="hljs-keyword">null</span> &amp;&amp; var0.equalsIgnoreCase(<span class="hljs-string">"true"</span>);&#125;</code></pre><p>在忽略大小写的情况下如果是true那么就是true，如果不是同事不为null，那么都为false。</p><h2 id="包装类-gt-基本数据类型"><a href="#包装类-gt-基本数据类型" class="headerlink" title="包装类-&gt;基本数据类型"></a>包装类-&gt;基本数据类型</h2><p>首先，我们要知道这个操作也是必要的，因为我们的包装类属于类是不能进行加减乘除运算的。</p><ul><li>调用包装类的xxxValue（），你是哪个包装类型就调用哪个value()方法.</li><li>自动拆箱</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span>&#123;    Integer in1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">12</span>);    <span class="hljs-keyword">int</span> i = in1.intValue();    System.out.println(i);&#125;</code></pre><h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>那么说到这里就得说一下自动装箱和自动拆箱了，它属于Jdk5的新特性。我们通过下面的例子理解这个特性：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">20</span>;    test13(num);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">(Object o)</span></span>&#123;    System.out.println(o);&#125;</code></pre><p>上面的这个操作将num放入test13中发现是可以的，这里并不是说我们把Object obj = num,这样理解是不对的，因为int类型和Object类型是没有任何关系的，但为什么又行了？</p><p>因为这里就用到了自动装箱,自动装箱就是这样的,相反有的就是自动拆箱。</p><ul><li>自动装箱：基本数据类型-&gt;包装类</li><li>自动拆箱：包装类-&gt;基本数据类型</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自动装箱</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    Integer integer = i;    <span class="hljs-comment">// 自动拆箱</span>    <span class="hljs-keyword">int</span> i2 = integer;&#125;</code></pre><h2 id="基本数据类型、包装类-gt-String"><a href="#基本数据类型、包装类-gt-String" class="headerlink" title="基本数据类型、包装类-&gt;String"></a>基本数据类型、包装类-&gt;String</h2><ul><li>方式一：连接运算</li><li>方法二：调用String重载的valueOf（Xxx xx）<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test16</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 方式一：</span>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    String str1 = num1 + <span class="hljs-string">""</span>;    <span class="hljs-comment">// 方式二：</span>    <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.3f</span>;    String str2 = String.valueOf(f1);    &#125;</code></pre></li></ul><h2 id="String-gt-基本数据类型、包装类"><a href="#String-gt-基本数据类型、包装类" class="headerlink" title="String-&gt;基本数据类型、包装类"></a>String-&gt;基本数据类型、包装类</h2><ul><li>调用包装类的parseXxx（String x）</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test17</span><span class="hljs-params">()</span></span>&#123;    String str = <span class="hljs-string">"123"</span>;    <span class="hljs-keyword">int</span> i = Integer.parseInt(str);&#125;</code></pre><p>注意：<br>最后再强调一下，字符串转换的时候如果有数字和字母，那么会报错NumberFormatException，除了Boolean特殊一些，可以再看一下上面的源码解析。</p><p>同时因为基本数据类型和包装类两个之间有自动装箱和自行拆箱的特性，所以我们可以把他们两个相对string来说看成一个整体进行转换。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>== 和 equals的区别</title>
    <link href="/cxlittlecute/f30662c7.html"/>
    <url>/cxlittlecute/f30662c7.html</url>
    
    <content type="html"><![CDATA[<h1 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a>== 和 equals的区别</h1><p>那么这是一个比较常见的面试题，在这里还是通过源码的分析再次总结一下。</p><p>举例：<br>比如现在我自定义一个类，然后根据这个类生成了两个对象,这两个对象的值属性都是一样的，比如这个叫tom，那个也叫tom，同时两个的年龄也是20岁。他们使用equals比较的结果是什么？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        People tom1 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"tom"</span>, <span class="hljs-number">20</span>);        People tom2 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"tom"</span>,<span class="hljs-number">20</span>);        System.out.println(tom1.equals(tom2));    &#125;</code></pre><p>如果说你回答true,那么你就错了，说明你误认为Object类中的equals方法比较的是值了。</p><p>那么下面我们就来总结一下它们的区别是什么。</p><p>总结：</p><ul><li>==既可以比较基本类型也可以比较引用类型。对于基本类型是直接比较的值（不一定类型相等），对于引用类型就是比较的内存的地址是否相同，即两个引用是否指向同一个对象实体。</li><li>equals的话，只能适用于引用数据类型，首先它是属于Object类中的方法，如果这个方法没有被当前的类重写那么比较的就是地址，等同于==。</li><li>自定义类相不相同，具体要看有没有重写Object的equals方法来判断。</li><li>通常情况下，我们重写equals方法，会去比较类中的属性值是否相等。（注意：这里便是我们的误区，因为我们经常使用像String这样的类（内部已重写equals方法），导致我们认为我们的自定义类比较的是值）。</li></ul><p>为什么说Object类中的equals方法和==作用相同了？上源码：</p><pre><code class="hljs java"><span class="hljs-comment">// 因为在Object中的equals方法的实现是这样的</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == var1;&#125;</code></pre><p>为什么说String、Data、File、包装类等中比较的是两个对象的值相等了？</p><pre><code class="hljs java"><span class="hljs-comment">// 它们都重写了Object类的equals方法   我们以下面String类为例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == var1) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (var1 <span class="hljs-keyword">instanceof</span> String) &#123;            String var2 = (String)var1;            <span class="hljs-keyword">int</span> var3 = <span class="hljs-keyword">this</span>.value.length;            <span class="hljs-keyword">if</span> (var3 == var2.value.length) &#123;                <span class="hljs-keyword">char</span>[] var4 = <span class="hljs-keyword">this</span>.value;                <span class="hljs-keyword">char</span>[] var5 = var2.value;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var6 = <span class="hljs-number">0</span>; var3-- != <span class="hljs-number">0</span>; ++var6) &#123;                    <span class="hljs-keyword">if</span> (var4[var6] != var5[var6]) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    &#125;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对POP、OOP、AOP、FP的理解</title>
    <link href="/cxlittlecute/60f59bbd.html"/>
    <url>/cxlittlecute/60f59bbd.html</url>
    
    <content type="html"><![CDATA[<h1 id="对POP、OOP、AOP的理解"><a href="#对POP、OOP、AOP的理解" class="headerlink" title="对POP、OOP、AOP的理解"></a>对POP、OOP、AOP的理解</h1><p>记得自己刚进项目组的时候就被师傅问了这样的一个问题，当时没有深入去理解过这个东西，于是今天好好总结分析一下这个问题。</p><h2 id="POP面向过程编程"><a href="#POP面向过程编程" class="headerlink" title="POP面向过程编程"></a>POP面向过程编程</h2><p>大家肯定会问什么是面向过程编程叻？</p><p>首先面向过程编程肯定是以过程为中心，那么我们来分析什么是过程，过程就是你解决问题的步骤，也就是这一步应该怎么做，下一步又应该怎么做，好比说一条流水线，每一步都设计好了，只需要使用的时候按照顺序一步一步的调用就可以了。我认为这就是过程。</p><p>那么加上编程二字了，也就是说我们需要首先分析出解决问题需要什么步骤，然后通过一个个函数去把这些步骤给实现，以什么正在发生为主要目标进行编程，那么串联起来也就是面向过程的编程了。</p><h2 id="OOP面向对象编程"><a href="#OOP面向对象编程" class="headerlink" title="OOP面向对象编程"></a>OOP面向对象编程</h2><p>面向对象编程的中心那肯定就是对象了，那么我们需要把问题中所需要的事物抽象为一个个的实体，将实体的属性和行为统一到类中，可以通过类的实例化出具体的对象，然后这些对象就能完成一系列不同的行为。这就是面向对象编程。</p><p>同时需要注意的是我们建立对象的目的不是为了具体完成某一个步骤，而是为了描述这个对象解决问题的行为。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例如简单分析一下飞机大战的设计：<br>面向过程的设计思路就是首先分析问题的步骤：</p><ol><li>开始游戏</li><li>飞机移动</li><li>绘制画面</li><li>判断是否碰撞</li><li>飞机移动</li><li>绘制画面</li><li>判断是否碰撞</li><li>输出结果</li></ol><p>那么接着我们再用面向对象的思想简单分析一下步骤：</p><ol><li>飞机。行为就是飞行移动。</li><li>界面。绘制游戏画面</li><li>规则。判定游戏的输赢。</li></ol><p>可以明显地看出，面向对象是以具体功能对象来划分问题，而不是步骤。绘制画面，这样的步骤多次出现在面向过程的设计中，很可能出现不同的绘制版本。而面向对象的设计中，绘图只可能在界面对象中出现，从而保证了绘图的统一。而且我们使用面向对象进行编程的话，可扩展性也更好。</p><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p><p>AOP采用横向抽取的机制，能很好的解决OOP通用业务（日志记录、性能统计、安全控制、事务处理、异常处理等）的解耦问题。</p><h2 id="FP函数式编程"><a href="#FP函数式编程" class="headerlink" title="FP函数式编程"></a>FP函数式编程</h2><p>函数式编程的特点就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数，那么在Java8中的Lambda表达式就是很好的体现。</p><p>好处就是代码简洁，开发快速；并且接近自然语言，易于理解。缺点也很明显就是难以编写。</p><p>参考：<br><a href="https://www.cnblogs.com/wyljq/p/12219208.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyljq/p/12219208.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Comparable、Comparator、compareTo 、compare的区别和联系</title>
    <link href="/cxlittlecute/f368ac2a.html"/>
    <url>/cxlittlecute/f368ac2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="Comparable、Comparator、compareTo-、compare的区别和联系"><a href="#Comparable、Comparator、compareTo-、compare的区别和联系" class="headerlink" title="Comparable、Comparator、compareTo 、compare的区别和联系"></a>Comparable、Comparator、compareTo 、compare的区别和联系</h1><p>在Java中经常会涉及到对象的排序问题，对于对象正常情况下，只能比较 == 或 ！=，不能使用 &gt; 或 &lt;，但是在实际开发中，我们又需要对多个对象进行排序，那么就涉及到对象之间的比较大小的问题。那么实现方为以下两种。</p><p>Java实现对象排序的方式有两种：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><p>Comparable和Comparator都是用于比较数据的大小的接口，实现Comparable接口需要重写compareTo方法，实现Comparator接口需要重写compare方法，这两个方法的返回值都是int，用int类型的值来确定比较结果。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    Comparator comparator = <span class="hljs-keyword">new</span> Comparator() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o, Object t1)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;    Comparable comparable = <span class="hljs-keyword">new</span> Comparable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;&#125;</code></pre><h2 id="Comparable自然排序"><a href="#Comparable自然排序" class="headerlink" title="Comparable自然排序"></a>Comparable自然排序</h2><p>默认的时候一般会考虑Comparable。</p><p>Comparable接口的举例说明：</p><ul><li><p>我们一些包装类已经替我们实现了Comparable接口，重写了compareTo方法，我们就能对他们的对象进行大小比较。</p></li><li><p>包装类等重写CompareTo()方法后，默认进行的是从小到大的排列。</p></li><li><p>那么我们重写CompareTo（）的规则是什么了？</p><ol><li>如果当前对象this大于形参对象obj，则返回正整数；</li><li>如果当前对象this小于形参obj，则返回负整数；</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ol></li></ul><p>我们可以一起来看看String类的源码，首先我们可以看到String类实现了Comparable的接口,并且重写了CompareTo（）方法，给出了比较两个String对象大小的方式：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200721144039.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.value.length;    <span class="hljs-keyword">int</span> var3 = var1.value.length;    <span class="hljs-keyword">int</span> var4 = Math.min(var2, var3);    <span class="hljs-keyword">char</span>[] var5 = <span class="hljs-keyword">this</span>.value;    <span class="hljs-keyword">char</span>[] var6 = var1.value;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var7 = <span class="hljs-number">0</span>; var7 &lt; var4; ++var7) &#123;        <span class="hljs-keyword">char</span> var8 = var5[var7];        <span class="hljs-keyword">char</span> var9 = var6[var7];        <span class="hljs-keyword">if</span> (var8 != var9) &#123;            <span class="hljs-keyword">return</span> var8 - var9;        &#125;    &#125;    <span class="hljs-keyword">return</span> var2 - var3;&#125;</code></pre><ul><li>如果自定义类想要进行排序，我们可以去实现Comparable接口，重写CompareTo()方法，在CompareTo（）方法中指明如何排序。不然的话进行排序就会报错。</li></ul><p>比如下面我们创建了一个商品的类，类中包含商品的名字和价格，我们要进行这个对象的排序就需要进行Comparable接口的实现和接口中方法的重写。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparaTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        Goods test1 = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"test1"</span>, <span class="hljs-number">12</span>);        Goods test2 = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"test2"</span>, <span class="hljs-number">13</span>);        Goods[] goods = <span class="hljs-keyword">new</span> Goods[]&#123;test1,test2&#125;;        Arrays.sort(goods);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;    <span class="hljs-comment">// 指明Goods类按照什么方式进行排序：按照价格从低到高排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-comment">// 这里和重写equals方法相似</span>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;            <span class="hljs-comment">// 方式一：</span>            <span class="hljs-comment">// 顺便说一下为什么要转换，因为Object类型的引用，调用不了子类Goods的特有属性</span>            Goods goods = (Goods)o; <span class="hljs-comment">// 转换完后当前对象和我们的形参对象就是两个对象了</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.price &gt; goods.price)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.price &lt; goods.price)&#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果价格相等，还需要比较，那么就可以嵌套继续根据名字等进行排序比较</span>                <span class="hljs-comment">// return 0;</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(goods.name);            &#125;            <span class="hljs-comment">// 方式二：</span>            <span class="hljs-comment">// return Double.compare(this.price, goods.price);</span>        &#125;        <span class="hljs-comment">// 如果比较的不是一个商品对象</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"传入的数据类型不一致"</span>);    &#125;&#125;</code></pre><p>注意：实现Comparable接口等于说是在类的基础上做的修改。同时实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p><h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><h3 id="什么时候使用Comparator"><a href="#什么时候使用Comparator" class="headerlink" title="什么时候使用Comparator"></a>什么时候使用Comparator</h3><p>当元素的类型没有实现Comparable接口而又不方便修改代码，或者实现了Comparable接口的排序规则不适合当前的操作，那么我们可以考虑使用Comparator的对象来排序。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>重写compare(Object o1,Object o2)方法。</p><p>如果方法返回正整数，则表示o1大于o2；<br>如果返回0,表示相等；<br>如果返回负整数，表示o1小于02。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"aa"</span>,<span class="hljs-string">"bb"</span>,<span class="hljs-string">"cc"</span>,<span class="hljs-string">"dd"</span>&#125;;    <span class="hljs-comment">// String本身实现了Comparable接口，但是如果我们想要从大到小排序就需要使用Comparator接口重新编写排序逻辑，因为String类的源码我们是没办法修改的。</span>    Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String  o2)</span> </span>&#123;            <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> String)&#123;                String s1 = (String)o1;                String s2 = (String)o2;                <span class="hljs-keyword">return</span> -s1.compareTo(s2);            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);        &#125;    &#125;);    <span class="hljs-comment">// Lambda表达式写法</span>    Arrays.sort(arr,(o1,o2) -&gt; &#123;        <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> String)&#123;            String s1 = (String)o1;            String s2 = (String)o2;            <span class="hljs-keyword">return</span> -s1.compareTo(s2);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);    &#125;);&#125;</code></pre><p>注意：comparator是属于非侵入式的排序实现方式。</p><p>对比：Comparable接口的的方式一旦指定，能够保证Comparable接口实现类在任何位置按照默认实现的方式比较大小，而Comparator属于临时性的比较。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我认为只需要记住Comparable是让对象具有比较的属性，也就是说实现了这个接口的对象之间可以直接互相比较。那么Comparator是比较器，那么实现了这个接口的类就是一个比较器，这个比较器可以应用于对象的比较（它不属于对象的特征，只是一个工具）。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复注解和类型注解</title>
    <link href="/cxlittlecute/d1ceb33.html"/>
    <url>/cxlittlecute/d1ceb33.html</url>
    
    <content type="html"><![CDATA[<h1 id="重复注解和类型注解"><a href="#重复注解和类型注解" class="headerlink" title="重复注解和类型注解"></a>重复注解和类型注解</h1><p>Java8对注解的处理也发生了两点改变：可重复的注解和可用于类型的注解</p><p>要想定义重复注解，该注解必须使用Repeatable修饰一下，同时指定它的容器类。</p><pre><code class="hljs java"><span class="hljs-meta">@Repeatable</span>(MyAnnotations<span class="hljs-class">.<span class="hljs-keyword">class</span>) //指定容器类</span><span class="hljs-class">@<span class="hljs-title">Target</span>(</span>&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "Java 8"</span>;&#125;<span class="hljs-comment">// 定义容器</span><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotations &#123;    MyAnnotation[] value();&#125;</code></pre><p>然后配合反射去使用：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//重复注解</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"Hello"</span>)    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"World"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;        <span class="hljs-comment">// 获取bean class实例</span>        Class&lt;Test&gt; clazz = Test<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        Method test1 = clazz.getMethod(<span class="hljs-string">"test1"</span>);        MyAnnotation[] mas = test1.getAnnotationsByType(MyAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">for</span> (MyAnnotation ma : mas) &#123;            System.out.println(ma.value()); <span class="hljs-comment">// 就能把注解内容获取</span>        &#125;    &#125;&#125;</code></pre><p>类型注解：</p><pre><code class="hljs java"><span class="hljs-meta">@Repeatable</span>(MyAnnotations<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span><span class="hljs-class">@<span class="hljs-title">Target</span>(</span>&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)  <span class="hljs-comment">// 这里</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "Java 8"</span>;&#125;``` 新增ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER（在Target上）。设置之后我们就可以在参数类型前面添加注解了：``` java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//重复注解</span>    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"Hello"</span>)    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"World"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">( @MyAnnotation(<span class="hljs-string">"java"</span>)</span> String str) </span>&#123;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新时间日期API</title>
    <link href="/cxlittlecute/aed0d4.html"/>
    <url>/cxlittlecute/aed0d4.html</url>
    
    <content type="html"><![CDATA[<h1 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h1><p>之前经常使用的Data和Calendar等时间API其实并不怎么好用，麻烦而且存在线程安全问题，所以在JAVA8推出了新的API接口。</p><p>全新的API是不可变的线程安全的。</p><p>时间操作是我们写程序经常会用到的API，所以通过这篇文章进行一个总结。</p><h2 id="本地时间和时间戳"><a href="#本地时间和时间戳" class="headerlink" title="本地时间和时间戳"></a>本地时间和时间戳</h2><ul><li>LocalDate LocalTime LocalDateTime 它们的使用方式都一样  注意都是产生新的实例</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//获取当前时间日期 now</span>    LocalDateTime ldt1 = LocalDateTime.now();    System.out.println(ldt1);    <span class="hljs-comment">//指定时间日期 of</span>    LocalDateTime ldt2 = LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">05</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">24</span>, <span class="hljs-number">33</span>);    System.out.println(ldt2);    <span class="hljs-comment">//加 plus</span>    LocalDateTime ldt3 = ldt2.plusYears(<span class="hljs-number">2</span>);    System.out.println(ldt3);    <span class="hljs-comment">//减 minus</span>    LocalDateTime ldt4 = ldt2.minusMonths(<span class="hljs-number">3</span>);    System.out.println(ldt4);    <span class="hljs-comment">//获取指定的你年月日时分秒... get</span>    System.out.println(ldt2.getDayOfYear());    System.out.println(ldt2.getHour());    System.out.println(ldt2.getSecond());    System.out.println(ldt2.getYear());&#125;</code></pre><ul><li>Instant:时间戳（以 Unix 元年 1970-01-01 00:00:00 到某个时间之间的毫秒值）</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 默认获取 UTC 时区 (UTC：世界协调时间)</span>    Instant ins1 = Instant.now();    System.out.println(ins1);    <span class="hljs-comment">//带偏移量的时间日期 (如：UTC + 8)</span>    OffsetDateTime odt1 = ins1.atOffset(ZoneOffset.ofHours(<span class="hljs-number">8</span>));    System.out.println(odt1);    <span class="hljs-comment">//转换成对应的毫秒值</span>    <span class="hljs-keyword">long</span> milli1 = ins1.toEpochMilli();    System.out.println(milli1);    <span class="hljs-comment">//构建时间戳 加60秒</span>    Instant ins2 = Instant.ofEpochSecond(<span class="hljs-number">60</span>);    System.out.println(ins2);&#125;</code></pre><ul><li>Duration：计算两个时间的间隔</li><li>Period：计算两个日期之间的间隔</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Instant now1 = Instant.now();    Thread.sleep(<span class="hljs-number">1000</span>);    Instant now2 = Instant.now();    Duration between = Duration.between(now1, now2);    <span class="hljs-comment">// 毫秒这里是toXXXX()，秒是getXXX（）</span>    System.out.println(between.toMillis());    System.out.println(<span class="hljs-string">"------------------------------"</span>);    LocalTime lt1 = LocalTime.now();    Thread.sleep(<span class="hljs-number">3000</span>);    LocalTime lt2 = LocalTime.now();    Duration between2 = Duration.between(lt1, lt2);    System.out.println(between.toMillis());    System.out.println(<span class="hljs-string">"-------------注意：上面都是获取时间的间隔-------------"</span>);    System.out.println(<span class="hljs-string">"-------------注意：下面都是获取日期的间隔-------------"</span>);    LocalDate ld1 = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);    LocalDate ld2 = LocalDate.now();    Period period = Period.between(ld2, ld2);    System.out.println(period); <span class="hljs-comment">// 输出的是ISO标准的格式</span>    <span class="hljs-comment">// 可以进一步获取详细信息</span>    System.out.println(period.getYears());    System.out.println(period.getMonths());&#125;</code></pre><h2 id="时间校正器"><a href="#时间校正器" class="headerlink" title="时间校正器"></a>时间校正器</h2><ul><li>TemporalAdjuster：时间校正器。有时我们需要调整日期为想要的时间。这个类是一个接口。</li><li>TemporalAdjusters：该类提供了很多静态方法进行实现。</li></ul><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TemporalAdjuster</span> </span>&#123;    <span class="hljs-function">Temporal <span class="hljs-title">adjustInto</span><span class="hljs-params">(Temporal var1)</span></span>;&#125;</code></pre><p>这里提一下Temporal接口，大家可以看一下LocalDate这些本地时间操作的源码，它是实现了这个Temporal这个接口的，所以Temporal可以根据实际需求表示为日期、时间或两者组合。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    LocalDateTime now = LocalDateTime.now();    <span class="hljs-comment">// 将月中的天数指定为想要的天数</span>    <span class="hljs-comment">// 改为本月十号</span>    LocalDateTime localDateTime = now.withDayOfMonth(<span class="hljs-number">10</span>);    <span class="hljs-comment">// with（）传递一个时间校正器</span>    <span class="hljs-comment">// 下一个周五是什么时候</span>    LocalDateTime with = now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));    System.out.println(with);&#125;</code></pre><p>我们可以根据源码看出TemporalAdjuster是一个函数式接口，那么我们可以通过自定义时间来判断多久是下一个工作日：</p><pre><code class="hljs java">LocalDateTime with1 = now2.with((t) -&gt; &#123;    LocalDateTime ldt4 = (LocalDateTime) t;    DayOfWeek dow1 = ldt4.getDayOfWeek();    <span class="hljs-keyword">if</span> (dow1.equals(DayOfWeek.FRIDAY)) &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dow1.equals(DayOfWeek.SATURDAY)) &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">2</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">1</span>);    &#125;&#125;);System.out.println(with1);</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>-DateTimeFormatter：格式化时间 / 日期</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// DateTimeFormatter后能选择很多种格式化的方式</span>    DateTimeFormatter dtf1 = DateTimeFormatter.ISO_DATE_TIME;    LocalDateTime ldt1 = LocalDateTime.now();    String str1 = ldt1.format(dtf1);    System.out.println(str1);    <span class="hljs-comment">//自定义格式化 ofPattern</span>    DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);    LocalDateTime ldt2 = LocalDateTime.now();    String str2 = ldt2.format(dtf2);    System.out.println(str2);    <span class="hljs-comment">//解析回去 </span>    LocalDateTime newDate = ldt1.parse(str1, dtf1);    System.out.println(newDate);&#125;</code></pre><h2 id="时区操作"><a href="#时区操作" class="headerlink" title="时区操作"></a>时区操作</h2><ul><li>ZonedDate</li><li>ZonedTime</li><li>ZonedDateTime<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//查看支持的所有时区</span>    Set&lt;String&gt; set = ZoneId.getAvailableZoneIds();    set.forEach(System.out::println);    <span class="hljs-comment">//指定时区 构建时间</span>    LocalDateTime ldt1 = LocalDateTime.now(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    System.out.println(ldt1);    <span class="hljs-comment">//在已构建好的日期时间上指定时区</span>    LocalDateTime ldt2 = LocalDateTime.now(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    ZonedDateTime zdt1 = ldt2.atZone(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    System.out.println(ldt2);    System.out.println(zdt1);&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口中的默认方法与静态方法</title>
    <link href="/cxlittlecute/bf52b93a.html"/>
    <url>/cxlittlecute/bf52b93a.html</url>
    
    <content type="html"><![CDATA[<h1 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h1><p>大家查看Java8中源码经常会看到接口中被default或static修饰的方法。<br>在之前接口中只能存在全局静态常量和抽象方法。<br>而现在Java8中可以有被default和static修饰的方法。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><h3 id="为什么要使用default修饰接口中的方法"><a href="#为什么要使用default修饰接口中的方法" class="headerlink" title="为什么要使用default修饰接口中的方法"></a>为什么要使用default修饰接口中的方法</h3><p>引入default主要目的是为了实现接口的升级。因为在原有的Java代码框架中，如果要对接口进行升级就会导致所有接口的实现类都要被<br>修改，这就很麻烦了。</p><p>那么我们在接口内部包含了一些默认的方法实现，为了解决接口的修改与现有的实现不兼容的问题。</p><p>默认方法能够向库的接口添加新功能，并确保与为这些接口的旧版本编写的代码兼容。并且不用在其子类进行逐个实现。</p><p>默认方法的另一个优势是该方法是可选的，子类可以根据不同的需求Override默认实现。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建接口Interface,并且在接口Interface1中定义默认方法helloWorld()。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"test"</span>);    &#125;&#125;</code></pre><p>编写一个类实现接口Interface1,并调用接口中定义的默认方法helloWorld()：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        <span class="hljs-comment">//直接调用helloWorld()方法</span>        myImplement.helloWorld();    &#125;    <span class="hljs-comment">// 执行结果直接输出HelloWorld中的内容。</span>&#125;</code></pre><h3 id="类优先原则"><a href="#类优先原则" class="headerlink" title="类优先原则"></a>类优先原则</h3><p>若一个接口中定义了一个默认方法，而另一个接口或父类中又定义了一个同名的方法时。</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法。（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。（也就是在实现类中重写该方法）</p></li></ul><p>类优先于接口:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"hi i'm from Interface2"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement2 myImplement2 = <span class="hljs-keyword">new</span> MyImplement2();        myImplement2.helloWorld();    &#125;    <span class="hljs-comment">// 结果是MyImplement执行的结果，因为类优先于接口</span>&#125;</code></pre><p>同时实现两个接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>,<span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        <span class="hljs-comment">//直接调用helloWorld()方法</span>        myImplement.helloWorld();    &#125;&#125;</code></pre><p>上面这样同时实现两个接口，恰好两个接口定义的默认方法相同，所以编译器不知道应该执行哪一个就会报错，解决办法就是在实现类中重写该方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>,<span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"testtest"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        myImplement.helloWorld();    &#125;&#125;</code></pre><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>java8中为接口新增了一项功能：定义一个或者更多个静态方法。类似于类中的静态方法，接口定义的静态方法可以独立于任何对象调用。</p><p>所以，在调用静态方法时，不需要实现接口，也不需要接口的实例，也就是说和调用类的静态方法的方式类似。</p><p>语法如：接口名字.静态方法名。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"接口中的静态方法"</span>);    &#125;&#125;<span class="hljs-comment">// 调用</span>MyInterface.show();</code></pre><p>注意，实现接口的类或者子接口不会继承接口中的静态方法。static不能和default同时使用。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optional类</title>
    <link href="/cxlittlecute/2df787ac.html"/>
    <url>/cxlittlecute/2df787ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><h2 id="什么是Optional类"><a href="#什么是Optional类" class="headerlink" title="什么是Optional类"></a>什么是Optional类</h2><p>Optional<T> 类 (java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在用 Optional 可以更好的表达这个概念；并且可以避免空指针异常的发生，还有就是快速定位空指针异常的位置。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>Optional.of(T t)：创建一个 Optional 实例</li><li>Optional.empty(T t)：创建一个空的 Optional 实例</li><li>Optional.ofNullable(T t)：若 t 不为 null，创建 Optional 实例，否则空实例</li><li>isPresent()：判断是否包含某值</li><li>orElse(T t)：如果调用对象包含值，返回该值，否则返回 t</li><li>orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回 s 获取的值</li><li>map(Function f)：如果有值对其处理，并返回处理后的 - Optional，否则返回 Optional.empty()</li><li>flatmap(Function mapper)：与 map 相似，要求返回值必须是 Optional</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Optional.of(T t):</span>    Optional&lt;Employee&gt; op = Optional.of(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 能快速锁定空指针异常的位置</span>    Employee employee = op.get();    System.out.println(employee);    <span class="hljs-comment">// Optional.empty(T t)</span>    Optional&lt;Employee&gt; op = Optional.empty(); <span class="hljs-comment">// 构建空的Optional</span>    Employee employee = op.get();    <span class="hljs-comment">// Optional.ofNullable(T t):</span>    <span class="hljs-comment">/* 源码：</span><span class="hljs-comment">     *     public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T var0) &#123;</span><span class="hljs-comment">     *        return var0 == null ? empty() : of(var0);</span><span class="hljs-comment">     *     &#125;</span><span class="hljs-comment">     * */</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    Employee employee = op.get();    <span class="hljs-comment">// isPresent():</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    <span class="hljs-keyword">if</span> (op.isPresent()) &#123; <span class="hljs-comment">// 是否有值</span>        Employee employee = op.get();    &#125;    <span class="hljs-comment">// orElse(T t)等于说设置默认值，有值就使用对象的值，没有就使用设置的默认值:</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    Employee test = op.orElse(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"test"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22.33</span>)); <span class="hljs-comment">// 避免出现空指针异常</span>    System.out.println(test);    <span class="hljs-comment">// orElseGet(Supplier s):</span>    <span class="hljs-comment">// 函数式接口就意味着你能写任意的功能</span>    op.orElseGet(() -&gt; <span class="hljs-keyword">new</span> Employee());    <span class="hljs-comment">// map(Function f)：</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"test"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22.33</span>));    Optional&lt;Object&gt; o = op.map((e) -&gt; e.getName()); <span class="hljs-comment">// 把容器中的对象应用到函数上</span>    System.out.println(o.get());    <span class="hljs-comment">// flatmap(Function mapper)：</span>    <span class="hljs-comment">// 和map的区别就是返回的值必须被Optional包装起来</span>    Optional&lt;String&gt; str = op.flatMap((e) -&gt; Optional.of(e.getName())); <span class="hljs-comment">// 进一步防止空指针异常</span>    System.out.println(str.get());&#125;</code></pre><p>总结：<br>Optional类给我进行空指针异常的判断提供了很大的便利，之前我们判断空指针异常大多数情况下都是使用if(xxx != null)进行判断，然后根据不同的情况，返回不同的值。</p><p>但是这种使用if的情况，如果需要判断的属性很多，那么if就会出现嵌套很冗余的情况，大量的if反而影响可读性。</p><p>现在有了Java8以后我们就可以选择Optional类，所以我们可以对我们的类属性进行Optional包装。</p><p>下面我们看一个实例，获取男人女神的名字，我通过两种方式避免空指针异常：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewMan</span> </span>&#123;    <span class="hljs-comment">// Optional也属于对象，所以我们不能赋值为null，这样就没有意义了（它自己调用自己的方法也是null），所以我们可以创建一个空的Optional实例</span>    <span class="hljs-keyword">private</span> Optional&lt;Godness&gt; godness = Optional.empty();&#125;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Godness</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Optional&lt;NewMan&gt; newMan)</span></span>&#123;    <span class="hljs-keyword">return</span> newMan.orElse(<span class="hljs-keyword">new</span> NewMan())            .getGodness()            .orElse(<span class="hljs-keyword">new</span> Godness(<span class="hljs-string">"波多野菊衣"</span>));            .getName();&#125;<span class="hljs-comment">// 这里的man中的属性是没有被Optional修饰的</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(Man man)</span></span>&#123;    <span class="hljs-keyword">if</span> (man != <span class="hljs-keyword">null</span>)&#123;        Godness gn = man.getGodness;        <span class="hljs-keyword">if</span> (gn != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> gn.getName;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"波多野菊衣"</span>;&#125;</code></pre><p>通过以上两种方式都可以在对象为null的时候设置默认值避免空指针异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法引用和构造器引用</title>
    <link href="/cxlittlecute/caf276df.html"/>
    <url>/cxlittlecute/caf276df.html</url>
    
    <content type="html"><![CDATA[<h1 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h1><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>若Lambda体中的内容有方法已经实现了，我们可以使用方法引用。（可以说方法引用是Lambda表达式的另一种表现形式）</p><p>主要有三种语法格式：</p><ul><li>对象 :: 实例方法</li><li>类 :: 静态方法</li><li>类 :: 实例方法</li></ul><p>注意：Lambda 表达体中调用方法的参数列表、返回类型必须和函数式接口中抽象方法保持一致。</p><pre><code class="hljs java"><span class="hljs-comment">// 对象：：实例方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    PrintStream ps = System.out; <span class="hljs-comment">// 已经有方法实现，并且参数和返回值一致</span>    Consumer&lt;String&gt; con1 = (s) -&gt; ps.println(s);        <span class="hljs-comment">// 在Lambda体的内容中如果已经有方法完成这个功能的时候，我们就可以使用方法引用的方式代替表达式</span>    <span class="hljs-comment">// 注意：这个函数接口中的抽象方法的参数列表与返回值类型，要与我们当前调用方法的参数和返回值类型保持一致。</span>    PrintStream out = System.out;    Consumer&lt;String&gt; consumer2 = out::print;        Consumer&lt;String&gt; consumer3 = System.out::println;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 类：：静态方法名</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);    System.out.println(com1.compare(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//类：：实例方法名</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y); <span class="hljs-comment">// 其他接口</span>    System.out.println(bp1.test(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>));    BiPredicate&lt;String, String&gt; bp2 = String::equals;    System.out.println(bp2.test(<span class="hljs-string">"c"</span>,<span class="hljs-string">"c"</span>));&#125;</code></pre><p>使用类：：实例方法名调用的条件：</p><p>注意：Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method。<br>如上面x是调用者，y是方法的参数。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><ul><li>ClassName::new</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;    Supplier&lt;List&gt; sup1 = () -&gt; <span class="hljs-keyword">new</span> ArrayList();    Supplier&lt;List&gt; sup2 = ArrayList::<span class="hljs-keyword">new</span>;&#125;</code></pre><p>注意：需要调用的构造器的参数列表要与函数时接口中抽象方法的参数列表保持一致。</p><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><ul><li>Type::new</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    Function&lt;Integer, String[]&gt; function = (x) -&gt; <span class="hljs-keyword">new</span> String[x];    String[] apply = function.apply(<span class="hljs-number">10</span>);    System.out.println(apply.length);    Function&lt;Integer, String[]&gt; function2 = String[]::<span class="hljs-keyword">new</span>;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了类：：实例方法名调用的条件是Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method外。</p><p>其他的都需要Lambda 表达体中调用方法或构造器的参数列表、返回类型必须和函数式接口中抽象方法保持一致。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四大内置核心函数式接口</title>
    <link href="/cxlittlecute/860e391d.html"/>
    <url>/cxlittlecute/860e391d.html</url>
    
    <content type="html"><![CDATA[<h1 id="四大内置核心函数式接口"><a href="#四大内置核心函数式接口" class="headerlink" title="四大内置核心函数式接口"></a>四大内置核心函数式接口</h1><p>写lambda表达式需要有函数式接口支持，并不是说每次用lambda表达式时都要自定义一个函数式接口，实际上，Java8已经为我们准备了java.util.function包，其中有许多非常实用的函数式接口。大致可以分为4种，下面介绍4种核心的接口的典型代表：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719204458.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Comsumer&lt;T&gt;：消费型接口</span><span class="hljs-comment">      *   void accept(T t）;</span><span class="hljs-comment">      * */</span>      Consumer&lt;Integer&gt; consumer = (x) -&gt; System.out.println(x);      consumer.accept(<span class="hljs-number">50</span>);      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Supplier&lt;T&gt;：供给型接口</span><span class="hljs-comment">      *   T get();</span><span class="hljs-comment">      * */</span>      Supplier&lt;Integer&gt; supplier = () -&gt;(<span class="hljs-keyword">int</span>)Math.random()*<span class="hljs-number">10</span>;      supplier.get();      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Function&lt;T,R&gt;：函数型接口</span><span class="hljs-comment">      *   R apply(T t);</span><span class="hljs-comment">      * */</span>      String oldStr = <span class="hljs-string">"123456"</span>;      Function&lt;String, String&gt; function = (s) -&gt; s.substring(<span class="hljs-number">1</span>, s.length()-<span class="hljs-number">1</span>);      System.out.println(function.apply(oldStr));      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Predicate&lt;T&gt;：断言型接口</span><span class="hljs-comment">      *   boolean test(T t)</span><span class="hljs-comment">      * */</span>      <span class="hljs-comment">//Predicate&lt;T&gt;</span>      Integer money = <span class="hljs-number">100</span>;      Predicate&lt;Integer&gt; predicate = (i) -&gt; i &gt;= <span class="hljs-number">100</span>;      <span class="hljs-keyword">if</span> (predicate.test(money))&#123;          System.out.println(<span class="hljs-string">"太贵了"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;          System.out.println(<span class="hljs-string">"还好"</span>);      &#125;  &#125;</code></pre><ul><li>消费型接口典型的代表为Consumer，其抽象方法为accept(), 该方法仅接受一个参数，并且没有返回值。</li><li>供给型接口的典型代表为Supplier，其抽象方法为get(), 该方法不接受参数，但有返回值。</li><li>函数型接口中的代表为Function，其抽象方法位apply(), 接受有一个参数，并且有返回值。</li><li>断言型接口的典型接口为Predicate，其抽象方法为test(), 接受一个参数，并返回一个布尔值。</li></ul><p>通过这些内置函数式接口可以进行一些自定义实现操作，类似于后面的Stream流。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"test1"</span>, <span class="hljs-string">"test2"</span>, <span class="hljs-string">"test3"</span>);    List&lt;String&gt; filter = filter(list, (s) -&gt; s.length() &gt; <span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (String s : filter) &#123;        System.out.println(s);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span> </span>&#123;    List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : list1) &#123;        <span class="hljs-keyword">if</span> (pre.test(s)) &#123;            list1.add(s);        &#125;    &#125;    <span class="hljs-keyword">return</span> list1;&#125;</code></pre><h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719215547.png" srcset="/img/loading.gif" alt=""></p><p>最后我们看一看四大内置函数式接口的源码实现，和我们自己定义的接口只是多了一些default默认方法的实现：</p><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">this</span>.accept(var2);            var1.accept(var2);        &#125;;    &#125;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.apply(var1.apply(var2));        &#125;;    &#125;    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> var1.apply(<span class="hljs-keyword">this</span>.apply(var2));        &#125;;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (var0) -&gt; &#123;            <span class="hljs-keyword">return</span> var0;        &#125;;    &#125;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test(var2) &amp;&amp; var1.test(var2);        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (var1) -&gt; &#123;            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.test(var1);        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test(var2) || var1.test(var2);        &#125;;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object var0)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == var0 ? Objects::isNull : (var1) -&gt; &#123;            <span class="hljs-keyword">return</span> var0.equals(var1);        &#125;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/cxlittlecute/bbcf5ff7.html"/>
    <url>/cxlittlecute/bbcf5ff7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>继续今天愉快的Java8之旅，Lambda表达式和Stream流是Java8中对Java影响最大的两个改变。</p><h2 id="为什么要使用Lambda"><a href="#为什么要使用Lambda" class="headerlink" title="为什么要使用Lambda"></a>为什么要使用Lambda</h2><p>首先Lambda是种匿名函数，它的表达式可以被当做方法传递的代码。然后它能使我们的编程风格更加简洁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 原来的写法</span>    Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> Integer.compare(o1,o2);        &#125;    &#125;;    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(comparator);    <span class="hljs-comment">// Lambda 表达式</span>    Comparator&lt;Integer&gt; comparator2 = (a, b) -&gt; Integer.compare(a, b);    TreeSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(comparator2);&#125;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一、 Lambda表达式引入了一个新的操作符”-&gt;”，该操作符被称为箭头操作符或Lambda操作符。将表达式分为两个部分：</p><p>左侧：表达式参数列表<br>右侧：表达式所要执行的功能，Lambda体</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 语法格式一：无参数，无返回值：() -&gt; sout</span>    Runnable r = ()-&gt; System.out.println(<span class="hljs-string">"hello Lambda"</span>); <span class="hljs-comment">// 同级别如果有变量仍然无法改变它的值</span>    r.run();    <span class="hljs-comment">// 语法格式二：有一个参数，无返回值</span>    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);    con.accept(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 语法格式三：有一个参数，无返回值 （小括号可以省略不写）</span>    Consumer&lt;String&gt; con2 = x -&gt; System.out.println(x);    con2.accept(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 语法格式四：有两个及以上的参数，有返回值，并且 Lambda 体中有多条语句（用&#123;&#125;括起来）</span>    Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123;        System.out.println(<span class="hljs-string">"多个参数并且有多条语句"</span>);        <span class="hljs-keyword">return</span> Integer.compare(x, y);    &#125;;    <span class="hljs-comment">// 语法格式五：有两个及以上的参数，有返回值，并且 Lambda 体中只有1条语句 （大括号 与 return 都可以省略不写）</span>    Comparator&lt;Integer&gt; com2 = (x,y) -&gt; Integer.compare(x, y);    <span class="hljs-comment">// 语法格式六：Lambda 表达式参数的数据类型可以省略不写，因为 Jvm编译器可以通过上下文推断出数据类型- “类型推断”（要写类型全部参数都必须要写）</span>    Comparator&lt;Integer&gt; com3 = (Integer x,Integer y) -&gt; Integer.compare(x, y);&#125;</code></pre><p>口诀：<br>左右遇一括号省<br>左侧推断类型省</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda表达式需要函数式接口的支持。</p><h3 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h3><p>若接口中只有一个抽象方法的接口，称为函数式接口。可以使用注解@FunctionalInterface修饰,可以检查是否是函数式接口。</p><pre><code class="hljs java"><span class="hljs-comment">// 定义一个函数式接口</span><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFun</span> </span>&#123;    <span class="hljs-function">Integer <span class="hljs-title">count</span><span class="hljs-params">(Integer a, Integer b)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">operation</span><span class="hljs-params">(Integer a, Integer b, MyFun myFun)</span></span>&#123;    <span class="hljs-keyword">return</span> myFun.count(a, b); <span class="hljs-comment">// 这样可以定义两个起始值</span>&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span>&#123;    Integer result = operation(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, (x, y) -&gt; x + y);    System.out.println(result);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap理解总结</title>
    <link href="/cxlittlecute/56a14e38.html"/>
    <url>/cxlittlecute/56a14e38.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap理解总结"><a href="#HashMap理解总结" class="headerlink" title="HashMap理解总结"></a>HashMap理解总结</h1><p>最近重新回顾一下Java8的一些改动。HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。于是通过这篇文章记录我对它的一些理解。</p><p>在进入HashMap之前我们先来了解几个常见的概念。</p><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>哈希表也称为散列表，是根据关键码值而直接访问的数据结构，也就是说可以通过关键码值映射到哈希表中的一个位置进行数据操作，</p><p>这个映射函数称为散列函数，存放记录的数组称为散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719092813.png" srcset="/img/loading.gif" alt=""></p><h2 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h2><p>由于我们的哈希表主体是数组，那么它的数组容量就是确定的固定的，不可避免的会出现，两个元素通过哈希函数求出的实际存储地址值相同的情况。</p><p>也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p><p>所以从这里我们可以知道，我们哈希函数的设计就显得尤为重要了，因此我们要尽可能保证我们的计算简单和散列地址分布均匀。</p><p>解决办法：</p><ul><li>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</li><li>再散列函数法</li><li>链表法</li></ul><h2 id="1-7和1-8中HashMap的变化"><a href="#1-7和1-8中HashMap的变化" class="headerlink" title="1.7和1.8中HashMap的变化"></a>1.7和1.8中HashMap的变化</h2><h3 id="头插法和尾插法以及为什么会导致死环？"><a href="#头插法和尾插法以及为什么会导致死环？" class="headerlink" title="头插法和尾插法以及为什么会导致死环？"></a>头插法和尾插法以及为什么会导致死环？</h3><ul><li>JDK1.7用的是头插法，JDK1.8用的是尾插法，为什么要这样做？<br>头插法就是说新来的值会取代原有的值，原有的值就顺推到链表中去。改为尾插法的目的主要就是为了防止多线程扩容后出现死环的情况。</li></ul><p>我们先来看一下JDK1.7扩容的核心代码：</p><pre><code class="hljs java"><span class="hljs-comment">//将老的表中的数据拷贝到新的结构中  </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;          <span class="hljs-keyword">int</span> newCapacity = newTable.length;<span class="hljs-comment">//容量  </span>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="hljs-comment">//遍历所有桶</span>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123;  <span class="hljs-comment">//遍历桶中所有元素（是一个链表）</span>                Entry&lt;K,V&gt; next = e.next;                  <span class="hljs-keyword">if</span> (rehash) &#123;<span class="hljs-comment">//如果是重新Hash，则需要重新计算hash值  </span>                    e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);                  &#125;                  <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="hljs-comment">//定位Hash桶  </span>                e.next = newTable[i];<span class="hljs-comment">//元素连接到桶中,这里相当于单链表的插入，总是插入在最前面</span>                newTable[i] = e;<span class="hljs-comment">//newTable[i]的值总是最新插入的值</span>                e = next;<span class="hljs-comment">//继续下一个元素  </span>            &#125;          &#125;      &#125;</code></pre><p>HashMap扩容导致死循环的主要原因在于扩容后链表中的节点在新的hash桶使用头插法插入。</p><p>新的hash桶会倒置原hash桶中的单链表，那么在多个线程同时扩容的情况下就可能导致产生一个存在闭环的单链表，从而导致死循环。</p><p>JDK1.8由于使用的是尾插法，不会导致单链表的倒置，所以扩容的时候不会导致死循环。</p><h3 id="为什么扩容后数据存储位置的计算方式不同？"><a href="#为什么扩容后数据存储位置的计算方式不同？" class="headerlink" title="为什么扩容后数据存储位置的计算方式不同？"></a>为什么扩容后数据存储位置的计算方式不同？</h3><p>源码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 分析1：hash(key)</span><span class="hljs-comment">  * 作用：计算传入数据的哈希码（哈希值、Hash值）</span><span class="hljs-comment">  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样  扰动函数  使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span><span class="hljs-comment">  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span><span class="hljs-comment">  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span><span class="hljs-comment">  */</span>    <span class="hljs-comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;     h ^= k.hashCode();      h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);     <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);  &#125;    <span class="hljs-comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span>   <span class="hljs-comment">// 1. 取hashCode值： h = key.hashCode() </span>   <span class="hljs-comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;         <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 计算存储位置的函数分析：indexFor(hash, table.length)</span><span class="hljs-comment">  * 注：该函数仅存在于JDK 1.7</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;         <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);        <span class="hljs-comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span> &#125;</code></pre><p>在JDK1.7的时候是直接用键的hashcode值与新数组的长度进行&amp;运算得到新数组的位置。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200726113745.png" srcset="/img/loading.gif" alt=""></p><p>而在jdk1.8中虽然扩容之后的数组和1.7是一样的，但是在计算元素位置的方式上不太一样，jdk1.7需要与新的数组长度进行重新hash运算，这个方式是相对耗性能的，而在1.8中对这一步进行了优化。</p><p>在1.8中我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><h3 id="为什么HashMap的数组长度一定是2的次幂？"><a href="#为什么HashMap的数组长度一定是2的次幂？" class="headerlink" title="为什么HashMap的数组长度一定是2的次幂？"></a>为什么HashMap的数组长度一定是2的次幂？</h3><pre><code class="hljs java"><span class="hljs-comment">// Java8中计算数组索引下标的位置</span>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]</code></pre><p>因为hashMap 的数组长度都是2的n次幂 ，那么对于这个数再减去1，转换成二进制的话，就肯定是最高位为0，其他位全是1 的数。</p><p>以Java8为例当数组长度不为2的n次幂 的时候，hashCode 值与数组长度减一做与运算的时候，会出现重复的数据，</p><p>因为不为2的n次幂 的话，对应的二进制数肯定有一位为0 , 这样不管你的hashCode 值对应的该位，是0还是1 ,</p><p>最终得到的该位上的数肯定是0，这带来的问题就是HashMap上的数组元素分布不均匀，而数组上的某些位置，永远也用不到。</p><p>这将带来的问题就是你的HashMap 数组的利用率太低，并且链表可能因为上边的(n - 1) &amp; hash 运算结果碰撞率过高，导致链表太深。(当然jdk 1.8已经在链表数据超过8个以后转换成了红黑树的操作，但那样也很容易造成它们之间的转换时机的提前到来)，所以说HashMap的长度一定是2的次幂，否则会出现性能问题。</p><p>总之，当数组长度为2的n次幂是，不同的key通过位运算获取的数组下标冲突的几率会小很多。冲突少了，添加元素的效率自然就会更高，数据在数组上的分布也会更加均匀，相应的链表长度也会更短。</p><p>这样我们在查询的时候，由于数据的分布均匀、链表长度不是很长而且均匀，使我们的查询效率也会变高很多。</p><h3 id="扩容因子为什么是0-75？"><a href="#扩容因子为什么是0-75？" class="headerlink" title="扩容因子为什么是0.75？"></a>扩容因子为什么是0.75？</h3><p>假设hash函数是理想的，数据会通过hash函数均匀的映射到数组上。一个数据映射到每一个桶（bucket）的概率是相等的。那么在任意的数组容量下，put一个数据发生碰撞的概率=数组元素个数/数组容量。</p><p>设置为0.75是做好了时间和空间的权衡的，因为扩容因子越大，碰撞的概率也就越大，发生碰撞后的代价也更大，结果导致效率也大打折扣。所以设置为0.75空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p><h3 id="底层实现原理的区别"><a href="#底层实现原理的区别" class="headerlink" title="底层实现原理的区别"></a>底层实现原理的区别</h3><h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>HashMap map = new HashMap();<br>在实例化以后，底层创建一个长度是16的一维数组Entry[] table。<br>…put很多次后…</p><p>map.put(key1,value1);</p><p>首先，调用key1所在类的hashcode计算key1哈希值，此哈希值经过某种算法后，得到在Entry数组中的存放位置。</p><p>如果该位置上数据为空，此时key和value直接添加成功。<br>如果该位置上数据不为空，说明该位置上存在一个或多个数据(以链表存储)，那么接着就会比较我们的key和已存在的数据的哈希值：</p><pre><code>如果key的哈希值与已存在数据的哈希值不同，添加成功。如果key的哈希值与已存在数据的哈希值相同，继续使用equals方法比较：    如果equals返回false，此时key添加成功。    如果equals返回true，此时value1替换value2。</code></pre><p>扩容的方式是将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><ol><li>new HashMap刚开始时底层没有创建一个长度为16的数组</li><li>底层数组不是Entry[]，变为了Node[]</li><li>首次调用put（）方法时，底层创建长度为16的数组</li><li>jdk7底层结构：数组+链表，jdk8底层结构：数组+链表+红黑树<br>当数组的某一个索引位置上的以链表形式存在的个数&gt;8且当前数组的长度&gt;64，此时此索引位置上的所有数据改为使用红黑树存储。</li></ol><p>参考：<br><a href="https://blog.csdn.net/qq32933432/article/details/86668385" target="_blank" rel="noopener">https://blog.csdn.net/qq32933432/article/details/86668385</a><br><a href="https://blog.csdn.net/liyantianmin/article/details/79401854" target="_blank" rel="noopener">https://blog.csdn.net/liyantianmin/article/details/79401854</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a><br><a href="https://blog.csdn.net/Tane_1018/article/details/103392267" target="_blank" rel="noopener">https://blog.csdn.net/Tane_1018/article/details/103392267</a><br><a href="https://www.jianshu.com/p/ee0de4c99f87" target="_blank" rel="noopener">https://www.jianshu.com/p/ee0de4c99f87</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream知识用法总结</title>
    <link href="/cxlittlecute/8a5cc6c1.html"/>
    <url>/cxlittlecute/8a5cc6c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-8-Stream"><a href="#JAVA-8-Stream" class="headerlink" title="JAVA 8 Stream"></a>JAVA 8 Stream</h1><p>最近写项目经常用到Java8新API stream流，当我们的项目数据量比较大的时候，很少会使用外键约束，因为这样产生的笛卡尔集，数量巨大，会造成我们的系统性能低下。</p><p>我们为了能避免这样的情况发生，一般会去除外键，那么通过一个一个表查询出来的数据，如何才能更好的进行VO或者TO的封装了，使用StreamAPI就是一个不错的处理方式。</p><p>于是，通过本篇文章对此进行一个知识点和用法的总结，帮助你了解和学习它的使用。</p><h2 id="Stream是什么"><a href="#Stream是什么" class="headerlink" title="Stream是什么"></a>Stream是什么</h2><p>数据渠道，用于操作数据源所生产的元素序列。</p><p>集合讲的是数据，流讲的是计算。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它的主要作用就是，使用一种管道流的思想处理我们的集合对象，对集合对象进行如同SQL语句一样的查找、过滤、排序等操作。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>Stream自己不会存储数据。</li><li>Stream不会改变源对象。</li><li>数据源来源：集合、数组、IO channel、生成器函数等.</li><li>借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。</li><li>中间操作返回新流，它们总是惰性的（延时执行），除非流水线触发终止操作，否则中间操作不会执行任何处理。由于是在终止操作时一次性全部处理，也称为惰性求值。</li><li>内部迭代：迭代操作是stream API完成的。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一、创建Stream</p><p>从一个数据源，如集合、数组中获取流。</p><p>二、中间操作</p><p>一个操作的中间链，对数据源的数据进行操作。</p><p>三、终止操作</p><p>一个终止操作，执行中间操作链，并产生结果。</p><h2 id="创建Stream流"><a href="#创建Stream流" class="headerlink" title="创建Stream流"></a>创建Stream流</h2><ul><li><p>stream() − 创建顺序流。</p></li><li><p>parallelStream() − 创建并行流。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 集合流</span><span class="hljs-comment"> *  - Collection.stream() 穿行流</span><span class="hljs-comment"> *  - Collection.parallelStream() 并行流</span><span class="hljs-comment"> */</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream();<span class="hljs-comment">/*</span><span class="hljs-comment">* 数组流</span><span class="hljs-comment">*   Arrays.stream(array)</span><span class="hljs-comment">* */</span>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];Stream&lt;String&gt; stream2 = Arrays.stream(strings);<span class="hljs-comment">/*</span><span class="hljs-comment">* 3.Stream 静态方法</span><span class="hljs-comment">*   Stream.of(...)</span><span class="hljs-comment">* */</span>Stream&lt;Integer&gt; stream3 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">* 4.无限流（一直停不下来）</span><span class="hljs-comment">*  (1)迭代</span><span class="hljs-comment">*  (2)生成</span><span class="hljs-comment">* */</span><span class="hljs-comment">// 迭代</span>Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>);<span class="hljs-comment">// 生成(可无限制造对象)</span>Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());<span class="hljs-comment">/*</span><span class="hljs-comment">* 5.BufferedReader.lines()将每行内容转成流</span><span class="hljs-comment"> * */</span>BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"stream.txt"</span>));Stream&lt;String&gt; lineStream = reader.lines();<span class="hljs-comment">/*</span><span class="hljs-comment">*6.Pattern.splitAsStream() 将字符串分隔成流</span><span class="hljs-comment">* */</span>Pattern pattern = Pattern.compile(<span class="hljs-string">","</span>);Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="hljs-string">"a,b,c,d"</span>);</code></pre><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="筛选-切片"><a href="#筛选-切片" class="headerlink" title="筛选/切片"></a>筛选/切片</h3><ul><li>filter：接收 Lambda ，从流中排除某些元素</li><li>limit：截断流，使其元素不超过给定数量</li><li>skip(n)：跳过元素，返回一个舍弃了前n个元素的流；若流中元素不足n个，则返回一个空流；与 limit(n) 互补</li><li>distinct：筛选，通过流所生成的 hashCode() 与 equals() 取除重复元素</li></ul><pre><code class="hljs java">List&lt;Employee&gt; emps = Arrays.asList(        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">101</span>, <span class="hljs-string">"Z3"</span>, <span class="hljs-number">19</span>, <span class="hljs-number">9999.99</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">102</span>, <span class="hljs-string">"L4"</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7777.77</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">103</span>, <span class="hljs-string">"W5"</span>, <span class="hljs-number">35</span>, <span class="hljs-number">6666.66</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">104</span>, <span class="hljs-string">"Tom"</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1111.11</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">105</span>, <span class="hljs-string">"Jerry"</span>, <span class="hljs-number">60</span>, <span class="hljs-number">4444.44</span>));<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 中间操作：不执行任何操作</span>    <span class="hljs-comment">// 此API属于内部迭代</span>    <span class="hljs-comment">// 外部迭代是我们自己编写的for 和 foreach方法</span>    Stream&lt;Employee&gt; stream = emps.stream()            .filter((x) -&gt; x.getAge() &gt; <span class="hljs-number">35</span>)            .limit(<span class="hljs-number">3</span>) <span class="hljs-comment">// 注意：短路 达到满足不再内部迭代</span>            .distinct() <span class="hljs-comment">// 注意：重写hashcode和equals方法</span>            .skip(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 终止操作：一次性执行全部内容，惰性求值</span>    stream.forEach(System.out::println);&#125;</code></pre><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ul><li>map：接收 Lambda ，将元素转换为其他形式或提取信息；接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li><li>flatMap：接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 大小写转换，该函数会被应用到每个元素上，并将其映射成一个新的元素</span>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);    list.stream()            .map((str) -&gt; str.toUpperCase())            .forEach(System.out::println);    <span class="hljs-comment">// 提取集合对象中信息</span>    emps.stream()            .map(Employee::getAge)            .forEach(System.out::println);&#125;</code></pre><p>在使用flatmap之前我们先看这样一个案例，将集合中字符串中的所有字符提取出来。在我们不使用flatmap之前我们需要进行嵌套的两次foreach，因为我们的filterCharacter方法也是返回的stream流对象：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">filterCharacter</span><span class="hljs-params">(String str)</span> </span>&#123;    List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;        list.add(c);    &#125;    <span class="hljs-keyword">return</span> list.stream();&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"bc"</span>, <span class="hljs-string">"ca"</span>);    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream()            .map(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数上的效果&#123;&#123;a,b,c&#125;,&#123;b,c&#125;,&#123;c,a&#125;&#125;，最终在一个大流中</span>    streamStream.forEach((sm) -&gt; &#123;        sm.forEach(System.out::println);    &#125;);&#125;</code></pre><p>那么我们可以再看看flatMap的作用，接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流。重点：flatMap得到的是一个流！</p><pre><code class="hljs java">Stream&lt;Character&gt; characterStream = list.stream()        .flatMap(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数的效果，去掉大流整合成一个流&#123;a,b,c,b,c,c,a&#125;</span>characterStream.forEach(System.out::println);</code></pre><p>此处总结一下这里，等于说Map是把一个个的流放入一个新的流中，导致流的嵌套；而flatMap是将一个个流中的元素放入新的流中。（这样会好理解一些）</p><p>类比于：集合中的add(Object obj)  addAll(Collection coll)方法。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>sorted()：自然排序(Comparable)</li><li>sorted(Comparator c)：定制排序(Comparator)</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自然排序</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);    list.stream()            .sorted() <span class="hljs-comment">//comparaTo()</span>            .forEach(System.out::println);        <span class="hljs-comment">// 定制排序</span>    emps.stream()            .sorted((e1, e2) -&gt; &#123; <span class="hljs-comment">//compara()</span>                <span class="hljs-keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123;                    <span class="hljs-keyword">return</span> e1.getName().compareTo(e2.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> e1.getAge().compareTo(e2.getAge());                &#125;            &#125;)            .forEach(System.out::println);&#125;</code></pre><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"aa"</span>, <span class="hljs-number">10</span>);    Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"bb"</span>, <span class="hljs-number">20</span>);    List&lt;Student&gt; studentList = Arrays.asList(s1, s2);    studentList.stream()            .peek(o -&gt; o.setAge(<span class="hljs-number">100</span>))            .forEach(System.out::println);    <span class="hljs-comment">//结果：</span>    Student&#123;name=<span class="hljs-string">'aa'</span>, age=<span class="hljs-number">100</span>&#125;    Student&#123;name=<span class="hljs-string">'bb'</span>, age=<span class="hljs-number">100</span>&#125;&#125;</code></pre><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><ul><li>allMatch：检查是否匹配所有元素</li><li>anyMatch：检查是否至少匹配一个元素</li><li>noneMatch：检查是否没有匹配所有元素</li><li>findFirst：返回第一个元素</li><li>findAny：返回当前流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中最大值</li><li>min：返回流中最小值</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    List&lt;Status&gt; list = Arrays.asList(Status.FREE, Status.BUSY, Status.VOCATION);    <span class="hljs-keyword">boolean</span> flag1 = list.stream()            .allMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag1);    <span class="hljs-keyword">boolean</span> flag2 = list.stream()            .anyMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag2);    <span class="hljs-keyword">boolean</span> flag3 = list.stream()            .noneMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag3);    <span class="hljs-comment">// 避免空指针异常</span>    Optional&lt;Status&gt; op1 = list.stream()            .findFirst();    <span class="hljs-comment">// 如果Optional为空 找一个替代的对象</span>    Status s1 = op1.orElse(Status.BUSY);    System.out.println(s1);    Optional&lt;Status&gt; op2 = list.stream()            .findAny();    System.out.println(op2);    <span class="hljs-keyword">long</span> count = list.stream()            .count();    System.out.println(count);    <span class="hljs-comment">// 获取最大工资的员工信息</span>    Optional&lt;Employee&gt; max = emps.stream()            .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));    System.out.println(max.get());    <span class="hljs-comment">// 获取最小工资</span>    Optional&lt;Double&gt; min = emps.stream()            .map(Employee::getSalary)            .min(Double::compare);    System.out.println(min.get());&#125;</code></pre><h2 id="归约-收集"><a href="#归约-收集" class="headerlink" title="归约/收集"></a>归约/收集</h2><ul><li>归约：reduce(T identity, BinaryOperator) / reduce(BinaryOperator) 可以将流中的数据反复结合起来，得到一个值</li><li>收集：collect 将流转换成其他形式；接收一个 Collector 接口的实现，用于给流中元素做汇总的方法</li></ul><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 归约</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);    Integer sum = list.stream()            .reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x + y); <span class="hljs-comment">// identity起始值 binaryOperator二元运算 现将起始值作为x，从流中取出元素作为y</span>    System.out.println(sum);    System.out.println(<span class="hljs-string">"-----------------------------------------"</span>);        <span class="hljs-comment">// 获取当前所有员工工资总和</span>    Optional&lt;Double&gt; reduce = emps.stream()            .map(Employee::getSalary)            .reduce(Double::sum); <span class="hljs-comment">// 为什么这里返回Optional？因为这里没有设置起始值</span>&#125;</code></pre><p>map和reduce的连接通常称为map-reduce模式，现在大数据经常应用这种模式。</p><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><p>collect-将流转换为其他形式。接收一个Collection接口的实现，用于给stream中元素汇总的方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 把公司员工所有名字提取出来，放入集合中</span>        List&lt;String&gt; list = emps.stream()                .map(Employee::getName)                .collect(Collectors.toList());<span class="hljs-comment">// Collectors实现类提供了很多静态方法，创建常见的收集器实例</span>        list.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        Set&lt;String&gt; set = emps.stream()                .map(Employee::getName)                .collect(Collectors.toSet());        set.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        HashSet&lt;String&gt; hs = emps.stream()                .map(Employee::getName)                .collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));        hs.forEach(System.out::println);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 收集总数</span>        Long collect = emps.stream()                .collect(Collectors.counting());        <span class="hljs-comment">// 平均值</span>        Double avg = emps.stream()                .collect(Collectors.averagingDouble(Employee::getSalary)); <span class="hljs-comment">// 指定了map</span>        System.out.println(avg);        <span class="hljs-comment">// 总和</span>        Double collect1 = emps.stream()                .collect(Collectors.summingDouble(Employee::getSalary));        System.out.println(collect1);        <span class="hljs-comment">// 最大值</span>        Optional&lt;Employee&gt; max = emps.stream()                .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));        System.out.println(max.get());        <span class="hljs-comment">// 最小值</span>        Optional&lt;Double&gt; min = emps.stream()                .map(Employee::getSalary)                .collect(Collectors.minBy(Double::compare));        System.out.println(min.get());        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 根据状态分组</span>        Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus));        System.out.println(map);        <span class="hljs-comment">// 多级分组</span>        Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; collect2 = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123;                    <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">35</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"青年"</span>;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">50</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"中年"</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"老年"</span>;                    &#125;                &#125;)));        <span class="hljs-comment">//分区</span>        Map&lt;Boolean, List&lt;Employee&gt;&gt; listMap = emps.stream()                .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; <span class="hljs-number">5000</span>)); <span class="hljs-comment">// 满足条件的一个区，不满足条件的在另一个区</span>        System.out.println(listMap);&#125;</code></pre><p>最后还有收集获取运算结果的其他方式和连接操作：</p><pre><code class="hljs java">DoubleSummaryStatistics dss = emps.stream()       .collect(Collectors.summarizingDouble(Employee::getSalary));   System.out.println(dss.getMax());   System.out.println(dss.getMin());   System.out.println(dss.getSum());   System.out.println(dss.getCount());   System.out.println(dss.getAverage());      <span class="hljs-comment">// 将参数连接起来</span>   String str = emps.stream()       .map(Employee::getName)       .collect(Collectors.joining(<span class="hljs-string">"-"</span>));  <span class="hljs-comment">// 可传入分隔符，首尾需要接着添加两个参数</span>   System.out.println(str);</code></pre><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><ul><li>并行流：就是把一个内容分成几个数据块，并用不同的线程分别处理每个数据块的流。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行操作；Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与串行流之间切换。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//串行流(单线程)：切换为并行流 parallel()</span>    <span class="hljs-comment">//并行流：切换为串行流 sequential()</span>    LongStream.rangeClosed(<span class="hljs-number">0</span>, <span class="hljs-number">100000000L</span>)            .parallel() <span class="hljs-comment">//底层：Fork Join</span>            .reduce(<span class="hljs-number">0</span>, Long::sum);&#125;</code></pre><p>fork join类似于归并排序，比较重要的思想就是工作窃取模式，它会将要执行的新任务，拆分为更小的任务执行，将小任务放入线程队列中，如果自己的线程空闲了，就会去别的线程偷取一个小任务放入自己的线程执行。这种方式减少了线程等待的时间，提高了性能。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075629.png" srcset="/img/loading.gif" alt=""></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>最后根据一个图更好的了解Stream 中间操作和结束操作的分类：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075903.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>无状态：指元素的处理不受之前元素的影响。</p></li><li><p>有状态：指该操作只有拿到所有元素之后才能继续下去。<br>（判断流操作是否有状态的判断标准，就是看是否需要知道先前的数据历史。前后数据是否有依赖关系来判断）</p></li><li><p>非短路操作：指必须处理所有元素才能得到最终结果。</p></li><li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p></li></ul><p>参考：<br><a href="https://blog.csdn.net/y_k_y/article/details/84633001" target="_blank" rel="noopener">https://blog.csdn.net/y_k_y/article/details/84633001</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GateWay网关访问服务出现503的问题解决</title>
    <link href="/cxlittlecute/674d8191.html"/>
    <url>/cxlittlecute/674d8191.html</url>
    
    <content type="html"><![CDATA[<h1 id="GateWay网关访问服务出现503的问题解决"><a href="#GateWay网关访问服务出现503的问题解决" class="headerlink" title="GateWay网关访问服务出现503的问题解决"></a>GateWay网关访问服务出现503的问题解决</h1><p>对于这个问题也是困扰了自己很久，今天下定决定要把它干掉。这个问题很坑，建议使用IDEA的朋友都可以看一看。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在分布式服务中，使用GateWay网关进行服务请求路由的统一管理，它是系统对外的唯一入口。为了让网关能正常发送调用其他服务，我使用到了Nacos服务注册中心。</p><p>正是这样出现了，我通过服务端口，能正常访问接口返回数据，通过网关访问有时可以有时不行的情况（也就是出现503的状态码反馈）。</p><p>HTTP状态码503指的是web服务器不能处理HTTP请求。原因大致如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716131929.png" srcset="/img/loading.gif" alt="avator"></p><p>那么根据上面这四个原因我还是没有分析出为什么会出现这个问题。于是我开始一步步排查问题。</p><ol><li><p>我首先认为是我GateWay网关，拦截配置的问题，可是我的情况是有时出现503，有时又能通过网关正常访问，所以暂时排除了这种情况。</p></li><li><p>是否本身的单体服务有问题，但是通过postman的测试，通过服务的端口访问接口，都能正常返回数据。所以也暂时排除这种情况。</p></li><li><p>Nacos注册中心的问题。</p></li></ol><p>那基本能确定是Nacos注册中心的问题了，但也不完全是Nacos的锅。</p><p>再次分析：</p><p>F12查看Network，请求的发送情况，发现OPTIONS预检请求是正常发送的，但发送真正的请求的时候出现了503的错误。如下图:</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133417.png" srcset="/img/loading.gif" alt="avator"></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133338.png" srcset="/img/loading.gif" alt="avator"></p><p>接着我点开了Preview（预览功能），看到了错误提示：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133611.png" srcset="/img/loading.gif" alt="avator"></p><p>我们可以通过错误提示很清晰的看到message的反馈，就是发现不了我的product服务。</p><p>和我们判断的没错是nacos的问题，于是我进入nacos查看服务是否注册成功。</p><p>这里就发现了一个很奇怪的现象，正常的我们刷新nacos的界面服务是不会掉的，但是我的product商品服务，一会有一会儿又没有，刚开始我发现了这个问题，但没有引起注意，也就导致这个问题之前一直没有得到解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是，我抱着再试一试的心态，将该服务的端口号从10000改为了8100，也就是改为了其他的数（或者修改一下服务名），这个服务就在nacos注册中心稳定了。（前提是确保你的服务Nacos配置没有问题）</p><p>这其实是一个很容易解决的bug，但是之前网上找过都没有得到好的解决。</p><p>让我想到了idea在使用过程中确实存在一些bug，常见的就是</p><ol><li><p>创建继承maven项目数量多了之后，项目结构就会不一样，需要手动修改，或者更换项目名才能解决。</p></li><li><p>使用springboot的过程中有些端口无法使用，这种无法使用是由于idea和系统的问题，你能正常跑通你的项目，但是这个项目你无法通过客户端访问，只要访问就是500服务器错误。</p></li></ol><hr><p>同时这里强调，不是因为什么端口被占用的问题，端口如果被占用，连服务都是无法启动的，所以这就是一些简单又很坑人的地方。</p><p>如果您有幸看到了这篇文章，希望对您有帮助，解决到您的问题。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
      <category>GateWay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>GateWay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</title>
    <link href="/cxlittlecute/4e6c6273.html"/>
    <url>/cxlittlecute/4e6c6273.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题"><a href="#Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题" class="headerlink" title="Springboot出现Possibly consider using a shorter maxLifetime value警告问题"></a>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>这是我经常遇到的一个问题，当我们使用Springboot连接数据库的时候（Springboot默认使用的是HikariCP），如果长时间的静默没有请求连接池，那么就会出现如下warn：</p><pre><code class="hljs routeros">[http-nio-7003-exec-10] WARN  com.zaxxer.hikari.pool.PoolBase - HikariPool-1 - Failed <span class="hljs-keyword">to</span> validate<span class="hljs-built_in"> connection </span>com.mysql.cj.jdbc.ConnectionImpl@3987b59f (<span class="hljs-literal">No</span> operations allowed after<span class="hljs-built_in"> connection </span>closed.). Possibly consider using a shorter maxLifetime value.</code></pre><p>我们可以看到这个warn的最后一句话， Possibly consider using a shorter maxLifetime value（让我们考虑使用一个更小的maxLifetime值）。</p><p>看到这里大家肯定会疑惑maxLifeTime是什么？</p><p>我们先来看看官方文档对参数的说明：<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716085042.png" srcset="/img/loading.gif" alt="avator"></p><p>此属性控制池中连接的最长生存期。一个正在使用的连接永远不会失效，只有当它关闭时，它才会被移除。在逐个连接的基础上，应用较小的负衰减以避免池中的大规模灭绝。我们强烈建议设置此值，并且它应该比任何数据库或基础设施施加的连接时间限制短几秒。值为0表示没有最长生存期（无限生存期），当然取决于idleTimeout设置。默认值：1800000（30分钟）。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>其实这个问题很好解决，就是在配置文件中添加HikariCP的参数设置，也就是将maxLifeTime的值变小。</p><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.hikari</span><span class="hljs-selector-class">.max-lifetime</span> =<span class="hljs-number">120000</span></code></pre><p>同时这里需要注意的是，如果这样设置后出现另外的报错：</p><pre><code class="hljs applescript">idleTimeout <span class="hljs-keyword">is</span> close <span class="hljs-keyword">to</span> <span class="hljs-keyword">or</span> more than maxLifetime, disabling <span class="hljs-keyword">it</span>.</code></pre><p>说明你设置的maxLifeTime的值低于了idleTimeout。</p><p>ideaTimeOut是连接允许在池中闲置的最长时间，它有个规则：如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒。</p><p>所以最好是将maxLifeTime和idleTimeOut的值一起按照要求修改。</p><p>文档里面的参数都可以在配置文件中修改默认值，可以根据自己的需要来。</p><p>当然说到这里其实自己也是有疑问的，为什么降低了maxLifeTime就可以避免发生这个问题？现在只是找到方法解决掉了这个问题，但是原理不是很明白，查阅到了相关资料我会进行补充。有想法的朋友可以评论或私信我，互相交流。</p><hr><p>以上的理解如果有偏差，可以通过关于页的联系方式第一时间联系我，我将做好修改更正工作。期待您的回复和反馈。</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>HikariCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>HikariCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云oss上传报错Invalid according to Policy Policy expired</title>
    <link href="/cxlittlecute/1d5383b1.html"/>
    <url>/cxlittlecute/1d5383b1.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"><a href="#阿里云oss上传报错Invalid-according-to-Policy-Policy-expired" class="headerlink" title="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"></a>阿里云oss上传报错Invalid-according-to-Policy-Policy-expired</h1><p>阿里云oss上传使用的是服务端签名后直传；通过服务端生成上传签名，前端使用服务端生成的签名上传文件。</p><p>同时，在这里先说一下为什么要使用服务端签名后直传。</p><p>之前使用OSS时，是让文件过自己的服务器，然后通过自己的服务器传到OSS的服务器，也就是这样：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175217.png" srcset="/img/loading.gif" alt="avator"></p><p>通过上面的这种直传的方式，导致我们的服务端压力很大。虽然我们可以使用JS直接前端传递，但是这样会暴露我们的AccessKeyID和AcessKeySecret，会有安全隐患。</p><p>所以选择了，接下来的这种服务端签名的方式上传：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175427.png" srcset="/img/loading.gif" alt="avator"></p><p>正是使用了这种方式出现了以下这个问题：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174130.png" srcset="/img/loading.gif" alt="avator"></p><p>查询阿里云文档可知错误原因：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174653.png" srcset="/img/loading.gif" alt="avator"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p> 生成签名时，官方代码中的参数expireTime默认是30秒，改为更大的时间。</p><h3 id="代码演示-解决办法"><a href="#代码演示-解决办法" class="headerlink" title="代码演示 解决办法"></a>代码演示 解决办法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Osscontroller</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.endpoint&#125;"</span>)    <span class="hljs-keyword">private</span> String endpoint;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.bucket&#125;"</span>)    <span class="hljs-keyword">private</span> String bucket;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.access-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessId;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.secret-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessKey;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/oss/policy"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">policy</span><span class="hljs-params">()</span> </span>&#123;        String host = <span class="hljs-string">"https://"</span> + bucket + <span class="hljs-string">"."</span> + endpoint; <span class="hljs-comment">// host的格式为 bucketname.endpoint</span>        <span class="hljs-comment">// callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。</span>        <span class="hljs-comment">//String callbackUrl = "http://88.88.88.88:8888";</span>        String format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(<span class="hljs-keyword">new</span> Date());        String dir = format+<span class="hljs-string">"/"</span>; <span class="hljs-comment">// 用户上传文件时指定的前缀。</span>        <span class="hljs-comment">// 创建OSSClient实例。</span>        OSS ossClient = <span class="hljs-keyword">new</span> OSSClientBuilder().build(endpoint, accessId, accessKey);        Map&lt;String, String&gt; respMap = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">long</span> expireTime = <span class="hljs-number">60</span>; <span class="hljs-comment">//增大这里的时间</span>            <span class="hljs-keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="hljs-number">1000</span>;            Date expiration = <span class="hljs-keyword">new</span> Date(expireEndTime);            <span class="hljs-comment">// PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span>            PolicyConditions policyConds = <span class="hljs-keyword">new</span> PolicyConditions();            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="hljs-number">0</span>, <span class="hljs-number">1048576000</span>);            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);            <span class="hljs-keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="hljs-string">"utf-8"</span>);            String encodedPolicy = BinaryUtil.toBase64String(binaryData);            String postSignature = ossClient.calculatePostSignature(postPolicy);            respMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();            respMap.put(<span class="hljs-string">"accessid"</span>, accessId);            respMap.put(<span class="hljs-string">"policy"</span>, encodedPolicy);            respMap.put(<span class="hljs-string">"signature"</span>, postSignature);            respMap.put(<span class="hljs-string">"dir"</span>, dir);            respMap.put(<span class="hljs-string">"host"</span>, host);            respMap.put(<span class="hljs-string">"expire"</span>, String.valueOf(expireEndTime / <span class="hljs-number">1000</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// Assert.fail(e.getMessage());</span>            System.out.println(e.getMessage());        &#125; <span class="hljs-keyword">finally</span> &#123;            ossClient.shutdown();        &#125;        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"data"</span>,respMap);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo消除中文路径</title>
    <link href="/cxlittlecute/8ce042f1.html"/>
    <url>/cxlittlecute/8ce042f1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo消除中文路径"><a href="#Hexo消除中文路径" class="headerlink" title="Hexo消除中文路径"></a>Hexo消除中文路径</h1><p>我们博客中的文章标题，一般都会有中文出现，同时Hexo默认也是会把你的title放在路径访问的最后，也就是xxx.html。</p><p>由于路径中有中文的存在，如果你想根据URL进行操作的时候就会被浏览器编码，也就是URL code字符编码。</p><pre><code class="hljs llvm">https://ccctop.cn/<span class="hljs-number">2020</span>/<span class="hljs-number">07</span>/<span class="hljs-number">13</span>/Jenkins<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%89</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A1</span><span class="hljs-symbol">%8</span>Cshell<span class="hljs-symbol">%E5</span><span class="hljs-symbol">%91</span><span class="hljs-symbol">%BD</span><span class="hljs-symbol">%E4</span><span class="hljs-symbol">%BB</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%EF</span><span class="hljs-symbol">%BC</span><span class="hljs-symbol">%8</span>C<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%8</span>F<span class="hljs-symbol">%90</span><span class="hljs-symbol">%E7</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%BAcommand-not-found</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%A3</span><span class="hljs-symbol">%E5</span><span class="hljs-symbol">%86</span><span class="hljs-symbol">%B3</span>/</code></pre><h2 id="这种中文URL的不缺点："><a href="#这种中文URL的不缺点：" class="headerlink" title="这种中文URL的不缺点："></a>这种中文URL的不缺点：</h2><ol><li><p>关键词被编译后，URL会变得很长，这是搜索引擎不建议的，但并非不能使用;也就是不利于SEO。</p></li><li><p>使用被引用，中文URL在转码后会变成形如：%E5%A9%9A%E7%BA%B1 的结构，一些编辑器支持的问题会造成错误链接地址或错误的URL识别、分割 ，甚至有些网站会产生状态为404的引用指向。</p></li></ol><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>一种是把中文路径变为拼音，另一种就是进行转换编码。在 Hexo 根目录下的 _config.yml 文件中，修改或新增配置项：</p><p>拼音：</p><pre><code class="hljs ada">npm i hexo-permalink-pinyin <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-symbol">permalink_pinyin:</span><span class="hljs-symbol">  enable:</span> true<span class="hljs-symbol">  separator:</span> <span class="hljs-string">'-'</span> <span class="hljs-meta"># default: <span class="hljs-string">'-'</span></span></code></pre><p>编码：</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-meta"># permalink: :title/</span><span class="hljs-symbol">permalink:</span> archives/:abbrlink.html<span class="hljs-symbol">abbrlink:</span><span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta"># 算法：crc16(default) and crc32</span><span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta"># 进制：dec(default) and hex</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins执行shell命令，提示command not found解决</title>
    <link href="/cxlittlecute/61702.html"/>
    <url>/cxlittlecute/61702.html</url>
    
    <content type="html"><![CDATA[<h1 id="Command-not-found"><a href="#Command-not-found" class="headerlink" title="Command not found"></a>Command not found</h1><p>jenkins执行shell命令，有时会提示“Command not found”—-处理方案。</p><p>1.首先，分析是linux环境的问题还是Jenkins的问题。</p><p>如果登录linux，shell命令不可以执行，同样提示“Command not found”，则是环境变量设置失败，需要配置环境变量、/etc/profile。</p><p>如果登录linux，shell命令可以执行，则是jenkins没有加载/etc/profile导致。</p><p>我就是第二种情况。那就是得让jenkins执行我们实际的shell命令之前，执行识别环境变量的shell命令。让Jenkins先读取/etc/profile等的内容。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">source</span> ~/.bash_profile<span class="hljs-built_in">source</span> /etc/profile<span class="hljs-built_in">cd</span>..等其他shell命令</code></pre>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云全站加速HTTPS证书无法开启问题解决</title>
    <link href="/cxlittlecute/10754.html"/>
    <url>/cxlittlecute/10754.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云全站加速HTTPS证书无法开启问题解决"><a href="#阿里云全站加速HTTPS证书无法开启问题解决" class="headerlink" title="阿里云全站加速HTTPS证书无法开启问题解决"></a>阿里云全站加速HTTPS证书无法开启问题解决</h1><p>全站加速（Dynamic Route for Content Delivery Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p><p>1.选择添加域名</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160216.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.添加域名 类型IP（IP就是你服务器IP）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160556.png" srcset="/img/loading.gif" alt="avatar"></p><p>3.HTTPS设置</p><p>我就是在这个地方出现问题的。</p><p>之前没有领取HTTPS证书，所以在这里想一起申请了，也就是选择</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162446.png" srcset="/img/loading.gif" alt="avatar"></p><p>免费证书，点击确定后，弹窗显示了设置成功，但是HTTPS的设置一直都是未开启的状态。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162917.png" srcset="/img/loading.gif" alt="avatar"></p><p>由于不知道问题出现在什么地方，所以找了一下客服。客服的回复如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162759.png" srcset="/img/loading.gif" alt="avatar"></p><p>之后发现出现这个问题的原因是，我自己添加的域名为泛域名，也就是域名前我带了*，这样可能会导致无法颁发证书。</p><p>随后我将*去掉，配置为www或者直接解析域名@,再次去申请证书就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云域名配置</title>
    <link href="/cxlittlecute/202.html"/>
    <url>/cxlittlecute/202.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云域名配置"><a href="#阿里云域名配置" class="headerlink" title="阿里云域名配置"></a>阿里云域名配置</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>登录阿里云，选择域名服务，选择你要购买的域名类型进行购买。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152655.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p><a href="https://beian.aliyun.com/" target="_blank" rel="noopener">https://beian.aliyun.com/</a></p><p>必要进行域名备案才能真正使用上你的域名，备案需要填写你购买域名的用途和你个人信息等，然后进行申请，审批时长大概二十天左右。</p><p>期间保持电话畅通，因为阿里云的客服小姐姐小哥哥可能会给你打电话，如果你有什么信息需要修改的可以第一时间得到反馈。然后就是耐心的等待。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152836.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>当你把以上的步骤完成后，就可以进入域名的管理控制台。<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153119.png" srcset="/img/loading.gif" alt="avatar"></p><p>点击解析 配置你的解析设置：<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153540.png" srcset="/img/loading.gif" alt="avatar"></p><p>这样只需要对应你的IP进行配置就可以实现使用你自己的域名解析到IP上了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建与部署</title>
    <link href="/cxlittlecute/19858.html"/>
    <url>/cxlittlecute/19858.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客搭建与部署"><a href="#Hexo博客搭建与部署" class="headerlink" title="Hexo博客搭建与部署"></a>Hexo博客搭建与部署</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。</p><p>文档地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="如何搭建（参照Hexo文档）"><a href="#如何搭建（参照Hexo文档）" class="headerlink" title="如何搭建（参照Hexo文档）"></a>如何搭建（参照Hexo文档）</h2><p>安装前提：node.js和Git</p><p>node: <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>Git: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre><pre><code class="hljs cmd">$ hexo init &lt;folder&gt;$ <span class="hljs-built_in">cd</span> &lt;folder&gt;$ npm install</code></pre><p>Hexo的安装过程比较简单，主要参照文档就行了。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>hexo项目结构安装好后，就可以选择一个合适的主题，官网有主题的选项，同时也可以去百度上看一下别人选择的主题做出来的效果，有看到喜欢的就用相同的主题。</p><p>我用的主题为：Fluid&emsp;&emsp;  <a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">https://hexo.fluid-dev.com/docs/</a></p><p>这个主题支持的插件基本还可以，界面还是简介大方。</p><p>那么我们只需要下载好相应的主题，按照Hexo官方文档（注意不是主题文档）修改_config.yml这个文件中的内容就可以了。</p><p>很多细小的配置在Fluid主题文档中都有，基本可以把文档看一遍，修改好你想要的设置。</p><h2 id="主题设置细节说明"><a href="#主题设置细节说明" class="headerlink" title="主题设置细节说明"></a>主题设置细节说明</h2><p>我的博客中使用了评论和统计插件。</p><p>评论-Valine <a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></p><p>统计-leancloud <a href="https://www.leancloud.cn/" target="_blank" rel="noopener">https://www.leancloud.cn/</a></p><p>评论和计数的后台都可以通过lencloud的后台系统管理，而且比较稳定。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>重点说一下部署，因为Hexo部署上去的其实就是Public下面的html静态文件，所以可以把public下的文件放置在任何地方。</p><p>文档推荐的是放github下，但是你会发现如果你不翻墙的话，图片很难加载出来，gitee也可以，但是如果你想配置自定义域名的话，就必须要购买gitee自定义域名的产品。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>我使用的是PicGo+Gitee(码云)搭建自己的图床。</p><p>1.将PicGO下载下来，然后安装插件</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713133658.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.配置Gitee<br>点击自己gitee头像-&gt;设置，左边有一个私人令牌，点击右上角生成新令牌，只选择projects,如下图：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150257.png" srcset="/img/loading.gif" alt="avatar"></p><p>注意：私人令牌token只会显示一次，如果没有复制成功只能删除后重新获取。</p><p>3.设置插件githubPlus</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150827.png" srcset="/img/loading.gif" alt="avatar"></p><p>测试：记得修改PicGO中上传区中的图片上传改为:图片上床-githubLPlus这样就可以根据路径来访问你的图片了。</p><pre><code class="hljs stata">最后，感谢Yazzz带我入坑，友链里有<span class="hljs-keyword">ta</span>哦~</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
