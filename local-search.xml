<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/cxlittlecute/ca4438af.html"/>
    <url>/cxlittlecute/ca4438af.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><p>之前自己有一篇<a href="http://ccctop.cn/cxlittlecute/56a14e38.html" target="_blank" rel="noopener">HashMap理解总结</a>的博文，里面主要是通过一些问题的提出，来分析1.8之前之后HashMap的一些区别，那么这次我们继续来看一看HashMap的部分源码细则。</p><h2 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h2><p>首先我们都知道在JDK1.8之前是采取的数组+链表的结构，而在JDK1.8之后采取的是数组+链表+红黑树的结构（也叫做哈系桶）。</p><p>这样转换的原因是，链表结点过多链表过长后，查询效率就会变低，而转换为红黑树的结构可以大大提升效率。</p><h3 id="1、类继承实现关系"><a href="#1、类继承实现关系" class="headerlink" title="1、类继承实现关系"></a>1、类继承实现关系</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;&#125;</code></pre><hr><h3 id="2、类成员变量"><a href="#2、类成员变量" class="headerlink" title="2、类成员变量"></a>2、类成员变量</h3><p>当我们第一次看HashMap的源码的时候肯定被它的类成员变量给吓到了，因为有很多参数信息。</p><pre><code class="hljs java"><span class="hljs-comment">// 序列化号</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">362498820763181265L</span>;<span class="hljs-comment">// 默认的初始容量是16，必须是2的幂。（上面的那篇博客有提到为什么）</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;<span class="hljs-comment">// 最大容量</span><span class="hljs-comment">// 有些版本的源码可能是 1 &lt;&lt; 30 表示必须是2的幂且小于2的30次方，传入容量过大将被这个值替换</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1073741824</span>;<span class="hljs-comment">// 加载因子，用于扩容使用</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> <span class="hljs-number">0.75F</span> = <span class="hljs-number">0.75F</span>;<span class="hljs-comment">// 当某个桶节点数量大于8时，会转换为红黑树。(链表转化为树的阈值)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<span class="hljs-comment">// 当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构(树转化为链表的阈值)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<span class="hljs-comment">// 当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span><span class="hljs-comment">// (桶中的数据要采用红黑树结构进行存储时，整个Table的最小容量)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<span class="hljs-comment">// 存储元素的数组(哈希表)，transient关键字表示该属性不能被序列化</span><span class="hljs-keyword">transient</span> HashMap.Node&lt;K, V&gt;[] table;<span class="hljs-comment">// 将Map数据转换成set的存储形式，这个变量主要用于迭代功能。</span><span class="hljs-keyword">transient</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet;<span class="hljs-comment">// 元素数量</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">// 统计该map修改的次数</span><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<span class="hljs-comment">// 临界值，也就是元素数量达到临界值时，会进行扩容。</span><span class="hljs-keyword">int</span> threshold;<span class="hljs-comment">// 也是加载因子，只不过这个是变量。</span><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;</code></pre><hr><h3 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h3><pre><code class="hljs java"><span class="hljs-comment">// 方法一</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 默认数组初始容量为16，负载因子为0.75f（这里还没有进行数组的初始化）</span>    <span class="hljs-keyword">this</span>.loadFactor = <span class="hljs-number">0.75F</span>;&#125;<span class="hljs-comment">// 方法二</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0.75F</span>);&#125;<span class="hljs-comment">// 方法三 设置初始化容量和负载因子</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    <span class="hljs-comment">// 判断初始容量是否小于0，如果小于0，会抛出异常</span>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> + initialCapacity);    <span class="hljs-comment">// 判断初始容量是否大于最大的容量(即2^31)，如果大于，将初始容量设置为最大初始容量。</span>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    <span class="hljs-comment">// 判断加载因子：如果小于等于0，或者不是一个数字，都会抛出异常。</span>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> + loadFactor);    <span class="hljs-comment">// 设置HashMap的加载因子和扩容的阈值</span>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);&#125;<span class="hljs-comment">// 方法四</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;    <span class="hljs-keyword">this</span>.loadFactor = <span class="hljs-number">0.75F</span>;    putMapEntries(m, <span class="hljs-keyword">false</span>);&#125;</code></pre><hr><h3 id="4、tableSizeFor（）"><a href="#4、tableSizeFor（）" class="headerlink" title="4、tableSizeFor（）"></a>4、tableSizeFor（）</h3><p>在构造方法三中我们看到了tableSizeFor（）这个方法，那么这个方法就是我们设置初始化容量的关键方法，因为它可以通过计算获得比cap大的最小的2的幂次方。（比如如果传10，返回大小为16）</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 按位或  无符号右移赋值</span>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre><hr><h3 id="5、put"><a href="#5、put" class="headerlink" title="5、put()"></a>5、put()</h3><p>上面的初始化方法看完了，接下来我们就看看大家最疑惑的Put方法，Put方法是我们经常使用的方法，我们可以通过它的底层逻辑来了解它是如何做到遇到相同的key就会替换掉的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;</code></pre><p><strong>在put方法中有两个方法很重要一个是hash另一个是putVal</strong>.下面我们就先展开来分析这两个方法。</p><hr><h3 id="6、hash（key"><a href="#6、hash（key" class="headerlink" title="6、hash（key)"></a>6、hash（key)</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-keyword">int</span> h;    <span class="hljs-comment">// 1. 允许key为null，hash = 0</span>    <span class="hljs-comment">// 2. h = key.hashCode()) ^ (h &gt;&gt;&gt; 16为了让高位数据与低位数据进行异或，增加hash随机性</span>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;</code></pre><ul><li><p>在这里我开门可以看到，当key=null时，也是有hash值的，是0，所以，HashMap的key是可以为null的！</p></li><li><p>接着我们还能发现，当key != null时，进行的是hash值的计算，首先计算出key的hashCode()为h，然后这个h与h无条件右移16位后的二进制进行按位异或(^)得到最终的hash值。</p><pre><code>备注：异或的操作如下：0 ^ 0=0，1 ^ 1 =0，0 ^ 1=1，1 ^ 0=1，也就是相同时返回0，不同时返回1。</code></pre></li></ul><p>在这里肯定有朋友要问了为什么要这样设计Hash函数，与直接使用key的hashcode算法有什么区别叻？<br>这里就是所谓的扰动函数，这么设计的原因：<br>1.可以做到尽可能的减少降低Hash碰撞，使元素分布的更加分散<br>2.因为这里是高频的操作，所以使用位运算来提高效率。</p><hr><h3 id="7、putVal"><a href="#7、putVal" class="headerlink" title="7、putVal()"></a>7、putVal()</h3><p>参考：<a href="https://blog.csdn.net/zhengwangzw/article/details/104889549" target="_blank" rel="noopener">一个HashMap跟面试官扯了半个小时</a></p><p>我们的put方法底层调用的方法其实是putval，我们下面就来揭开它神秘的面纱。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    <span class="hljs-comment">// tab：内部数组</span>    <span class="hljs-comment">// p：hash对应的索引位中的首节点</span>    <span class="hljs-comment">// n：内部数组的长度</span>    <span class="hljs-comment">// i：hash对应的索引位</span>    Node&lt;K,V&gt;[] tab;     Node&lt;K,V&gt; p;     <span class="hljs-keyword">int</span> n, i;    <span class="hljs-comment">// 初始化时，map中还没有key-value，内部数组为空，扩充数组</span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        <span class="hljs-comment">// 利用resize生成对应的tab[]数组（下面我们再来看看resize（））</span>        n = (tab = resize()).length;    <span class="hljs-comment">// 计算数组索引，获取该索引位置的首节点，如果为null，则新的节点放在这个位置</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 这里也是为什么HashMap的数组长度是2的N次幂(n-1除最高为0其余都是1)</span>    <span class="hljs-comment">// 不同key通过位运算获取的数组下标冲突的几率会比较小</span>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 以下的else中的逻辑表示确定的该位置不是空</span>    <span class="hljs-keyword">else</span> &#123;        Node&lt;K,V&gt; e; K k;        <span class="hljs-comment">// 计算表中的hash和要插入的key.hash比较，如果与数组中的节点的hash值相等，则直接取代</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            e = p;        <span class="hljs-comment">// 如果是红黑树，直接向红黑树新增一个数据</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);        <span class="hljs-comment">// 此时首节点为链表，如果链表中存在该键值对，直接覆盖value。</span>        <span class="hljs-comment">// 如果不存在，则在末端插入键值对。然后判断链表是否大于等于7，尝试转换成红黑树。</span>        <span class="hljs-comment">// 注意此处使用“尝试”，因为在treeifyBin方法中还会判断当前数组容量是否到达64，</span>        <span class="hljs-comment">// 否则会放弃次此转换，优先扩充数组容量。</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 走到这里，hash碰撞了。检查链表中是否包含key，或将键值对添加到链表末尾</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-comment">// p.next == null，到达链表末尾，添加新节点，如果长度足够，转换成树结构。</span>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                    <span class="hljs-comment">// 节点到达阈值，尝试转为红黑树</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)                         <span class="hljs-comment">// 这里是尝试进行方法的再次判断</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">// 如果待插入的key在链表中找到了，则退出循环</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// 更新p指向下一结点</span>                p = e;            &#125;        &#125;        <span class="hljs-comment">// 覆盖value的方法,map中含有旧值，返回旧值</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            V oldValue = e.value;            <span class="hljs-comment">// onlyIfAbsent是方法的调用参数，表示是否替换已存在的值，</span>            <span class="hljs-comment">// 在默认的put方法中这个值是false，所以这里会用新值替换旧值</span>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            <span class="hljs-comment">// 在节点被访问后做点什么事，在LinkedHashMap中用到</span>            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    ++modCount;    <span class="hljs-comment">// 判断当前的键值对数量是否即将超过阈值，如果即将超过，需要进行resize()扩充数组操作。</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)        resize();<span class="hljs-comment">// 多个线程走到这，可能重复resize()</span>    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>到这里我们先简短的总结一下上面的步骤：</p><ul><li>当table数组为空时，通过扩容的方式初始化table</li><li>计算key的hash值，通过(n - 1) &amp; hash计算应当存放在数组中的下标后，获取该索引位的首节点，查看 table[index] 是否存在数据。</li><li>如果首节点为null，直接添加节点到该索引位。</li><li>如果首节点不为null（发生hash冲突），那么有3种情况<br>  ① key和首节点的key相同，覆盖value；否则执行②或③<br>  ② 如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树。<br>  ③ 如果首节点是链表，将键值对添加到链表。添加之后会判断链表长度是否到达TREEIFY_THRESHOLD - 1这个阈值，“尝试”将链表转换成红黑树。</li><li>最后判断当前元素个数是否大于threshold，扩充数组。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200826103703.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="8、resize"><a href="#8、resize" class="headerlink" title="8、resize()"></a>8、resize()</h3><p>接着我们再深入进去看resize方法是如何初始化和扩充数组的。这里也是HashMap的一个重点环节。</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;    <span class="hljs-comment">// 保存当前old table</span>    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-comment">// 保存old table大小</span>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;    <span class="hljs-comment">// 保存当前阈值</span>    <span class="hljs-keyword">int</span> oldThr = threshold;    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 如果老的数组容量大于0，首先判断是否大于等于HashMap的最大容量，</span>    <span class="hljs-comment">// 如果true，将阈值设置为Integer的最大值，同时数组容量不变</span>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 之前table大于最大容量</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            <span class="hljs-comment">// 阈值为最大整形</span>            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">// 如果扩容后的数组容量小于我们规定的最大数组容量，而且老的数组容量大于等于16，</span>        <span class="hljs-comment">// 对数组进行扩容，扩容后的数组容量为原来的两倍；同时阈值也扩容为原来的两倍</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;            oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            <span class="hljs-comment">// 容量翻倍，使用左移，效率更高，扩容成原来的两倍</span>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">// 这种情况是带参构造创建的对象</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)        <span class="hljs-comment">/**</span><span class="hljs-comment">        * 在HashMap构造器Hash(int initialCapacity, float loadFactor)中有一句代码，</span><span class="hljs-comment">        * this.threshold = tableSizeFor(initialCapacity)， 表示在调用构造器时，默认是将初始容量暂时赋值给了</span><span class="hljs-comment">        * threshold临界值，因此此处相当于将上一次的初始容量赋值给了新的容量。</span><span class="hljs-comment">        * 什么情况下会执行到这句？当调用了HashMap(int initialCapacity)构造器，还没有添加元素时</span><span class="hljs-comment">        */</span>    <span class="hljs-comment">// 也就是老的数组容量为0，而且老的阈值大于0，则新的容量=老的阈值</span>        newCap = oldThr;    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果old table &lt;= 0 并且 存储的阀值 &lt;= 0</span>        <span class="hljs-comment">// 在默认无参数初始化会有这种情况  </span>        <span class="hljs-comment">// 容量和阈值都初始化为默认值，即16和12  扩容阀值为 初始容量*负载因子</span>        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    <span class="hljs-comment">//对临界值做判断，确保其不为0（这里会导致位溢出）</span>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr; <span class="hljs-comment">// 将临界值设置为新临界值</span>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)    <span class="hljs-comment">// 构造新表，初始化表中数据</span>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];    table = newTab;    <span class="hljs-comment">// 如果第一次进行table初始化不会走下面的这段代码</span>    <span class="hljs-comment">// 扩容后需要把结点重新放在新扩容的数组中</span>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 遍历将原来table中的数据放到扩容后的新表中来</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;                oldTab[j] = <span class="hljs-keyword">null</span>;                <span class="hljs-comment">// 没有链表Node节点，直接放到新的table中下标为【e.hash &amp; (newCap - 1)】位置即可</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;                <span class="hljs-comment">// 如果是treeNode节点，则需要将树上的节点重新进行拆分放到newTab中</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果e后面还有链表节点，则遍历e所在的链表，</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-comment">// 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash</span>                    <span class="hljs-comment">// 遍历链表，并将链表结点进行分组</span>                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);                    <span class="hljs-comment">// 将拆分完的链表放进桶里的操作</span>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;                        loTail.next = <span class="hljs-keyword">null</span>;                        <span class="hljs-comment">/**</span><span class="hljs-comment">                         * 若(e.hash &amp; oldCap) == 0，下标不变，将原表某个下标的元素放到扩容表同样</span><span class="hljs-comment">                         * 下标的位置上</span><span class="hljs-comment">                        */</span>                        newTab[j] = loHead;                    &#125;                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;                        hiTail.next = <span class="hljs-keyword">null</span>;                         <span class="hljs-comment">/**</span><span class="hljs-comment">                         * 若(e.hash &amp; oldCap) != 0，将原表某个下标的元素放到扩容表中</span><span class="hljs-comment">                         * [下标+增加的扩容量]的位置上</span><span class="hljs-comment">                         */</span>                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newTab;&#125;</code></pre><p>总的来说resize的步骤如下：<br>1.首先会判断table数组长度，如果大于0说明已经被初始化过了，<strong>那么按照当前table数组长度的2倍进行扩容，同时阀值也变为原来的2倍</strong>。<br>2.若table数组未被初始化过，且threshold（阀值）大于0，<strong>说明调用了HashMap(initialCapacity,loadFactor)构造方法</strong>，那么就把数组大小设置为threshold。<br>3.若table数组未被初始化，且threshold为0说明<strong>调用HashMap（）构造方法</strong>，那么就把数组的大小设置为<strong>16</strong>,threshold设为<strong>16*0.75</strong>。<br>4.接着判断的是如果不是第一次进行初始化，那么扩容之后，需要重新计算键值对的位置，并把它们移动到合适的位置上去，如果结点是红黑树类型需要进行<strong>红黑树的拆分</strong>。</p><hr><h3 id="9、链表拆分"><a href="#9、链表拆分" class="headerlink" title="9、链表拆分"></a>9、链表拆分</h3><p>这里再补充一下链表的拆分：转载  <a href="https://blog.csdn.net/weixin_41565013/article/details/93190786" target="_blank" rel="noopener">深入理解HashMap</a><br>我们可以看到链表的拆分定义了4个变量：loHead, loTail ,hiHead , hiTail，这四个变量从字面意思可以看出应该是两个头节点，两个尾节点。</p><p>那么为什么需要两个链表的头尾节点呢？因为这两个链表的作用就是保存原链表拆分成的两个链表。看原博主画的这个图就明白了。（你出现的位置只可能是当前位置或者当前位置+oldCap）</p><p> if ((e.hash &amp; oldCap) == 0)</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200826161522.png" srcset="/img/loading.gif" alt=""></p><hr><h3 id="10、get"><a href="#10、get" class="headerlink" title="10、get()"></a>10、get()</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object var1)</span> </span>&#123;    HashMap.Node var2;    <span class="hljs-keyword">return</span> (var2 = <span class="hljs-keyword">this</span>.getNode(hash(var1), var1)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : var2.value;&#125;<span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;    Node&lt;K,V&gt;[] tab; <span class="hljs-comment">// 指向hash数组</span>    Node&lt;K,V&gt; first, e; <span class="hljs-comment">// first指向hash数组连接的第一个节点，e指向下一个节点</span>    <span class="hljs-keyword">int</span> n;  <span class="hljs-comment">// hash数组的长度</span>    K k;    <span class="hljs-comment">// 当table不为空，并且桶中不为空，根据hash值计算出在数组中索引index</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp; (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 先检查桶中的头节点是否为我们需要get的节点</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp;                 <span class="hljs-comment">// 满足key的地址相同或equals，返回头节点</span>                ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-keyword">return</span> first;        <span class="hljs-comment">// 桶中不止一个节点</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">//桶中为树，调用红黑树查找方法</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)            <span class="hljs-comment">//在树中查找，这里有机会再讲吧</span>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<span class="hljs-comment">//这里的do-while循环目的是遍历当前桶中的链表</span>            <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// 两个key的hash值相同，并且有相同地址或者equals的key，返回目标节点</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p>查找的步骤为：<br>1.通过hash()方法计算出key对应的hash值，然后tab[(n - 1) &amp; hash]计算出数组中的位置<br>2.判断这个位置上是否有节点，若没有则返回null，表示没有该元素<br>3.若有判断该结点是不是要查找的元素，若是就直接返回该结点<br>4.若不是而且桶中不止一个节点，那么就判断该结点的类型。</p><ul><li>若是红黑树的话，就调用红黑树的方法去查找元素。</li><li>如果是链表类型的话，则遍历链表调用equals方法去查找元素。</li></ul>]]></content>
    
    
    <categories>
      
      <category>集合源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TreeSet源码分析</title>
    <link href="/cxlittlecute/34c19c23.html"/>
    <url>/cxlittlecute/34c19c23.html</url>
    
    <content type="html"><![CDATA[<h1 id="TreeSet源码分析"><a href="#TreeSet源码分析" class="headerlink" title="TreeSet源码分析"></a>TreeSet源码分析</h1><p>本篇我们对TreeSet进行一下分析，将前面遗漏的类之间的关系，在本篇中进行讲解分析。</p><h2 id="TreeSet分析"><a href="#TreeSet分析" class="headerlink" title="TreeSet分析"></a>TreeSet分析</h2><p>1、类继承分析：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt; </span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">NavigableSet</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;</code></pre><ul><li>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet<E>, Cloneable, java.io.Serializable接口。</li><li>TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。</li><li>TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。</li><li>TreeSet 实现了Cloneable接口，意味着它能被克隆。</li><li>TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。</li><li>TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。</li></ul><p>2、成员变量</p><pre><code class="hljs java"><span class="hljs-comment">// TreeSet底层是以TreeMap来储存数据的，key为add()中的元素，value为PRESENT值</span><span class="hljs-comment">// NavigableMap接口的实现类是TreeMap</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<span class="hljs-comment">// 空的Object对象，作为TreeMap中的value值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();</code></pre><p>3、构造方法</p><pre><code class="hljs java"><span class="hljs-comment">// 实际内部调用的方法，外部无法调用</span>TreeSet(NavigableMap&lt;E, Object&gt; var1) &#123;    <span class="hljs-keyword">this</span>.m = var1;&#125;<span class="hljs-comment">// 无参构造函数，申请一个TreeMap作为参数，由此可见TreeSet依赖于TreeMap进行实现</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>((NavigableMap)(<span class="hljs-keyword">new</span> TreeMap()));&#125;<span class="hljs-comment">// 指定比较器的构造函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>((NavigableMap)(<span class="hljs-keyword">new</span> TreeMap(var1)));&#125;<span class="hljs-comment">//将指定的集合var1放入TreeSet中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    <span class="hljs-keyword">this</span>.addAll(var1);&#125;<span class="hljs-comment">// 将有序集合var1放入TreeSet中</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(SortedSet&lt;E&gt; var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>(var1.comparator());    <span class="hljs-keyword">this</span>.addAll(var1);&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>TreeSet底层是使用TreeMap来存储数据，key值为TreeSet中的数据，value值为一个空的Object对象</li><li>TreeSet的方法大多是通过调用TreeMap中的方法来实现的</li><li>TreeSet和TreeMap一样，都是线程不安全的集合类</li><li>TreeSet和TreeMap一样，有两种方式定义key的比较规则，优先使用指定的构造器进行比较key，也就是说它是无序存储的，但是它可以排序。<ul><li>key实现Comparable接口重写compareTo方法。</li><li>通过TreeSet的构造方法指定构造器。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>集合源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashSet源码分析</title>
    <link href="/cxlittlecute/ba405a18.html"/>
    <url>/cxlittlecute/ba405a18.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a>HashSet源码分析</h1><h2 id="HashSet分析"><a href="#HashSet分析" class="headerlink" title="HashSet分析"></a>HashSet分析</h2><p>1、类的继承实现关系</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt; </span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;&#125;</code></pre><p>1、核心成员变量</p><pre><code class="hljs java"><span class="hljs-comment">//HashSet底层是基于HashMap存储数据，该map的key就是HashSet要存放的数据</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="hljs-comment">//该变量用来填充上一个map的value字段，因为HashSet关注的是map的Key</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();</code></pre><p>2、构造函数</p><pre><code class="hljs java"><span class="hljs-comment">// 默认初始化一个HashMap对象</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();&#125;<span class="hljs-comment">//这个构造函数允许传入集合进行初始化</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">//直接通过集合大小和默认负载比推算出应该初始化的容量，+1是为了防止出现小数向上取整</span>    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="hljs-keyword">int</span>) (c.size()/.<span class="hljs-number">75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));    <span class="hljs-comment">//添加元素</span>    addAll(c);&#125;<span class="hljs-comment">// 可指定大小和负载比，但实际还是初始化一个hashmap对象</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;<span class="hljs-comment">// 可指定容量大小，但初始化的还是hashmap对象</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(initialCapacity);&#125;<span class="hljs-comment">// 这次初始化的是一个linkedhashmap对象，可以看出最后一个参数暂时没用，</span><span class="hljs-comment">// 但是有这个参数，就可以初始化为linkedhashmap对象</span><span class="hljs-comment">// 注意该构造方法不是public的，且注释中已经说该构造方法只会被LinkedHashSet使用，</span><span class="hljs-comment">// 所以平常我们new HashSet的时候是不能用的</span>HashSet(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">boolean</span> dummy) &#123;    map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;</code></pre><p>3、添加方法</p><pre><code class="hljs java"><span class="hljs-comment">// 可见内部还是调用的hashmap的put方法实现，我们知道HashMap的put方法,</span><span class="hljs-comment">// 如果该位置已经存在一个一样的Key，会用新的value替换原来的旧的value，</span><span class="hljs-comment">// 并且返回旧的value，所以对于HashSet而言第一次插入返回null就代表成功，</span><span class="hljs-comment">// 添加一个元素，如果该元素不存在，则返回true，如果存在，则返回false</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">//往map中添加元素，返回null，说明是第一个往map中添加该key</span>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre><p>4、删除方法</p><pre><code class="hljs java"><span class="hljs-comment">//也是调用的hashmap的移除方法，同添加一样，通过返回的值判断是否删除成功</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map.remove(var1) == PRESENT;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、hashSet底层是基于hashMap实现的，hashSet存储的元素对应hashMap的key，因为hashMap不能存储重复的Key，所以hashSet不能存放重复元素。<br>2、由于hashMap的key是基于hashCode存储对象的，所以hashSet中存放的对象也是无序的。<br>3、hashSet也没有提供get方法，可以通过Iterator迭代器获取数据。<br>4、HashSet中允许有一个null元素，因为HashMap允许key为null。<br>5、HashSet是非线程安全的。</p>]]></content>
    
    
    <categories>
      
      <category>集合源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector源码分析</title>
    <link href="/cxlittlecute/5a9972d1.html"/>
    <url>/cxlittlecute/5a9972d1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Vector源码分析"><a href="#Vector源码分析" class="headerlink" title="Vector源码分析"></a>Vector源码分析</h1><p>我们看见Vector的第一反应就是它底层是数组并且线程安全，那么接下来我们就来看看是不是这样的，它还有什么特征点没有。</p><p>类的继承关系：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; </span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;&#125;</code></pre><h2 id="Vector分析"><a href="#Vector分析" class="headerlink" title="Vector分析"></a>Vector分析</h2><p>1、类成员变量</p><pre><code class="hljs java"><span class="hljs-comment">// 存储数据的数组，这是一个动态的数组</span><span class="hljs-keyword">protected</span> Object[] elementData;<span class="hljs-comment">// 当前元素的个数</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> elementCount;<span class="hljs-comment">// 容量增长系数，扩容时使用,每次需要增长时，值就会增加一倍</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> capacityIncrement;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">2767605614048989439L</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ARRAY_SIZE = <span class="hljs-number">2147483639</span>;</code></pre><p>2、构造方法</p><pre><code class="hljs java"><span class="hljs-comment">// 指定数组初始化容量大小和增长系数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">int</span> capacityIncrement)</span> </span>&#123;    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//初始化容量小于0，抛出异常</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+                                           initialCapacity);    <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<span class="hljs-comment">// 为对象数组指定初始化容量</span>    <span class="hljs-keyword">this</span>.capacityIncrement = capacityIncrement;<span class="hljs-comment">// 传参，设置增长系数</span>&#125;<span class="hljs-comment">// 指定Vector初始化容量大小，默认增长系数为0</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0</span>);&#125;<span class="hljs-comment">// 构造一个空的Vector，增长系数为0</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//初始化容量为10</span>    <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);&#125;<span class="hljs-comment">// 构造一个包含指定集合C中的元素的数组</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    elementData = c.toArray();<span class="hljs-comment">// 获取集合C中的元素，将其放入数组中</span>    elementCount = elementData.length;<span class="hljs-comment">// 添加成功后，Vector的元素个数就是数组的长度</span>    <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)// 判断添加进的元素对象是否为对象数组类型</span><span class="hljs-class">    // 否则进行拷贝,将类型转化为对象数组</span><span class="hljs-class">        <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, elementCount, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><p>从上面我们可以看出：</p><ul><li>Vector是使用数组保存数据，和ArrayList类似。</li><li>如果没有指定构造Vector那么它的默认容量位 10 增长系数位 0</li></ul><p>3、我们接下来继续来看看Vector是如何添加和扩容的。</p><pre><code class="hljs java"><span class="hljs-comment">// 步骤一 添加元素</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E var1)</span> </span>&#123;    ++<span class="hljs-keyword">this</span>.modCount;    <span class="hljs-comment">// 判断是否需要扩容</span>    <span class="hljs-keyword">this</span>.ensureCapacityHelper(<span class="hljs-keyword">this</span>.elementCount + <span class="hljs-number">1</span>);    <span class="hljs-keyword">this</span>.elementData[<span class="hljs-keyword">this</span>.elementCount++] = var1;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">// 步骤二 </span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code检测是否大于数组长度</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);&#125;<span class="hljs-comment">// 步骤三 扩容操作</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// 原Vector容量值</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-comment">// 如果有给capacityIncrement设置增长系数的话，就加上该系数值来扩容，</span>    <span class="hljs-comment">// 否则将原先的数组容量变为2*oldCapacity</span>    <span class="hljs-comment">// 注意：这是和ArrayList不同的地方，这个的自动扩容是直接增加一个oldCapacity，也就是扩大了一倍。</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?                                    capacityIncrement : oldCapacity);    <span class="hljs-comment">// 如果重新设置的容量值还要小于最小要求的容量值得话</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)         <span class="hljs-comment">// 就将最小的容量值赋值给新的容量</span>        newCapacity = minCapacity;    <span class="hljs-comment">// 如果重新设置的新容量值比限制的最大容量还要大的话，则进行Integer.MAX_VALUE来进行扩张。</span>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        <span class="hljs-comment">// 重新设置大小</span>        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// 将原先数组的元素浅拷贝到一个新的数组</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;<span class="hljs-comment">// 步骤四 限制最大容量</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var0)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var0 &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> var0 &gt; <span class="hljs-number">2147483639</span> ? <span class="hljs-number">2147483647</span> : <span class="hljs-number">2147483639</span>;    &#125;&#125;</code></pre><p>4、线程安全</p><p>在Vector中大多的方法使用了synchronized来进行修饰，以确保该方法是同步的，也就是这样才导致了Vector的查询没有ArrayList快的原因了，因为多了加锁释放锁的时间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、Vector内部用来大量的synchronized保证同步，是线程安全的List实现。<br>2、通过capacity指定数组容量，capacityIncrement指定扩容增量。capacityIncrement&lt;=0时（增长系数），新容量为原来2倍，否则新容量为(原容量 + capacityIncrement )。这并不是最后的容量，而是用新容量与指定的minCapacity比较，取较大值作为最后的新容量。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>怎么将一个线程不安全的ArrayList集合转换为线程安全的？</p><p>使用集合工具类：java.util.Collections</p><pre><code class="hljs java">List myList = <span class="hljs-keyword">new</span> ArrayList();Collections.synchronizedList(myList);myList.add(<span class="hljs-string">"111"</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>集合源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList源码分析</title>
    <link href="/cxlittlecute/475fb381.html"/>
    <url>/cxlittlecute/475fb381.html</url>
    
    <content type="html"><![CDATA[<h1 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h1><p>在简介LinkedList之前我们先来回顾一下，单向链表的优缺点。</p><p>优点：随机增删元素效率较高。（因为增删元素不像数组一样涉及大量元素位移的问题）<br>缺点：查询效率较低，每一次查找某个元素的时候都需要从头结点开始往下遍历。</p><p>首先我们需要认识LinkedList的底层是双向链表（也就是说顺着和逆着都能找到相应的结点）。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824223450.png" srcset="/img/loading.gif" alt=""></p><h2 id="LinkedList分析"><a href="#LinkedList分析" class="headerlink" title="LinkedList分析"></a>LinkedList分析</h2><p>1、LinkedList继承于AbstractSequentialList的双向链表，实现List接口，因此也可以对其进行队列操作，它也实现了Deque接口，所以LinkedList也可当做双端队列使用，还有LinkedList是非同步的。</p><p>类的继承关系</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt; </span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;&#125;</code></pre><p>2、成员变量</p><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前列表的元素个数</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<span class="hljs-comment">// 指针指向第一个结点</span><span class="hljs-comment">// 默认值都为null</span><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<span class="hljs-comment">// 指针指向最后一个结点</span></code></pre><p>3、我们来看看在LinkedList中的add方法是如何进行的。</p><pre><code class="hljs java"><span class="hljs-comment">// 步骤一</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>.linkLast(var1);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">// 步骤二</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">linkLast</span><span class="hljs-params">(E var1)</span> </span>&#123;    <span class="hljs-comment">// 取出当前最后一个节点（刚开始last为Null）</span>    LinkedList.Node l = <span class="hljs-keyword">this</span>.last;    <span class="hljs-comment">// 创建一个新节点，注意其前驱节点为l，后续节点为null</span>    LinkedList.Node newNode = <span class="hljs-keyword">new</span> LinkedList.Node(l, var1, (LinkedList.Node)<span class="hljs-keyword">null</span>);    <span class="hljs-comment">// 记录新的最后一个节点</span>    <span class="hljs-keyword">this</span>.last = newNode;    <span class="hljs-comment">// 如果最后一个节点为空，则表示链表为空，则将first节点也赋值为newNode</span>    <span class="hljs-keyword">if</span> (l == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">this</span>.first = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 关联l的next节点，构成双向节点</span>        l.next = newNode;    &#125;    <span class="hljs-comment">// 元素总数加1</span>    ++<span class="hljs-keyword">this</span>.size;    <span class="hljs-comment">// 修改次数自增</span>    ++<span class="hljs-keyword">this</span>.modCount;&#125;<span class="hljs-comment">// 步骤三 LinkedList底层数据结构</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    E item; <span class="hljs-comment">// 存储元素</span>    LinkedList.Node&lt;E&gt; next; <span class="hljs-comment">// 指向下一个元素</span>    LinkedList.Node&lt;E&gt; prev; <span class="hljs-comment">// 指向上一个元素</span>    Node(LinkedList.Node&lt;E&gt; var1, E l, LinkedList.Node&lt;E&gt; newNode) &#123;        <span class="hljs-keyword">this</span>.item = l;        <span class="hljs-keyword">this</span>.next = newNode;        <span class="hljs-keyword">this</span>.prev = var1;    &#125;&#125;</code></pre><p>LinkedList加入元素是直接放在链表尾的，主要点构成双向链表。</p><p>4、构造方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//无参构造函数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-keyword">this</span>();    addAll(c);<span class="hljs-comment">//将c中的元素都添加到此列表中</span>&#125;</code></pre><p>5、接下来我们再来看看addAll方法</p><pre><code class="hljs java"><span class="hljs-comment">// 步骤一</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-keyword">return</span> addAll(size, c); <span class="hljs-comment">//此时 size == 0</span>&#125;<span class="hljs-comment">// 步骤二</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;    <span class="hljs-comment">// 检查index是否越界</span>    checkPositionIndex(index);    <span class="hljs-comment">// 将集合c转换为Object数组 a</span>    Object[] a = c.toArray();    <span class="hljs-keyword">int</span> numNew = a.length;    <span class="hljs-comment">// 如果插入集合无数据，则直接返回</span>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// succ的前驱节点</span>    Node&lt;E&gt; pred, succ;    <span class="hljs-comment">// 如果index与size相同</span>    <span class="hljs-keyword">if</span> (index == size) &#123;        <span class="hljs-comment">// succ的前驱节点直接赋值为最后节点</span>        <span class="hljs-comment">// succ赋值为null，因为index在链表最后</span>        <span class="hljs-comment">//情况一：构造方法创建的一个空的链表，那么size=0，last、和first都为null。</span>        <span class="hljs-comment">//         linkedList中是空的。什么节点都没有。succ=null、pred=last=null</span>        <span class="hljs-comment">//情况二：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，</span>        <span class="hljs-comment">//       在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，</span>        <span class="hljs-comment">//       所以把last保存到pred临时节点中。</span>        succ = <span class="hljs-keyword">null</span>;        pred = last;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//情况三、index！=size，说明不是前面两种情况，而是在链表中间插入元素，</span>        <span class="hljs-comment">//那么就得知道index上的节点是谁，保存到succ临时节点中，然后将succ的前一个</span>        <span class="hljs-comment">//节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了</span>        <span class="hljs-comment">//举个简单的例子，有2个位置，1、2、如果想插数据到第二个位置，双向链表中，</span>        <span class="hljs-comment">//就需要知道第一个位置是谁，原位置也就是第二个位置上是谁</span>        succ = node(index);        pred = succ.prev;    &#125;    <span class="hljs-comment">// 遍历插入集合</span>    <span class="hljs-keyword">for</span> (Object o : a) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>) E e = (E) o;        <span class="hljs-comment">// 创建新节点 前驱节点为succ的前驱节点，后续节点为null</span>        <span class="hljs-comment">//pred就是之前所构建好的，可能为null、也可能不为null，</span>        <span class="hljs-comment">//为null的话就是属于情况一、不为null则可能是情况二、或者情况三</span>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;(pred, e, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// succ的前驱节点为空，则表示succ为头，则重新赋值第一个结点</span>        <span class="hljs-comment">//如果pred==null，说明是情况一，构造方法，是刚创建的一个空链表，</span>        <span class="hljs-comment">//此时的newNode就当作第一个节点，所以把newNode给first头节点</span>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-keyword">null</span>)            first = newNode;        <span class="hljs-keyword">else</span>            <span class="hljs-comment">// 构建双向链表</span>            <span class="hljs-comment">//如果pred！=null，说明可能是情况2或者情况3，</span>            <span class="hljs-comment">//如果是情况2，pred就是last，那么在最后一个节点之后追加到newNode，</span>            <span class="hljs-comment">//如果是情况3，在中间插入，pred为原index节点之前的一个节点，</span>            <span class="hljs-comment">//将它的next指向插入的节点，也是对的</span>            pred.next = newNode;        <span class="hljs-comment">// 将前驱节点移动到新节点上，继续循环</span>        pred = newNode;    &#125;    <span class="hljs-comment">// index位置上为空 赋值last节点为pred，因为通过上述的循环pred已经走到最后了</span>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-keyword">null</span>) &#123;        last = pred;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 构建双向链表</span>        pred.next = succ;        succ.prev = pred;    &#125;    <span class="hljs-comment">// 元素总数更新</span>    size += numNew;    <span class="hljs-comment">// 修改次数自增</span>    modCount++;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>6、在LinkedList中的get方法按位读取的内部也有小小的优化。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    checkElementIndex(index);    <span class="hljs-keyword">return</span> node(index).item;&#125;<span class="hljs-function">Node&lt;E&gt; <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;   <span class="hljs-comment">//查询位置在链表前半部分，从链表头开始查找</span>        Node&lt;E&gt; x = first;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)            x = x.next;        <span class="hljs-keyword">return</span> x;    &#125; <span class="hljs-keyword">else</span> &#123;                     <span class="hljs-comment">//查询位置在链表后半部分，从链表尾开始查找</span>        Node&lt;E&gt; x = last;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt; index; i--)            x = x.prev;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、linkedList本质上是一个双向链表，通过一个Node内部类实现的这种链表结构。<br>2、对于链表的数据结构来说，随机增删效率较高。检索效率较低。链表中的元素在空间存储上，内存地址不连续。<br>3、linkedList不光能当链表，还能当队列使用。<br>4、linkedList不光能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值。<br>5、LinkedList序列化的时候将链表按顺序拆分开来，仅序列化结点中保存的数据，反序列化的时候重新连接链表，保证了链表的有效性。</p>]]></content>
    
    
    <categories>
      
      <category>集合源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码分析</title>
    <link href="/cxlittlecute/c352a0f3.html"/>
    <url>/cxlittlecute/c352a0f3.html</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>本文主要根据源码来看一下集合中各实现类的特点。</p><h2 id="ArrayList分析"><a href="#ArrayList分析" class="headerlink" title="ArrayList分析"></a>ArrayList分析</h2><p>0、类的继承关系</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; </span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;&#125;</code></pre><p>1、ArrayList集合初始化默认容量10.（注意不是初始化的时候就会创建为容量为10的数组,而是第一个元素被添加的时候）</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;</code></pre><p>2、ArrayList集合底层是一个Object类型的数组.</p><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;</code></pre><p>3、Size获取的是当前集合中元素的个数，不是获取集合的容量.</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;</code></pre><p>4、有参构造方法，可以指定数组的大小构建ArrayList集合.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[var1];    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (var1 != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span> + var1);        &#125;        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><p>5、无参构造方法，默认初始化应该是一个空的数组.</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;</code></pre><p>6、有参构造方法，容器数组化处理</p><pre><code class="hljs java"><span class="hljs-comment">// 根据已有集合生成ArrayList的构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; var1)</span> </span>&#123;    <span class="hljs-comment">// 将集合转化为对象数组，因为ArrayList中数据是保存在对象数组中的</span>    <span class="hljs-keyword">this</span>.elementData = var1.toArray();    <span class="hljs-comment">//将集合中数据数量赋值给size，判断size值是否为0</span>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.size = <span class="hljs-keyword">this</span>.elementData.length) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;             <span class="hljs-comment">// 将集合var1中数据复制存入ArrayList的数据容器</span>            <span class="hljs-keyword">this</span>.elementData = Arrays.copyOf(<span class="hljs-keyword">this</span>.elementData, <span class="hljs-keyword">this</span>.size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="hljs-comment">// 创建一个初始容量为0的ArrayList</span>    &#125;&#125;</code></pre><p>7、上面说到了在add的时候才会初始化数组，那么我们就来看看add方法.（添加和扩容）</p><pre><code>add(E e)：添加一个元素到列表的末尾。add( int index, E element ) :在指定的位置添加元素addAll( Collection&lt;? extends E&gt; c )：添加一个集合到元素的末尾.以上返回类型booleanensureCapcity（int minCapcity）：确保列表中含有minCapcity的最小容量</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 第一步</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E var1)</span> </span>&#123;    <span class="hljs-comment">// 加入元素前检查数组的容量是否足够</span>    <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.size + <span class="hljs-number">1</span>);    <span class="hljs-keyword">this</span>.elementData[<span class="hljs-keyword">this</span>.size++] = var1;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">// 第二步</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>.ensureExplicitCapacity(calculateCapacity(<span class="hljs-keyword">this</span>.elementData, var1));&#125;<span class="hljs-comment">// 第三步 如果数组元素等于默认空数组的话,那么数组插入数组索引下标会进行一个取最大值的操作</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] var0, <span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-comment">// 数组等于默认空数组</span>    <span class="hljs-keyword">return</span> var0 == DEFAULTCAPACITY_EMPTY_ELEMENTDATA ? Math.max(<span class="hljs-number">10</span>, var1) : var1;<span class="hljs-comment">//在数组初始容量和数组的下标中取一个最大值</span>&#125;<span class="hljs-comment">// 第四步 为了明确保证数组容量序列化计算</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-comment">//反序列化计算器加 1 </span>    ++<span class="hljs-keyword">this</span>.modCount;    <span class="hljs-comment">// //如果要指定添加元素的下标位置 &gt; 数组长度  此时就要扩容</span>    <span class="hljs-keyword">if</span> (var1 - <span class="hljs-keyword">this</span>.elementData.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.grow(var1);    &#125;&#125;<span class="hljs-comment">// 第五步 计算新数组的长度=原始数组的1.5倍</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.elementData.length;    <span class="hljs-comment">// var2 == old  var3 == new</span>    <span class="hljs-comment">// 将数组的长度增加原来数组的一半</span>    <span class="hljs-comment">// 新的数组长度 = 原始数组长度 + 原始数组 / 2</span>    <span class="hljs-keyword">int</span> var3 = var2 + (var2 &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 如果新的数组长度 &lt; 要添加元素的位置</span>    <span class="hljs-keyword">if</span> (var3 - var1 &lt; <span class="hljs-number">0</span>) &#123;        var3 = var1; <span class="hljs-comment">//新数组长度 = 添加元素的位置长度</span>    &#125;    <span class="hljs-comment">// 如果新的数组长度 &gt; 2147483639 </span>    <span class="hljs-keyword">if</span> (var3 - <span class="hljs-number">2147483639</span> &gt; <span class="hljs-number">0</span>) &#123;        var3 = hugeCapacity(var1); <span class="hljs-comment">//就判断是否超过了JVM内存</span>    &#125;    <span class="hljs-keyword">this</span>.elementData = Arrays.copyOf(<span class="hljs-keyword">this</span>.elementData, var3);&#125;<span class="hljs-comment">// 第六步 判断这个新数组长度是否JVM内存分配的最大值</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var0)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var0 &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> var0 &gt; <span class="hljs-number">2147483639</span> ? <span class="hljs-number">2147483647</span> : <span class="hljs-number">2147483639</span>;    &#125;&#125;</code></pre><p>8、将下标索引var1的数据删除</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    ++<span class="hljs-keyword">this</span>.modCount;    <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.size - var1 - <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (var2 &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果var1大于ArrayList中数据数量，将下标索引var1后面的数据前移一位</span>        System.arraycopy(<span class="hljs-keyword">this</span>.elementData, var1 + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.elementData, var1, var2);    &#125;    <span class="hljs-keyword">this</span>.elementData[--<span class="hljs-keyword">this</span>.size] = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//将最后一个数据设置为null</span>&#125;</code></pre><p>9、清空ArrayList中数据</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    ++<span class="hljs-keyword">this</span>.modCount;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var1 = <span class="hljs-number">0</span>; var1 &lt; <span class="hljs-keyword">this</span>.size; ++var1) &#123;        <span class="hljs-keyword">this</span>.elementData[var1] = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//将数据容器中数据赋值为null</span>    &#125;    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<span class="hljs-comment">//将ArrayList中数据数量赋值为0</span>&#125;</code></pre><p>10、将集合var1中数据添加到ArrayList末尾</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; var1)</span> </span>&#123;    Object[] var2 = var1.toArray();<span class="hljs-comment">//将集合var1转化为对象数组</span>    <span class="hljs-keyword">int</span> var3 = var2.length;    <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.size + var3);<span class="hljs-comment">//扩大ArrayList数据容器大小</span>    System.arraycopy(var2, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.elementData, <span class="hljs-keyword">this</span>.size, var3);<span class="hljs-comment">//将对象数组var2中数据复制到ArrayList的数据容器末尾</span>    <span class="hljs-keyword">this</span>.size += var3;    <span class="hljs-keyword">return</span> var3 != <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、关于ArrayList扩容，首次扩容是增长到原容量的1.5倍，如果仍不够就以新数组的长度为最新的容量。</p><p>2、优化扩容：由于底层是数组，我们应尽可能减少扩容，因为数组的扩容效率比较低下，建议在使用的时候预估元素的个数，给定一个初始容量。</p><p>3、<br>数组的优点：检索效率比较高。（在数组中每个元素占用的空间大小相同，内存地址是连续的，知道首元素内存地址，然后知道下标，通过数学表达式计算出元素的内存地址，所以检索效率最高）</p><p>数组的缺点：随机增删元素效率比较低。（但是向数组末尾添加元素的效率还是很高的）另外数组很难找到一块非常巨大的连续的内存空间。</p><p>4、总的来说ArrayList是我们平常使用的最多的集合，因为往数组末尾添加元素，效率不受影响，另外，我们检索/查找某个元素的操作比较多。</p><p>5、数组的长度不是没有上限的,如果超过2147483639就会报OOM。</p><p>6、ArrayList自己实现了序列化和反序列化的方法。</p><p>7、ArrayList里面的数组elementData是声明为transient的，表示ArrayList在序列化的时候，默认不会序列化这些数组元素。因为ArrayList实际上是动态数组，每次在放满以后会扩容，如果数组扩容后，实际上只放了一个元素，那就会序列化很多null元素，浪费空间，所以ArrayList把元素数组设置为transient，仅仅序列化已经保存的数据。</p>]]></content>
    
    
    <categories>
      
      <category>集合源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>contains()和remove()源码分析</title>
    <link href="/cxlittlecute/5b7502b5.html"/>
    <url>/cxlittlecute/5b7502b5.html</url>
    
    <content type="html"><![CDATA[<h1 id="contains-和remove-源码分析"><a href="#contains-和remove-源码分析" class="headerlink" title="contains()和remove()源码分析"></a>contains()和remove()源码分析</h1><h2 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h2><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p>我们首先来看一下这样的一段代码结果是什么</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);    String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"def"</span>);    list.add(s1);    list.add(s2);    String x = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);    System.out.println(list.contains(x)); <span class="hljs-comment">// 结果是多少</span>&#125;</code></pre><h3 id="JVM中的结构演示"><a href="#JVM中的结构演示" class="headerlink" title="JVM中的结构演示"></a>JVM中的结构演示</h3><p>得出结果之前我们首先来看一下，这段代码在JVM的结构是怎么样的。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824165345.png" srcset="/img/loading.gif" alt=""></p><p>我们可以看出它确实不存于我们的集合中，但是这里我们就需要思考contains（）底层是如何进行比较的。于是我们可以进入contains方法去看一下。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>1、在ArrayList集合中实现的contains调用了IndexOf方法</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824165905.png" srcset="/img/loading.gif" alt=""></p><p>2、我们接着进去这个IndexOf方法。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824170456.png" srcset="/img/loading.gif" alt=""></p><p>3、这里我们可以看到底层调用的是equals方法，我们知道在我们String类中重写了equals（），比较的是内容。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824170803.png" srcset="/img/loading.gif" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>contains方法判断集合中是否包含某个元素是调用equals方法进行比对的。<br>如果我们的对象重写了equals方法并设置为值比较那么就是值比较。如果没有重写那么就是继承的Object的equals方法比较的是地址，等于==。</p><p>所以存放在集合中的类型一定要重写equals方法</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><h3 id="代码片段-1"><a href="#代码片段-1" class="headerlink" title="代码片段"></a>代码片段</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);    String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);    list.add(s1);    list.remove(s2);    System.out.println(list.size());&#125;</code></pre><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824181220.png" srcset="/img/loading.gif" alt=""></p><p>同样调用的是equals方法</p><p>分析和上面的contains（）类似这里就不展开进行分析了。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合继承图分析</title>
    <link href="/cxlittlecute/be62119f.html"/>
    <url>/cxlittlecute/be62119f.html</url>
    
    <content type="html"><![CDATA[<h1 id="集合继承图分析"><a href="#集合继承图分析" class="headerlink" title="集合继承图分析"></a>集合继承图分析</h1><p>从本篇文章开始，将回顾Java中集合这一块的知识。</p><p>首先我们可以把Java中的集合分为两大类：</p><ul><li>单个方式存储的元素，这一类集合中的超级父接口：java.util.Collection</li><li>键值对方式存储元素，这一类集合中的超级父接口：java.util.Map</li></ul><h2 id="Collection的继承结构"><a href="#Collection的继承结构" class="headerlink" title="Collection的继承结构"></a>Collection的继承结构</h2><p>我们主要看的是List和Set子接口。通过下面这个结构图的分析我们可以很清楚的理解它们之间的关系。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824120612.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824122416.png" srcset="/img/loading.gif" alt=""></p><p>补充：</p><ul><li>SortedSet集合存储元素的特点是，由于继承了Set集合，它的特点也是无序不可重复，但是放在SortedSet集合中的元素可以自动排序。我们称为可排序集合。放到该集合中的元素是自动按照大小顺序排序的。</li><li>补充说明一下迭代器需要注意的地方：<br>1、集合结构只要发生改变，迭代器必须重新获取。<br>2、初学的时候使用迭代器我们可能会进行一个删除元素的操作(没有使用迭代器删除)，但是这样其实是错误，原因也同1因为我们改变了集合内的元素。所以在迭代集合元素的过程中，不能调用集合对象的remove方法，删除元素。（上面两种情况都会出现java.util.ConcurrentModificationException)<ul><li>迭代器好比我们集合的快照，我们需要通知迭代器的快照和集合一起删除才行。需要保证我们快照和集合里的元素是统一的，不然就会报错。</li></ul></li></ul><h3 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h3><ul><li>1、Collection继承Iterable接口：</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824140825.png" srcset="/img/loading.gif" alt=""></p><ul><li>2、ArrayList和Vector底层都是数组：</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824141209.png" srcset="/img/loading.gif" alt=""></p><ul><li>3、HashSet底层创建的是HashMap集合</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824141522.png" srcset="/img/loading.gif" alt=""></p><ul><li>4、TreeSet底层new的是TreeMap，同时它实现的接口继承了SortedSet</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824141924.png" srcset="/img/loading.gif" alt=""></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824152348.png" srcset="/img/loading.gif" alt=""></p><h2 id="Map的继承结构"><a href="#Map的继承结构" class="headerlink" title="Map的继承结构"></a>Map的继承结构</h2><p>首先我们需要认识到，我们Map接口是一个独立的接口，和我们的Collection接口是没有关系的。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824143531.png" srcset="/img/loading.gif" alt=""></p><h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h3><ul><li><p>我们来理解一下Map集合的Key和Set集合存储元素特点相同。（也就是说不可以重复）</p><p>  在HashSet中：</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200824143213.png" srcset="/img/loading.gif" alt=""></p><h2 id="总结-部分的实现类"><a href="#总结-部分的实现类" class="headerlink" title="总结(部分的实现类)"></a>总结(部分的实现类)</h2><ul><li>ArrayList：底层是数组。</li><li>LinkedList：底层是双向链表。</li><li>Vector：底层是数组，线程安全的，效率较低，使用较少。</li><li>HashSet：底层是HashMap，放到HashSet中的元素等同于放到HashMap集合key部分了。</li><li>TreeSet：底层是TreeMap，放到TreeSet中的元素等同于放到TreeMap集合key部分了。</li><li>HashMap：底层是哈希表。</li><li>Hashtable：底层也是哈希表，只不过是线程安全的，效率较低，使用较少。</li><li>Properties：线程安全的，并且key和value只能存储字符串String。</li><li>TreeMap：底层是二叉树。TreeMap集合的key可以自动按照大小顺序排序。</li></ul><p><strong>List集合存储元素的特点：</strong></p><p>有序可重复<br>有序：指存进去和取出来的顺序相同，每一个元素都有下标。<br>可重复：存进去的元素可以重复。</p><p><strong>Set集合存储元素的特点：</strong><br>无序不可重复<br>无序：存进去和取出来的顺序不相同，每一个元素没有下标。<br>不可重复：存进去一个元素，就不能再次存进去一个相同的元素。</p><p><strong>SortedSet(SortedMap)集合存储元素的特点：</strong><br>无序不可重复，但是SortedSet集合中的元素是可排序的。<br>无序：存进去和取出来的顺序不相同，每一个元素没有下标。<br>不可重复：存进去一个元素，就不能再次存进去一个相同的元素。<br>可排序：可以按照大小顺序排序。</p><p>注意：集合中不能存储基本数据类型，也不能存储Java对象，只是存储Java对象的内存地址。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存穿透、击穿与雪崩</title>
    <link href="/cxlittlecute/143a556.html"/>
    <url>/cxlittlecute/143a556.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis缓存穿透、击穿与雪崩"><a href="#Redis缓存穿透、击穿与雪崩" class="headerlink" title="Redis缓存穿透、击穿与雪崩"></a>Redis缓存穿透、击穿与雪崩</h1><p>首先我们需要明白的是，这都是服务的高可用问题。本文只是解决面试中遇到这类问题应该如何回答，不会详细的去分析解决方案的底层。</p><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823161537.png" srcset="/img/loading.gif" alt=""></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查不到导致的</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀场景！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823161930.png" srcset="/img/loading.gif" alt=""></p><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823162703.png" srcset="/img/loading.gif" alt=""></p><p>但是这种方法会存在两个问题：<br>1 、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；<br>2 、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>量太大，缓冲过期导致的，就是一个空档期全部砸到了Mysql上。</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="设置热点数据永不过期"><a href="#设置热点数据永不过期" class="headerlink" title="设置热点数据永不过期"></a>设置热点数据永不过期</h4><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p><h4 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h4><p>分布式锁：使用分布式锁，保证对于<strong>每个key同时只有一个线程去查询后端服务</strong>，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823164045.png" srcset="/img/loading.gif" alt=""></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823164455.png" srcset="/img/loading.gif" alt=""></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><p>比如：双十一的时候我们就会停掉一些服务，为的就是保证主要的服务可用。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h4><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p><h4 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h4><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从复制</title>
    <link href="/cxlittlecute/b7e51ad7.html"/>
    <url>/cxlittlecute/b7e51ad7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；==数据的复制是单向的，只能由主节点到从节点==。</p><p>Master以写为主，Slave 以读为主。</p><p>==默认情况下，每台Redis服务器都是主节点==；<br>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><p>1 、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>2 、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br>3 、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>4 、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><p>1 、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>2 、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，==单台Redis最大使用内存不应该超过20G==。</p><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p>对于这种场景，我们可以使如下这种架构：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823110917.png" srcset="/img/loading.gif" alt=""></p><p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！一主二从！<br>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库！</p><p>1.运行redis镜像</p><pre><code class="hljs bash">docker run --name redis-6379 -p 6379:6379 -d redisdocker run --name redis-6380 -p 6380:6379 -d redisdocker run --name redis-6381 -p 6381:6379 -d redis</code></pre><p>使用docker ps命令，查看是否启动成功</p><p>2.配置redis集群</p><p>分别使用dokcer inspect 容器ID命令，查看3个Redis内网IP地址:</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823114118.png" srcset="/img/loading.gif" alt=""></p><p>他们都是属于同一网段。</p><p>3.进入Docker容器内部</p><p>使用redis-6379为主机，其余两台为从机<br>使用 docker exec -ti 容器ID /bin/bash 分别进入三个Redis容器<br>进入容器后，使用 redis-cli 命令，连接redis服务端<br>连接服务后，使用 info replication 查看当前机器的角色<br>未配置前，三台redis均为 master主机</p><p>4.接着使用上面的方法，分别进入 redis-6379、redis-6380、redis-6381容器内部，并连接redis服务端。</p><p>分别在redis-6380和redis-6381使用 SLAVEOF 172.17.0.6 6379 命令<br>在redis-6379 使用 info replication 命令，验证主从关系是否配置成功</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823121809.png" srcset="/img/loading.gif" alt=""></p><p>这里的主从配置，还可以在配置文件中配置。由于我们运行容器的时候没有映射配置文件，所以docker中是没有redis.conf配置文件的，我们需要重新删除容器映射配置文件，然后就可以在配置文件中的主从配置处进行配置。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823123656.png" srcset="/img/loading.gif" alt=""></p><p>细节：<br>==主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！==</p><p>测试：<br>主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p><p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！（这也算是命令行配置的缺点）</p><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步==。</p><p>==全量复制==：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p>==增量复制==：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p><h2 id="层层链路"><a href="#层层链路" class="headerlink" title="层层链路"></a>层层链路</h2><p>我们之前的模型如果只是单主双从的话，主机挂了就无法写入了，从机不会自动改变成主机。现在我们使用这种层层链路的方式，使上一个M链接下一个S。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823145908.png" srcset="/img/loading.gif" alt=""></p><p>这时候也可以完成我们的主从复制！</p><p>如果主机断开了连接，我们可以使用==SLAVEOF no one==让自己变成主机！其他的节点就可以手动连<br>接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>（自动选举老大的模式）</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。 </p><p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数==自动将从库转换为主库==。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823152236.png" srcset="/img/loading.gif" alt=""></p><h3 id="哨兵作用"><a href="#哨兵作用" class="headerlink" title="哨兵作用"></a>哨兵作用</h3><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823152400.png" srcset="/img/loading.gif" alt=""></p><p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 <strong>主观下线</strong> 。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong> 。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>1.配置哨兵<br>Redis哨兵配置，有两种方案:</p><ul><li>方案一：基于现有的3台Redis容器服务，互相启动一个Redis哨兵</li><li>方案二：重新再启动3台Redis容器服务，分别启动一个Redis哨兵</li></ul><p>方案二会额外的新增3个Redis容器服务，所以这里演示方案一.</p><p><a href="https://www.cnblogs.com/fan-gx/p/11463400.html" target="_blank" rel="noopener">第二种方案可以点击此处</a></p><p>2.分别进入3台Redis容器内部，执行以下操作<br>首先，进入Docker容器内部:</p><pre><code>使用 docker exec -ti 容器ID /bin/bash 分别进入三个Redis容器</code></pre><p>3.然后，编写Redis哨兵配置文件</p><pre><code>使用 cd / 命令，进入根目录</code></pre><p>使用touch sentinel.conf命令，创建哨兵配置文件</p><p>4.在进行编辑时，需要先安装vim，命令为apt-get update ,apt-get install vim<br>使用 vim 命令编辑 sentinel.conf 文件，添加以下内容</p><pre><code class="hljs bash"><span class="hljs-comment"># sentinel monitor 被监控的名称 host port 1</span>sentinel monitor myredis 127 .0.0.1 6379 1</code></pre><p>后面的这个数字 1 ，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p><p>5.最后，启动Redis哨兵</p><p>使用redis-sentinel /sentinel.conf启动Redis哨兵监控<br>使用ps –ef |grep redis命令，可以看到redis-server和redis-sentinel正在运行</p><p>==注意：==<br>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</p><p>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>优点：<br>1 、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有<br>2 、 主从可以切换，故障可以转移，系统的可用性就会更好<br>3 、哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p><p>缺点：<br>1 、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！<br>2 、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</p><h3 id="哨兵模式的配置"><a href="#哨兵模式的配置" class="headerlink" title="哨兵模式的配置"></a>哨兵模式的配置</h3><pre><code class="hljs bash"><span class="hljs-comment"># Example sentinel.conf</span><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认 26379</span>port 26379<span class="hljs-comment"># 哨兵sentinel的工作目录</span>dir /tmp<span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port</span><span class="hljs-comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span><span class="hljs-comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>sentinel monitor mymaster 127 .0.0.1 6379 2<span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供</span>密码<span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒</span><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel down-after-milliseconds mymaster 30000<span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><span class="hljs-comment"># 这个数字越小，完成failover所需的时间就越长，</span><span class="hljs-comment"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><span class="hljs-comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>sentinel parallel-syncs mymaster 1<span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。</span><span class="hljs-comment">#   直到slave被纠正为向正确的master那里同步数据时。</span><span class="hljs-comment">#3. 当想要取消一个正在进行的failover所需要的时间。</span><span class="hljs-comment">#4. 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，</span><span class="hljs-comment">#   slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><span class="hljs-comment"># 默认三分钟</span><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></code></pre><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis发布订阅</title>
    <link href="/cxlittlecute/7f3ad76a.html"/>
    <url>/cxlittlecute/7f3ad76a.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统！</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>订阅/发布消息图：</p><p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823101054.png" srcset="/img/loading.gif" alt=""></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823101305.png" srcset="/img/loading.gif" alt=""></p><p>image.png<br>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823101338.png" srcset="/img/loading.gif" alt=""></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823101433.png" srcset="/img/loading.gif" alt=""></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>订阅端：</p><pre><code class="hljs bash">127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo  <span class="hljs-comment"># 订阅一个频道 kuangshenshuo</span>Reading messages... (press Ctrl-C to quit)1 ) <span class="hljs-string">"subscribe"</span>2 ) <span class="hljs-string">"kuangshenshuo"</span>3 ) (<span class="hljs-built_in">integer</span>) 1<span class="hljs-comment"># 等待读取推送的信息</span>1 ) <span class="hljs-string">"message"</span> <span class="hljs-comment"># 消息</span>2 ) <span class="hljs-string">"kuangshenshuo"</span> <span class="hljs-comment"># 那个频道的消息</span>3 ) <span class="hljs-string">"hello,kuangshen"</span> <span class="hljs-comment"># 消息的具体内容</span>1 ) <span class="hljs-string">"message"</span>2 ) <span class="hljs-string">"kuangshenshuo"</span>3 ) <span class="hljs-string">"hello,redis"</span></code></pre><p>发送端：</p><pre><code class="hljs bash">127.0.0.1:6379&gt; PUBLISH kuangshenshuo <span class="hljs-string">"hello,kuangshen"</span> <span class="hljs-comment"># 发布者发布消息到频道！</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; PUBLISH kuangshenshuo <span class="hljs-string">"hello,redis"</span> <span class="hljs-comment"># 发布者发布消息到频道！</span>(<span class="hljs-built_in">integer</span>) 1</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，及加深对 Redis 的理解。</p><p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p><p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823103004.png" srcset="/img/loading.gif" alt=""></p><p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p><p>使用场景：<br>1 、实时消息系统！<br>2 、事实聊天！（频道当做聊天室，将信息回显给所有人即可！）即发布者也是订阅者<br>3 、订阅，关注系统都是可以的！</p><p>稍微复杂的场景我们就会使用 消息中间件 MQ</p><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化</title>
    <link href="/cxlittlecute/119ed1dc.html"/>
    <url>/cxlittlecute/119ed1dc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>面试和工作，持久化都是重点！</p><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能.</p><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822222137.png" srcset="/img/loading.gif" alt=""></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><p>我们默认的就是RDB，一般情况下不需要修改这个配置！</p><p>==rdb保存的文件是dump.rdb== </p><p>有时候在生产环境我们会将这个文件进行备份！</p><p>都是在我们的配置文件中快照中进行配置的！</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822222624.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822222826.png" srcset="/img/loading.gif" alt=""></p><h3 id="RDB触发机制"><a href="#RDB触发机制" class="headerlink" title="RDB触发机制"></a>RDB触发机制</h3><p>1 、save的规则满足的情况下，会自动触发rdb规则</p><p>2 、执行 flushall 命令，也会触发我们的rdb规则！</p><p>3 、退出redis，也会产生 rdb 文件！</p><p>4、 kill不会生成rdb文件！<br>备份就自动生成一个 dump.rdb</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822223527.png" srcset="/img/loading.gif" alt=""></p><h3 id="恢复RDB文件"><a href="#恢复RDB文件" class="headerlink" title="恢复RDB文件"></a>恢复RDB文件</h3><p>1 、只需要将rdb文件放在我们redis配置文件设置的目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</p><p>2 、查看需要存在的位置</p><pre><code class="hljs bash">127.0.0.1:6379&gt; config get dir1 ) <span class="hljs-string">"dir"</span>2 ) <span class="hljs-string">"/usr/local/bin"</span> <span class="hljs-comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></code></pre><p>我们通常使用它默认的设置就可以了。</p><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p>优点：<br>1 、适合大规模的数据恢复！<br>2 、对数据的完整性要不高！<br>缺点：<br>1 、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！<br>2 、fork进程的时候，会占用一定的内存空间！！</p><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823091651.png" srcset="/img/loading.gif" alt=""></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>==Aof保存的是appendonly.aof文件==</p><h3 id="APPEND-ONLY-MODE"><a href="#APPEND-ONLY-MODE" class="headerlink" title="APPEND ONLY MODE"></a>APPEND ONLY MODE</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823092043.png" srcset="/img/loading.gif" alt=""></p><p>默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！</p><p>重启，redis 就可以生效了！</p><p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件.</p><p>redis 给我们提供了一个工具 <code>redis-check-aof --fix</code></p><p>成功修复：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823092632.png" srcset="/img/loading.gif" alt=""></p><p>如果文件正常，重启就可以直接恢复了！</p><h3 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h3><p>aof 默认就是文件的无限追加，<code>文件会越来越大</code>！</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200823093316.png" srcset="/img/loading.gif" alt=""></p><p>如果 aof 文件大于64m，太大了！ fork一个新的进程来将我们的文件进行重写(增加一个aof文件)！</p><h3 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><pre><code class="hljs bash">appendonly no  <span class="hljs-comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span>appendfilename <span class="hljs-string">"appendonly.aof"</span> <span class="hljs-comment"># 持久化的文件的名字</span><span class="hljs-comment"># appendfsync always # 每次修改都会 sync。消耗性能</span>appendfsync everysec <span class="hljs-comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span><span class="hljs-comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></code></pre><p>优点和缺点！<br>优点：<br>1 、每一次修改都同步，文件的完整会更加好！<br>2 、每秒同步一次，可能会丢失一秒的数据(默认)<br>3 、从不同步，效率最高的！<br>缺点：<br>1 、相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！<br>2 、Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1 、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储<br>2 、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始<br>的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重<br>写，使得AOF文件的体积不至于过大。</p><p>3 、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</p><p>4 、同时开启两种持久化方式</p><ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者<br>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有<br>AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul><p>5 、性能建议</p><ul><li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要 15 分钟备份一次就够了，只保留 save 900 1 这条规则。</p></li><li><p>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</p></li><li><p>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构</p><p>  参见：B站遇见狂神说</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis.conf</title>
    <link href="/cxlittlecute/c4e0e521.html"/>
    <url>/cxlittlecute/c4e0e521.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h1><p>Redis启动的时候，就通过配置文件来启动！</p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822212734.png" srcset="/img/loading.gif" alt=""></p><p>1 、配置文件 units 单位 对大小写不敏感！</p><h2 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822212758.png" srcset="/img/loading.gif" alt=""></p><p>就是好比我们学习Spring中的Improt以及JSP中的include标签</p><h2 id="MODULES-模块"><a href="#MODULES-模块" class="headerlink" title="MODULES 模块"></a>MODULES 模块</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822213150.png" srcset="/img/loading.gif" alt=""></p><p>加载一些SO文件</p><h2 id="NETWORK-网络"><a href="#NETWORK-网络" class="headerlink" title="NETWORK 网络"></a>NETWORK 网络</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822213347.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1 <span class="hljs-comment"># 绑定的IP</span>protected-mode no <span class="hljs-comment"># 保护模式</span>port 6379 <span class="hljs-comment"># 端口设置</span></code></pre><h2 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822213623.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs bash">daemonize yes <span class="hljs-comment"># 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span>pidfile /var/run/redis_6379.pid  <span class="hljs-comment"># 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span><span class="hljs-comment"># 日志</span><span class="hljs-comment"># Specify the server verbosity level.</span><span class="hljs-comment"># This can be one of:</span><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)生产环境</span><span class="hljs-comment"># warning (only very important / critical messages are logged)</span>loglevel noticelogfile <span class="hljs-string">"/www/server/redis/redis.log"</span> <span class="hljs-comment"># 日志文件位置</span>databases 16 <span class="hljs-comment"># 默认16个数据库</span>always-show-logo yes <span class="hljs-comment"># 是否总是显示LOGO</span></code></pre><h2 id="SNAPSHOTTING-快照"><a href="#SNAPSHOTTING-快照" class="headerlink" title="SNAPSHOTTING 快照"></a>SNAPSHOTTING 快照</h2><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件。文件分为.rdb. aof</p><p>redis 是内存数据库，如果没有持久化，那么数据断电及失！</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822214039.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs bash"><span class="hljs-comment"># 持久化规则：</span><span class="hljs-comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span>save 900 1<span class="hljs-comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span>save 300 10<span class="hljs-comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span>save 60 10000<span class="hljs-comment"># 我们之后学习持久化，会自己定义这个测试！</span>stop-writes-on-bgsave-error yes <span class="hljs-comment"># 持久化如果出错，是否还需要继续工作！</span>rdbcompression yes <span class="hljs-comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span>rdbchecksum yes <span class="hljs-comment"># 保存rdb文件的时候，进行错误的检查校验！</span>dir ./  <span class="hljs-comment"># rdb 文件保存的目录！</span></code></pre><h2 id="REPLICATION"><a href="#REPLICATION" class="headerlink" title="REPLICATION"></a>REPLICATION</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822214650.png" srcset="/img/loading.gif" alt=""></p><h2 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822214815.png" srcset="/img/loading.gif" alt=""></p><p>可以在这里设置redis的密码，默认是没有密码的！</p><pre><code class="hljs bash">127.0.0.1:6379&gt; config get requirepass <span class="hljs-comment"># 获取redis的密码</span>1 ) <span class="hljs-string">"requirepass"</span>2 ) <span class="hljs-string">""</span>127.0.0.1:6379&gt; config <span class="hljs-built_in">set</span> requirepass <span class="hljs-string">"123456"</span> <span class="hljs-comment"># 设置redis的密码</span>OK127.0.0.1:6379&gt; config get requirepass <span class="hljs-comment"># 发现所有的命令都没有权限了</span>(error) NOAUTH Authentication required.127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456 <span class="hljs-comment"># 使用密码进行登录！</span>OK127.0.0.1:6379&gt; config get requirepass1 ) <span class="hljs-string">"requirepass"</span>2 ) <span class="hljs-string">"123456"</span></code></pre><h2 id="限制Clients"><a href="#限制Clients" class="headerlink" title="限制Clients"></a>限制Clients</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822215129.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs bash">maxclients 10000 <span class="hljs-comment"># 设置能连接上redis的最大客户端的数量</span></code></pre><h2 id="MEMORY-MANAGEMENT"><a href="#MEMORY-MANAGEMENT" class="headerlink" title="MEMORY MANAGEMENT"></a>MEMORY MANAGEMENT</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822215350.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs bash">maxmemory &lt;bytes&gt;  <span class="hljs-comment"># redis 配置最大的内存容量</span>maxmemory-policy noeviction  <span class="hljs-comment"># 内存到达上限之后的处理策略</span>    1 、volatile-lru：只对设置了过期时间的key进行LRU（默认值）    2 、allkeys-lru ： 删除lru算法的key    3 、volatile-random：随机删除即将过期key    4 、allkeys-random：随机删除    5 、volatile-ttl ： 删除即将过期的    6 、noeviction ： 永不过期，返回错误</code></pre><h2 id="APPEND-ONLY-MODE-AOF"><a href="#APPEND-ONLY-MODE-AOF" class="headerlink" title="APPEND ONLY MODE AOF"></a>APPEND ONLY MODE AOF</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822215803.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs bash">appendonly no  <span class="hljs-comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span>appendfilename <span class="hljs-string">"appendonly.aof"</span> <span class="hljs-comment"># 持久化的文件的名字</span><span class="hljs-comment"># appendfsync always # 每次修改都会 sync。消耗性能</span>appendfsync everysec <span class="hljs-comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span><span class="hljs-comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="/cxlittlecute/4ebad2d4.html"/>
    <url>/cxlittlecute/4ebad2d4.html</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p><p>SpringData 也是和 SpringBoot 齐名的项目！</p><h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p><p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接池！ 更像 BIO 模式</p><p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了，更像 NIO 模式</p><p>需要注意的是由于版本底层的变化，我们通过源码可以发现jedis中很多的类已经不存在了，所以有时我们在配置文件中配置jedis池等配置时是不生效的，我们应该使用lettuce去配置一些池的信息。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(    name = &#123;<span class="hljs-string">"redisTemplate"</span>&#125;)<span class="hljs-comment">// 不存在这个Bean才生效，我们可以自己定义一个redisTemplate来替换这个默认的！</span><span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;    <span class="hljs-comment">// 默认的RedisTemplate 没有过多的设置，redis对象都是需要序列化的！</span>    <span class="hljs-comment">// 两个泛型都是 Object，Object 的类型，我们后面使用需要强制转换&lt;String,Object&gt;</span>    RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span> <span class="hljs-comment">// 由于我们的String类型常用，所以我们单独提出来了一个bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;    StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    <span class="hljs-keyword">return</span> template;&#125;</code></pre><h2 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h2><p>1 、导入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2 、配置连接</p><pre><code class="hljs properties"><span class="hljs-comment"># 配置redis</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-meta">spring.redis.port</span>= <span class="hljs-string">6379</span></code></pre><p>3 、测试</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootredisApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span>        <span class="hljs-comment">// opsForValue 操作字符串 类似String</span>        <span class="hljs-comment">// opsForList 操作List 类似List</span>        <span class="hljs-comment">// opsForSet</span>        <span class="hljs-comment">// opsForHash</span>        <span class="hljs-comment">// opsForZSet</span>        <span class="hljs-comment">// opsForGeo</span>        <span class="hljs-comment">// opsForHyperLogLog</span>        <span class="hljs-comment">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</span>        <span class="hljs-comment">// 获取redis的连接对象</span>        <span class="hljs-comment">// RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span>        <span class="hljs-comment">// connection.flushDb();</span>        <span class="hljs-comment">// connection.flushAll();</span>        redisTemplate.opsForValue().set(<span class="hljs-string">"mykey"</span>,<span class="hljs-string">"oy"</span>);        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">"oy"</span>));    &#125;&#125;</code></pre><p>这里我们需要注意的是如果我们的值，保存的是中文，那么redis中的中文数据就会出现乱码。为什么？我们可以根据源码来看一下：</p><p>对值的序列化<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822120635.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822120722.png" srcset="/img/loading.gif" alt=""></p><p>我们可以看到底层默认的序列化方式是Jdk序列化，那么它就会使我们的字符串转义。我们就可能会使用Json来序列化。我们知道只要我们自定义redisTemplate，框架带有的就会失效。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822193739.png" srcset="/img/loading.gif" alt=""></p><h2 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h2><p>为了解决上面的这个问题我们可以自己自定义一个RedisTemplate。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-comment">// 自定义redisTemplate</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span></span>&#123;        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate();        template.setConnectionFactory(factory);        <span class="hljs-comment">// Json 序列化配置</span>        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        <span class="hljs-comment">// String 的序列化</span>        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();        <span class="hljs-comment">// key采用String的序列化方式</span>        template.setKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// hash的key也采用String的序列化方式</span>        template.setHashKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// value序列化方式采用jackson</span>        template.setValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        <span class="hljs-comment">// hash的value序列化方式采用jackson</span>        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre><h2 id="RedisUtil"><a href="#RedisUtil" class="headerlink" title="RedisUtil"></a>RedisUtil</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ccctop.utils;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> RedisUtil</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/22 20:15</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisUtil</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;    <span class="hljs-comment">// =============================common============================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 26</span><span class="hljs-comment">     * 指定缓存失效时间</span><span class="hljs-comment">     * 27</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><span class="hljs-comment">     *             28</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><span class="hljs-comment">     *             29</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 30</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">expire</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 44</span><span class="hljs-comment">     * 根据key 获取过期时间</span><span class="hljs-comment">     * 45</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键 不能为null</span><span class="hljs-comment">     *            46</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 时间(秒) 返回0代表为永久有效</span><span class="hljs-comment">     * 47</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 53</span><span class="hljs-comment">     * 判断key是否存在</span><span class="hljs-comment">     * 54</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            55</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><span class="hljs-comment">     * 56</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasKey</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.hasKey(key);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 67</span><span class="hljs-comment">     * 删除缓存</span><span class="hljs-comment">     * 68</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 可以传一个值 或多个</span><span class="hljs-comment">     *            69</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(String... key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span> &amp;&amp; key.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (key.length == <span class="hljs-number">1</span>) &#123;                redisTemplate.delete(key[<span class="hljs-number">0</span>]);            &#125; <span class="hljs-keyword">else</span> &#123;                redisTemplate.delete(CollectionUtils.arrayToList(key));            &#125;        &#125;    &#125;    <span class="hljs-comment">// ============================String=============================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 83</span><span class="hljs-comment">     * 普通缓存获取</span><span class="hljs-comment">     * 84</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            85</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 值</span><span class="hljs-comment">     * 86</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> key == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : redisTemplate.opsForValue().get(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 92</span><span class="hljs-comment">     * 普通缓存放入</span><span class="hljs-comment">     * 93</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              94</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              95</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><span class="hljs-comment">     * 96</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForValue().set(key, value);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 109</span><span class="hljs-comment">     * 普通缓存放入并设置时间</span><span class="hljs-comment">     * 110</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              111</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              112</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span><span class="hljs-comment">     *              113</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false 失败</span><span class="hljs-comment">     * 114</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; <span class="hljs-keyword">else</span> &#123;                set(key, value);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 130</span><span class="hljs-comment">     * 递增</span><span class="hljs-comment">     * 131</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              132</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要增加几(大于0)</span><span class="hljs-comment">     *              133</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 134</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">incr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"递增因子必须大于0"</span>);        &#125;        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, delta);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 143</span><span class="hljs-comment">     * 递减</span><span class="hljs-comment">     * 144</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              145</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 要减少几(小于0)</span><span class="hljs-comment">     *              146</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 147</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">decr</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> delta)</span> </span>&#123;        <span class="hljs-keyword">if</span> (delta &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"递减因子必须大于0"</span>);        &#125;        <span class="hljs-keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);    &#125;    <span class="hljs-comment">// ================================Map=================================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 157</span><span class="hljs-comment">     * HashGet</span><span class="hljs-comment">     * 158</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><span class="hljs-comment">     *             159</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><span class="hljs-comment">     *             160</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 值</span><span class="hljs-comment">     * 161</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">hget</span><span class="hljs-params">(String key, String item)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().get(key, item);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 167</span><span class="hljs-comment">     * 获取hashKey对应的所有键值</span><span class="hljs-comment">     * 168</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            169</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 对应的多个键值</span><span class="hljs-comment">     * 170</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Object, Object&gt; <span class="hljs-title">hmget</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().entries(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 176</span><span class="hljs-comment">     * HashSet</span><span class="hljs-comment">     * 177</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            178</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 对应多个键值</span><span class="hljs-comment">     *            179</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false 失败</span><span class="hljs-comment">     * 180</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForHash().putAll(key, map);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 192</span><span class="hljs-comment">     * HashSet 并设置时间</span><span class="hljs-comment">     * 193</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><span class="hljs-comment">     *             194</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map  对应多个键值</span><span class="hljs-comment">     *             195</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 时间(秒)</span><span class="hljs-comment">     *             196</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true成功 false失败</span><span class="hljs-comment">     * 197</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hmset</span><span class="hljs-params">(String key, Map&lt;String, Object&gt; map, <span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForHash().putAll(key, map);            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;                expire(key, time);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 212</span><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><span class="hljs-comment">     * 213</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              214</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><span class="hljs-comment">     *              215</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              216</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><span class="hljs-comment">     * 217</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForHash().put(key, item, value);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 229</span><span class="hljs-comment">     * 向一张hash表中放入数据,如果不存在将创建</span><span class="hljs-comment">     * 230</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              231</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item  项</span><span class="hljs-comment">     *              232</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              233</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span><span class="hljs-comment">     *              234</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 成功 false失败</span><span class="hljs-comment">     * 235</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hset</span><span class="hljs-params">(String key, String item, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForHash().put(key, item, value);            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>) &#123;                expire(key, time);            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 250</span><span class="hljs-comment">     * 删除hash表中的值</span><span class="hljs-comment">     * 251</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><span class="hljs-comment">     *             252</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 可以使多个 不能为null</span><span class="hljs-comment">     *             253</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hdel</span><span class="hljs-params">(String key, Object... item)</span> </span>&#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 259</span><span class="hljs-comment">     * 判断hash表中是否有该项的值</span><span class="hljs-comment">     * 260</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键 不能为null</span><span class="hljs-comment">     *             261</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项 不能为null</span><span class="hljs-comment">     *             262</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><span class="hljs-comment">     * 263</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hHasKey</span><span class="hljs-params">(String key, String item)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 269</span><span class="hljs-comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span><span class="hljs-comment">     * 270</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><span class="hljs-comment">     *             271</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><span class="hljs-comment">     *             272</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要增加几(大于0)</span><span class="hljs-comment">     *             273</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 274</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hincr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 280</span><span class="hljs-comment">     * hash递减</span><span class="hljs-comment">     * 281</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  键</span><span class="hljs-comment">     *             282</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item 项</span><span class="hljs-comment">     *             283</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> by   要减少记(小于0)</span><span class="hljs-comment">     *             284</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 285</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">hdecr</span><span class="hljs-params">(String key, String item, <span class="hljs-keyword">double</span> by)</span> </span>&#123;        <span class="hljs-keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);    &#125;    <span class="hljs-comment">// ============================set=============================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 292</span><span class="hljs-comment">     * 根据key获取Set中的所有值</span><span class="hljs-comment">     * 293</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            294</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 295</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">sGet</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().members(key);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 306</span><span class="hljs-comment">     * 根据value从一个set中查询,是否存在</span><span class="hljs-comment">     * 307</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              308</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              309</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true 存在 false不存在</span><span class="hljs-comment">     * 310</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sHasKey</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().isMember(key, value);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 321</span><span class="hljs-comment">     * 将数据放入set缓存</span><span class="hljs-comment">     * 322</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><span class="hljs-comment">     *               323</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><span class="hljs-comment">     *               324</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><span class="hljs-comment">     * 325</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSet</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().add(key, values);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 336</span><span class="hljs-comment">     * 将set数据放入缓存</span><span class="hljs-comment">     * 337</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><span class="hljs-comment">     *               338</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time   时间(秒)</span><span class="hljs-comment">     *               339</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><span class="hljs-comment">     *               340</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功个数</span><span class="hljs-comment">     * 341</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sSetAndTime</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> time, Object... values)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Long count = redisTemplate.opsForSet().add(key, values);            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)                expire(key, time);            <span class="hljs-keyword">return</span> count;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 355</span><span class="hljs-comment">     * 获取set缓存的长度</span><span class="hljs-comment">     * 356</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            357</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 358</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sGetSetSize</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForSet().size(key);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 369</span><span class="hljs-comment">     * 移除值为value的</span><span class="hljs-comment">     * 370</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    键</span><span class="hljs-comment">     *               371</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values 值 可以是多个</span><span class="hljs-comment">     *               372</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><span class="hljs-comment">     * 373</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">setRemove</span><span class="hljs-params">(String key, Object... values)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Long count = redisTemplate.opsForSet().remove(key, values);            <span class="hljs-keyword">return</span> count;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">// ===============================list=================================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 386</span><span class="hljs-comment">     * 获取list缓存的内容</span><span class="hljs-comment">     * 387</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              388</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start 开始</span><span class="hljs-comment">     *              389</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end   结束 0 到 -1代表所有值</span><span class="hljs-comment">     *              390</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 391</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">lGet</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForList().range(key, start, end);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 402</span><span class="hljs-comment">     * 获取list缓存的长度</span><span class="hljs-comment">     * 403</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     *            404</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 405</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lGetListSize</span><span class="hljs-params">(String key)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForList().size(key);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 416</span><span class="hljs-comment">     * 通过索引 获取list中的值</span><span class="hljs-comment">     * 417</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              418</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span><span class="hljs-comment">     *              419</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 420</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">lGetIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> redisTemplate.opsForList().index(key, index);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 431</span><span class="hljs-comment">     * 将list放入缓存</span><span class="hljs-comment">     * 432</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              433</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              434</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 436</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForList().rightPush(key, value);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将list放入缓存</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, Object value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForList().rightPush(key, value);            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)                expire(key, time);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 467</span><span class="hljs-comment">     * 将list放入缓存</span><span class="hljs-comment">     * 468</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              469</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 472</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForList().rightPushAll(key, value);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 484</span><span class="hljs-comment">     * 将list放入缓存</span><span class="hljs-comment">     * 485</span><span class="hljs-comment">     * &lt;p&gt;</span><span class="hljs-comment">     * 486</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              487</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              488</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  时间(秒)</span><span class="hljs-comment">     *              489</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 490</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lSet</span><span class="hljs-params">(String key, List&lt;Object&gt; value, <span class="hljs-keyword">long</span> time)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForList().rightPushAll(key, value);            <span class="hljs-keyword">if</span> (time &gt; <span class="hljs-number">0</span>)                expire(key, time);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 504</span><span class="hljs-comment">     * 根据索引修改list中的某条数据</span><span class="hljs-comment">     * 505</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              506</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 索引</span><span class="hljs-comment">     *              507</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              508</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 509</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lUpdateIndex</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> index, Object value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            redisTemplate.opsForList().set(key, index, value);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 521</span><span class="hljs-comment">     * 移除N个值为value</span><span class="hljs-comment">     * 522</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   键</span><span class="hljs-comment">     *              523</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> count 移除多少个</span><span class="hljs-comment">     *              524</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 值</span><span class="hljs-comment">     *              525</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 移除的个数</span><span class="hljs-comment">     * 526</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">lRemove</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> count, Object value)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            Long remove = redisTemplate.opsForList().remove(key, count, value);            <span class="hljs-keyword">return</span> remove;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jedis</title>
    <link href="/cxlittlecute/ea742350.html"/>
    <url>/cxlittlecute/ea742350.html</url>
    
    <content type="html"><![CDATA[<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用 Java 来操作 Redis</p><h2 id="什么是Jedis"><a href="#什么是Jedis" class="headerlink" title="什么是Jedis"></a>什么是Jedis</h2><p>是Redis官方推荐的java连接开发工具！使用Java操作Redis 中间件如果你要使用java操作redis，那么一定要对Jedis 十分的熟悉！</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>1 、导入对应的依赖</p><pre><code class="hljs java">&lt;!--导入jedis的包--&gt;&lt;dependencies&gt;    &lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;</span>    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;3.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--fastjson--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.62&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>2、编码测试</p><ul><li>连接数据库</li><li>操作命令</li><li>断开连接</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPing</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 1、 new Jedis 对象即可</span>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6379</span> );        <span class="hljs-comment">// jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！</span>        System.out.println(jedis.ping());    &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200822104419.png" srcset="/img/loading.gif" alt=""></p><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><p>所有的api命令，对应<a href="http://ccctop.cn/cxlittlecute/3dc4f105.html" target="_blank" rel="noopener">五大数据类型</a>和<a href="http://ccctop.cn/cxlittlecute/401a612a.html" target="_blank" rel="noopener">三大特殊数据类型</a></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6379</span>);        jedis.flushDB();        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();        jsonObject.put(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>);        jsonObject.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"kuangshen"</span>);        <span class="hljs-comment">// 开启事务</span>        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        <span class="hljs-keyword">try</span> &#123;            multi.set(<span class="hljs-string">"user1"</span>, result);            multi.set(<span class="hljs-string">"user2"</span>, result);            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 代码抛出异常事务，执行失败！</span>            multi.exec(); <span class="hljs-comment">// 执行事务！</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            multi.discard(); <span class="hljs-comment">// 放弃事务</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(jedis.get(<span class="hljs-string">"user1"</span>));            System.out.println(jedis.get(<span class="hljs-string">"user2"</span>));            jedis.close(); <span class="hljs-comment">// 关闭连接</span>        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/cxlittlecute/4d5e325c.html"/>
    <url>/cxlittlecute/4d5e325c.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！</p><p>一次性、顺序性、排他性（不允许被别人干扰）！执行一系列的命令！</p><pre><code class="hljs shell">-------- 队列 set set set 执行------------</code></pre><p><strong>Redis事务没有没有隔离级别的概念！</strong></p><p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec</p><p><strong>Redis单条命令式保存原子性的，但是事务不保证原子性！</strong></p><p>redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（……）</li><li>执行事务（exec）</li></ul><h2 id="正常执行事务"><a href="#正常执行事务" class="headerlink" title="正常执行事务"></a>正常执行事务</h2><pre><code class="hljs shell">127.0.0.1:6379&gt; multi  # 开启事务OK<span class="hljs-meta">#</span><span class="bash"> 命令入队</span>127.0.0.1:6379&gt; set k1 v1127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; exec # 执行事务1 ) OK2 ) OK3 ) "v2"4 ) OK</code></pre><h2 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h2><pre><code class="hljs shell">127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; DISCARD # 取消事务OK127.0.0.1:6379&gt; get k4 # 事务队列中命令都不会被执行！(nil)</code></pre><h2 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h2><p>有两种错误：</p><ul><li>编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！<pre><code class="hljs shell">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v5QUEUED127.0.0.1:6379&gt; exec # 执行事务报错！(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行！(nil)</code></pre></li><li>运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！</li></ul><pre><code class="hljs shell">127.0.0.1:6379&gt; set k1 "v1"OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1  # 会执行的时候失败！QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec1 ) (error) ERR value is not an integer or out of range  # 虽然第一条命令报错了，但是依旧正常执行成功了！2 ) OK3 ) OK4 ) "v3"127.0.0.1:6379&gt; get k2"v2"127.0.0.1:6379&gt; get k3"v3"</code></pre><h2 id="监控-watch"><a href="#监控-watch" class="headerlink" title="监控(watch)"></a>监控(watch)</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li></ul><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据，</li><li>监视获取version</li><li>更新的时候比较 version</li></ul><h3 id="Redis测监视测试"><a href="#Redis测监视测试" class="headerlink" title="Redis测监视测试"></a>Redis测监视测试</h3><pre><code class="hljs shell">127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money # 监视 money 对象OK127.0.0.1:6379&gt; multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！OK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY out 20QUEUED127.0.0.1:6379&gt; exec1 ) (integer) 802 ) (integer) 20</code></pre><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; watch money # 监视 moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 10QUEUED127.0.0.1:6379&gt; INCRBY out 10QUEUED127.0.0.1:6379&gt; exec  # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！(nil)</code></pre><p>如果修改失败了，先解锁再获取最新的值就好！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; unwatch # 如果发现事务执行失败，就需要先解锁OK127.0.0.1:6379&gt; watch money # 获取最新的值，再次监视，select versionOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; decrby money 1QUEUED127.0.0.1:6379&gt; incrby money 1QUEUED127.0.0.1:6379&gt; exec # 比对监视的值是否发生了变化，如果没有变化，那么可以执行成功，如果变化，就执行失败1) (integer) 992) (integer) 100</code></pre><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis三种特殊数据类型</title>
    <link href="/cxlittlecute/401a612a.html"/>
    <url>/cxlittlecute/401a612a.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis三种特殊数据类型"><a href="#Redis三种特殊数据类型" class="headerlink" title="Redis三种特殊数据类型"></a>Redis三种特殊数据类型</h1><h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h2><p>朋友的定位，附近的人，打车距离计算？</p><p>Redis 的 Geo 在Redis3.2 版本就推出了！ 这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！</p><p><a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">官方文档</a><br><a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener">操作文档</a></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200821170958.png" srcset="/img/loading.gif" alt=""></p><pre><code>geoadd</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> getadd 添加地理位置</span><span class="hljs-meta">#</span><span class="bash"> 规则：两级(南极北极)无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span><span class="hljs-meta">#</span><span class="bash"> 参数 key 值（纬度、经度、名称）</span><span class="hljs-meta">#</span><span class="bash"> 有效的经度从-180度到 180 度。</span><span class="hljs-meta">#</span><span class="bash"> 有效的纬度从-85.05112878度到85.05112878度。</span><span class="hljs-meta">#</span><span class="bash"> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span><span class="hljs-meta">#</span><span class="bash"> 127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijin</span>(error) ERR invalid longitude,latitude pair 39 .900000,116.400000<span class="hljs-meta">#</span><span class="bash"> 参数 key 值（）</span>127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen(integer) 2 127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2</code></pre><pre><code>geopos</code></pre><p>获得当前定位：一定是一个坐标值！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; GEOPOS china:city beijing  # 获取指定的城市的经度和纬度！1 ) 1 ) "116.39999896287918091"2 ) "39.90000009167092543"127.0.0.1:6379&gt; GEOPOS china:city beijing chongqi1 ) 1 ) "116.39999896287918091"2 ) "39.90000009167092543"2 ) 1 ) "106.49999767541885376"2 ) "29.52999957900659211"</code></pre><pre><code>GEODIST</code></pre><p>两人之间的距离！</p><p>单位：</p><ul><li>m 表示单位为米。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li></ul><pre><code class="hljs shell">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km  # 查看上海到北京的直线距离"1067.3788"127.0.0.1:6379&gt; GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离"1464.0708"</code></pre><pre><code>georadius 以给定的经纬度为中心， 找出某一半径内的元素</code></pre><p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！获得指定数量的人，200.</p><p>所有数据应该都录入：china:city ，才会让结果更加请求！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km  # 以 110 ， 30 这个经纬度为中心，寻找方圆1000km内的城市1 ) "chongqi"2 ) "xian"3 ) "shengzhen"4 ) "hangzhou"127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km1 ) "chongqi"2 ) "xian"127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist  # 显示到中心距离的位置1 ) 1 ) "chongqi"2 ) "341.9374"2 ) 1 ) "xian"2 ) "483.8340"127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord  # 显示他人的定位信息（经度纬度）1 ) 1 ) "chongqi"2 ) 1 ) "106.49999767541885376" 2 ) "29.52999957900659211"2 ) 1 ) "xian"2 ) 1 ) "108.96000176668167114" 2 ) "34.25999964418929977"127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 1 #筛选出指定的结果！1 ) 1 ) "chongqi"2 ) "341.9374"3 ) 1 ) "106.49999767541885376" 2 ) "29.52999957900659211"127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 21 ) 1 ) "chongqi"2 ) "341.9374"3 ) 1 ) "106.49999767541885376" 2 ) "29.52999957900659211"2 ) 1 ) "xian"2 ) "483.8340"3 ) 1 ) "108.96000176668167114" 2 ) "34.25999964418929977"</code></pre><pre><code>GEORADIUSBYMEMBER</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 找出位于指定元素周围的其他元素！</span>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km1 ) "beijing"2 ) "xian"127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shanghai 400 km1 ) "hangzhou"2 ) "shanghai"</code></pre><pre><code>GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示</code></pre><p>该命令将返回 11 个字符的Geohash字符串!</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span>127.0.0.1:6379&gt; geohash china:city beijing chongqi1 ) "wx4fbxxfke0"2 ) "wm5xzrybty0"</code></pre><pre><code>GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！</code></pre><pre><code class="hljs shell">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # 查看地图中全部的元素1 ) "chongqi"2 ) "xian"3 ) "shengzhen"4 ) "hangzhou"5 ) "shanghai"6 ) "beijing"127.0.0.1:6379&gt; zrem china:city beijing  # 移除指定元素！(integer) 1127.0.0.1:6379&gt; ZRANGE china:city 0 -11 ) "chongqi"2 ) "xian"3 ) "shengzhen"4 ) "hangzhou"5 ) "shanghai"</code></pre><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><pre><code>什么是基数？</code></pre><p>A {1,3,5,7,8,7} B {1,3,5,7,8}</p><p>基数（不重复的元素） = 5，可以接受误差！</p><pre><code>简介</code></pre><p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p><p>Redis Hyperloglog 基数统计的算法！</p><p>优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的话 Hyperloglog 首选！</p><p><strong>网页的 UV （一个人访问一个网站多次，但是还是算作一个人！）</strong><br>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断!</p><p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p><p>Hyperloglog有0.81% 错误率！ 统计UV任务，可以忽略不计的！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey  # 统计 mykey 元素的基数数量(integer) 10127.0.0.1:6379&gt; PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey2(integer) 9127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2  # 合并两组 mykey mykey2 =&gt; mykey3 并集OK127.0.0.1:6379&gt; PFCOUNT mykey3  # 看并集的数量！(integer) 15</code></pre><p>如果允许容错，那么一定可以使用 Hyperloglog ！</p><p>如果不允许容错，就使用 set 或者自己的数据类型即可！</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><pre><code>位存储</code></pre><p>统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡， 365 天打卡！ 两个状态的，都可以使用Bitmap！</p><p>Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有 0 和 1 两个状态！</p><p>365 天 = 365 bit 1字节 = 8bit 46个字节左右！</p><pre><code>测试</code></pre><p>使用bitmap 来记录 周一到周日的打卡！</p><p>周一： 1 周二： 0 周三： 0 周四：1 ……</p><pre><code class="hljs shell">127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0</code></pre><p>查看某一天是否有打卡！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; getbit sign 0(integer) 1127.0.0.1:6379&gt; getbit sign 1(integer) 0</code></pre><p>统计操作，统计打卡的天数！</p><pre><code class="hljs shell">127.0.0.1:6379&gt; bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤!(integer) 1</code></pre><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis五大数据类型</title>
    <link href="/cxlittlecute/3dc4f105.html"/>
    <url>/cxlittlecute/3dc4f105.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h1><p>官方文档描述：</p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作【数据库】、【缓存】和【消息中间件】。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><p><a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">官网Redis命名查询</a></p><h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><pre><code>keys *  # 查看所有的keyEXISTS name  # 判断当前的key是否存在move name 1 # 移除当前库中的keyEXPIRE name 10 # 设置key的过期时间，单位是秒type name  # 查看当前key的一个类型</code></pre><pre><code class="hljs shell">127.0.0.1:6379&gt; keys *  # 查看所有的key(empty list or set)127.0.0.1:6379&gt; set name kuangshen  # set keyOK127.0.0.1:6379&gt; keys *1 ) "name"127.0.0.1:6379&gt; set age 1OK127.0.0.1:6379&gt; keys *1 ) "age"2 ) "name"127.0.0.1:6379&gt; EXISTS name  # 判断当前的key是否存在(integer) 1127.0.0.1:6379&gt; EXISTS name(integer) 0127.0.0.1:6379&gt; move name 1 # 移除当前库中的key(integer) 1127.0.0.1:6379&gt; keys *1 ) "age"127.0.0.1:6379&gt; set name qinjiangOK127.0.0.1:6379&gt; keys *1 ) "age"2 ) "name"127.0.0.1:6379&gt; clear127.0.0.1:6379&gt; keys *1 ) "age"2 ) "name"127.0.0.1:6379&gt; get name"qinjiang"127.0.0.1:6379&gt; EXPIRE name 10 # 设置key的过期时间，单位是秒(integer) 1127.0.0.1:6379&gt; ttl name  # 查看当前key的剩余时间(integer) 4127.0.0.1:6379&gt; ttl name(integer) 3127.0.0.1:6379&gt; ttl name(integer) 2127.0.0.1:6379&gt; ttl name(integer) 1127.0.0.1:6379&gt; ttl name(integer) -127.0.0.1:6379&gt; get name(nil)127.0.0.1:6379&gt; type name  # 查看当前key的一个类型！string127.0.0.1:6379&gt; type agestring</code></pre><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><pre><code>##########################################################################set key1 v1  # 设置值keys * # 获得所有的keyEXISTS key1  # 判断某一个key是否存在APPEND key1 &quot;hello&quot; # 追加字符串，如果当前key不存在，就相当于setkeySTRLEN key1  # 获取字符串的长度##########################################################################incr views  # 自增 1 浏览量变为 1decr views  # 自减 1 浏览量-1INCRBY views 10 # 可以设置步长，指定增量！DECRBY views 5##########################################################################GETRANGE key1 0 3 # 截取字符串 [0,3]GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的##########################################################################SETRANGE key2 1 xx # 替换指定位置开始的字符串！##########################################################################setex key3 30 &quot;hello&quot; # 设置key3 的值为 hello,30秒后过期setnx mykey &quot;redis&quot; # 如果mykey 不存在，创建mykeysetnx mykey &quot;MongoDB&quot; # 如果mykey存在，创建失败！##########################################################################mset k1 v1 k2 v2 k3 v3 # 同时设置多个值mget k1 k2 k3 # 同时获取多个值对象##########################################################################getset db redis # 如果不存在值，则返回 nilgetset db mongodb  # 如果存在值，获取原来的值，并设置新的值##########################################################################lset 将列表中指定下标的值替换为另外一个值，更新操作linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; set key1 v1  # 设置值OK127.0.0.1:6379&gt; get key1 # 获得值"v1"127.0.0.1:6379&gt; keys * # 获得所有的key1 ) "key1"127.0.0.1:6379&gt; EXISTS key1  # 判断某一个key是否存在(integer) 1127.0.0.1:6379&gt; APPEND key1 "hello" # 追加字符串，如果当前key不存在，就相当于setkey(integer) 7127.0.0.1:6379&gt; get key1"v1hello"127.0.0.1:6379&gt; STRLEN key1  # 获取字符串的长度！(integer) 7127.0.0.1:6379&gt; APPEND key1 ",kaungshen"(integer) 17127.0.0.1:6379&gt; STRLEN key1(integer) 17127.0.0.1:6379&gt; get key1"v1hello,kaungshen"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><span class="hljs-meta">#</span><span class="bash"> i++</span><span class="hljs-meta">#</span><span class="bash"> 步长 i+=</span>127.0.0.1:6379&gt; set views 0 # 初始浏览量为 0OK127.0.0.1:6379&gt; get views"0"127.0.0.1:6379&gt; incr views  # 自增 1 浏览量变为 1(integer) 1127.0.0.1:6379&gt; incr views(integer) 2127.0.0.1:6379&gt; get views"2"127.0.0.1:6379&gt; decr views  # 自减 1 浏览量-1(integer) 1127.0.0.1:6379&gt; decr views(integer) 0127.0.0.1:6379&gt; decr views(integer) -1127.0.0.1:6379&gt; get views"-1"127.0.0.1:6379&gt; INCRBY views 10 # 可以设置步长，指定增量！(integer) 9127.0.0.1:6379&gt; INCRBY views 10(integer) 19127.0.0.1:6379&gt; DECRBY views 5<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; set key1 "hello,kuangshen" # 设置 key1 的值OK127.0.0.1:6379&gt; get key1"hello,kuangshen"127.0.0.1:6379&gt; GETRANGE key1 0 3 # 截取字符串 [0,3]"hell"127.0.0.1:6379&gt; GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的"hello,kuangshen"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>替换！127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2"abcdefg"127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换指定位置开始的字符串！(integer) 7127.0.0.1:6379&gt; get key2"axxdefg"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>setex (set with expire) # 设置过期时间setnx (set if not exist) # 不存在在设置 （在分布式锁中会常常使用！）127.0.0.1:6379&gt; setex key3 30 "hello" # 设置key3 的值为 hello,30秒后过期OK127.0.0.1:6379&gt; ttl key3(integer) 26127.0.0.1:6379&gt; get key3"hello"127.0.0.1:6379&gt; setnx mykey "redis" # 如果mykey 不存在，创建mykey(integer) 1127.0.0.1:6379&gt; keys *1 ) "key2"2 ) "mykey"3 ) "key1"127.0.0.1:6379&gt; ttl key3(integer) -2127.0.0.1:6379&gt; setnx mykey "MongoDB" # 如果mykey存在，创建失败！(integer) 0127.0.0.1:6379&gt; get mykey"redis"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>msetmget127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 # 同时设置多个值OK127.0.0.1:6379&gt; keys *1 ) "k1"2 ) "k2"3 ) "k3"127.0.0.1:6379&gt; mget k1 k2 k3 # 同时获取多个值1 ) "v1"2 ) "v2"3 ) "v3"127.0.0.1:6379&gt; msetnx k1 v1 k4 v4  # msetnx 是一个原子性的操作，要么一起成功，要么一起失败！(integer) 0127.0.0.1:6379&gt; get k4(nil)<span class="hljs-meta">#</span><span class="bash"> 对象</span>set user:1 &#123;name:zhangsan,age:3&#125;  # 设置一个user:1 对象 值为 json字符来保存一个对象！<span class="hljs-meta">#</span><span class="bash"> 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span>127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1 ) "zhangsan"2 ) "2"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>getset # 先get然后在set127.0.0.1:6379&gt; getset db redis # 如果不存在值，则返回 nil(nil)127.0.0.1:6379&gt; get db"redis127.0.0.1:6379&gt; getset db mongodb  # 如果存在值，获取原来的值，并设置新的值"redis"127.0.0.1:6379&gt; get db"mongodb"</code></pre><p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>基本的数据类型，列表.</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200821095407.png" srcset="/img/loading.gif" alt=""></p><p>在redis里面，我们可以把list玩成 ，栈、队列、阻塞队列。</p><p>所有的list命令都是用l开头的，Redis不区分大小命令。</p><pre><code>##########################################################################LPUSH list one  # 将一个值或者多个值，插入到列表头部 （左）LRANGE list 0 -1 # 获取list中值Rpush list righr  # 将一个值或者多个值，插入到列表尾部 （右）##########################################################################Lpop list  # 移除list的第一个元素Rpop list  # 移除list的最后一个元素##########################################################################lindex list 1 # 通过下标获得 list 中的某一个值##########################################################################Llen list # 返回列表的长度##########################################################################lrem list 1 one # 移除list集合中指定个数的value，精确匹配##########################################################################ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素。##########################################################################rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表中！##########################################################################lset 将列表中指定下标的值替换为另外一个值，更新操作##########################################################################linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面##########################################################################</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; LPUSH list one  # 将一个值或者多个值，插入到列表头部 （左）(integer) 1127.0.0.1:6379&gt; LPUSH list two(integer) 2127.0.0.1:6379&gt; LPUSH list three(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -1 # 获取list中值！1 ) "three"2 ) "two"3 ) "one"127.0.0.1:6379&gt; LRANGE list 0 1 # 通过区间获取具体的值！1 ) "three"2 ) "two"127.0.0.1:6379&gt; Rpush list righr  # 将一个值或者多个值，插入到列表尾部 （右）(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11 ) "three"2 ) "two"3 ) "one"4 ) "righr"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>LPOPRPOP127.0.0.1:6379&gt; LRANGE list 0 -11 ) "three"2 ) "two"3 ) "one"4 ) "righr"127.0.0.1:6379&gt; Lpop list  # 移除list的第一个元素"three"127.0.0.1:6379&gt; Rpop list  # 移除list的最后一个元素"righr"127.0.0.1:6379&gt; LRANGE list 0 -11 ) "two"2 ) "one"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>Lindex127.0.0.1:6379&gt; LRANGE list 0 -11 ) "two"2 ) "one"127.0.0.1:6379&gt; lindex list 1 # 通过下标获得 list 中的某一个值"one"127.0.0.1:6379&gt; lindex list 0"two"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>Llen127.0.0.1:6379&gt; Lpush list one(integer) 1127.0.0.1:6379&gt; Lpush list two(integer) 2127.0.0.1:6379&gt; Lpush list three(integer) 3127.0.0.1:6379&gt; Llen list # 返回列表的长度(integer) 3<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>移除指定的值！取关 uidLrem127.0.0.1:6379&gt; LRANGE list 0 -11 ) "three"2 ) "three"3 ) "two"4 ) "one"127.0.0.1:6379&gt; lrem list 1 one # 移除list集合中指定个数的value，精确匹配(integer) 1127.0.0.1:6379&gt; LRANGE list 0 -11 ) "three"2 ) "three"3 ) "two"127.0.0.1:6379&gt; lrem list 1 three(integer) 1127.0.0.1:6379&gt; LRANGE list 0 -11 ) "three"2 ) "two"127.0.0.1:6379&gt; Lpush list three(integer) 3127.0.0.1:6379&gt; lrem list 2 three(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11 ) "two"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>trim 修剪； list 截断127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; Rpush mylist "hello"(integer) 1127.0.0.1:6379&gt; Rpush mylist "hello1"(integer) 2127.0.0.1:6379&gt; Rpush mylist "hello2"(integer) 3127.0.0.1:6379&gt; Rpush mylist "hello3"(integer) 4127.0.0.1:6379&gt; ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素。OK127.0.0.1:6379&gt; LRANGE mylist 0 -11 ) "hello1"2 ) "hello2"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>rpoplpush # 移除列表的最后一个元素，将他移动到新的列表中。127.0.0.1:6379&gt; rpush mylist "hello"(integer) 1127.0.0.1:6379&gt; rpush mylist "hello1"(integer) 2127.0.0.1:6379&gt; rpush mylist "hello2"(integer) 3127.0.0.1:6379&gt; rpoplpush mylist myotherlist # 移除列表的最后一个元素，将他移动到新的列表中！"hello2"127.0.0.1:6379&gt; lrange mylist 0 -1 # 查看原来的列表1 ) "hello"2 ) "hello1"127.0.0.1:6379&gt; lrange myotherlist 0 -1 # 查看目标列表中，确实存在改值！1 ) "hello2"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>lset 将列表中指定下标的值替换为另外一个值，更新操作127.0.0.1:6379&gt; EXISTS list # 判断这个列表是否存在(integer) 0127.0.0.1:6379&gt; lset list 0 item # 如果不存在列表我们去更新就会报错(error) ERR no such key127.0.0.1:6379&gt; lpush list value1(integer) 1127.0.0.1:6379&gt; LRANGE list 0 01 ) "value1"127.0.0.1:6379&gt; lset list 0 item # 如果存在，更新当前下标的值OK127.0.0.1:6379&gt; LRANGE list 0 01 ) "item"127.0.0.1:6379&gt; lset list 1 other # 如果不存在，则会报错(error) ERR index out of range<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>linsert # 将某个具体的value插入到列把你中某个元素的前面或者后面127.0.0.1:6379&gt; Rpush mylist "hello"(integer) 1127.0.0.1:6379&gt; Rpush mylist "world"(integer) 2127.0.0.1:6379&gt; LINSERT mylist before "world" "other"(integer) 3127.0.0.1:6379&gt; LRANGE mylist 0 -11 ) "hello"2 ) "other"3 ) "world"127.0.0.1:6379&gt; LINSERT mylist after world new(integer) 4127.0.0.1:6379&gt; LRANGE mylist 0 -11 ) "hello"2 ) "other"3 ) "world"4 ) "new"</code></pre><pre><code>小结：</code></pre><ul><li>我们可以把它想成一个链表，before Node after,left,right都可以插入值</li><li>如果key不存在，创建新的链表</li><li>如果key存在，新增内容</li><li>如果移除所有的值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高，中间元素，相对来说效率会低一点</li></ul><p>消息排队。消息队列 （Lpush Rpop）， 栈（ Lpush Lpop）。</p><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set中的值是不能重复的。</p><pre><code>##########################################################################sadd myset &quot;hello&quot; # set集合中添加元素SMEMBERS myset # 查看指定set的所有值SISMEMBER myset hello  # 判断某一个值是不是在set集合中##########################################################################scard myset  # 获取set集合中的内容元素个数！##########################################################################srem myset hello  # 移除set集合中的指定元素##########################################################################SRANDMEMBER myset  # 随机抽选出一个元素SRANDMEMBER myset 2 # 随机抽选出指定个数的元素##########################################################################spop myset # 随机删除一些set集合中的元素##########################################################################spop myset # 随机删除一些set集合中的元素##########################################################################smove myset myset2 &quot;kuangshen&quot; # 将一个指定的值，移动到另外一个set集合##########################################################################SDIFF key1 key2 # 差集SINTER key1 key2 # 交集 共同好友就可以这样实现SUNION key1 key2 # 并集##########################################################################</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; sadd myset "hello" # set集合中添加元素(integer) 1127.0.0.1:6379&gt; sadd myset "kuangshen"(integer) 1127.0.0.1:6379&gt; sadd myset "lovekuangshen"(integer) 1127.0.0.1:6379&gt; SMEMBERS myset # 查看指定set的所有值1 ) "hello"2 ) "lovekuangshen"3 ) "kuangshen"127.0.0.1:6379&gt; SISMEMBER myset hello  # 判断某一个值是不是在set集合中！(integer) 1127.0.0.1:6379&gt; SISMEMBER myset world(integer) 0<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; scard myset  # 获取set集合中的内容元素个数！(integer) 4<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>rem127.0.0.1:6379&gt; srem myset hello  # 移除set集合中的指定元素(integer) 1127.0.0.1:6379&gt; scard myset(integer) 3127.0.0.1:6379&gt; SMEMBERS myset1 ) "lovekuangshen2"2 ) "lovekuangshen"3 ) "kuangshen"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>set 无序不重复集合。抽随机。127.0.0.1:6379&gt; SMEMBERS myset1 ) "lovekuangshen2"2 ) "lovekuangshen"3 ) "kuangshen"127.0.0.1:6379&gt; SRANDMEMBER myset  # 随机抽选出一个元素"kuangshen"127.0.0.1:6379&gt; SRANDMEMBER myset"kuangshen"127.0.0.1:6379&gt; SRANDMEMBER myset"kuangshen"127.0.0.1:6379&gt; SRANDMEMBER myset"kuangshen"127.0.0.1:6379&gt; SRANDMEMBER myset 2 # 随机抽选出指定个数的元素1 ) "lovekuangshen"2 ) "lovekuangshen2"127.0.0.1:6379&gt; SRANDMEMBER myset 21 ) "lovekuangshen"2 ) "lovekuangshen2"127.0.0.1:6379&gt; SRANDMEMBER myset # 随机抽选出一个元素"lovekuangshen2"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>随机删除key！127.0.0.1:6379&gt; SMEMBERS myset1 ) "lovekuangshen2"2 ) "lovekuangshen"3 ) "kuangshen"127.0.0.1:6379&gt; spop myset # 随机删除一些set集合中的元素！"lovekuangshen2"127.0.0.1:6379&gt; spop myset"lovekuangshen"127.0.0.1:6379&gt; SMEMBERS myset1 ) "kuangshen"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>将一个指定的值，移动到另外一个set集合。127.0.0.1:6379&gt; sadd myset "hello"(integer) 1127.0.0.1:6379&gt; sadd myset "world"(integer) 1127.0.0.1:6379&gt; sadd myset "kuangshen"(integer) 1127.0.0.1:6379&gt; sadd myset2 "set2"(integer) 1127.0.0.1:6379&gt; smove myset myset2 "kuangshen" # 将一个指定的值，移动到另外一个set集合！(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1 ) "world"2 ) "hello"127.0.0.1:6379&gt; SMEMBERS myset21 ) "kuangshen"2 ) "set2"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>微博，B站，共同关注！(并集)数字集合类：- 差集 SDIFF- 交集 SINTER- 并集 SUNION127.0.0.1:6379&gt; SDIFF key1 key2 # 差集1 ) "b"2 ) "a"127.0.0.1:6379&gt; SINTER key1 key2 # 交集 共同好友就可以这样实现1 ) "c"127.0.0.1:6379&gt; SUNION key1 key2 # 并集1 ) "b"2 ) "c"3 ) "e"4 ) "a"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span></code></pre><p>微博，A用户将所有关注的人放在一个set集合中！将它的粉丝也放在一个集合中！</p><p>共同关注，共同爱好，二度好友，推荐好友！（六度分割理论）</p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Map集合，key-map! 时候这个值是一个map集合！ 本质和String类型没有太大区别，还是一个简单的key-vlaue！</p><pre><code>##########################################################################hset myhash field1 kuangshen  # set一个具体 key-vlauehget myhash field1  # 获取一个字段值hmset myhash field1 hello field2 world # set多个 key-vlauehmget myhash field1 field2 # 获取多个字段值hgetall myhash # 获取全部的数据hdel myhash field1  # 删除hash指定key字段！对应的value值也就消失了##########################################################################hlen myhash  # 获取hash表的字段数量##########################################################################HEXISTS myhash field1  # 判断hash中指定字段是否存在##########################################################################hkeys myhash  # 只获得所有fieldhvals myhash  # 只获得所有value##########################################################################hset myhash field3 5 #指定增量hsetnx myhash field4 hello  # 如果不存在则可以设置hsetnx myhash field4 world  # 如果存在则不能设置##########################################################################</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; hset myhash field1 kuangshen  # set一个具体 key-vlaue(integer) 1127.0.0.1:6379&gt; hget myhash field1  # 获取一个字段值"kuangshen"127.0.0.1:6379&gt; hmset myhash field1 hello field2 world # set多个 key-vlaueOK127.0.0.1:6379&gt; hmget myhash field1 field2 # 获取多个字段值1 ) "hello"2 ) "world"127.0.0.1:6379&gt; hgetall myhash # 获取全部的数据1 ) "field1"2 ) "hello"3 ) "field2"4 ) "world"127.0.0.1:6379&gt; hdel myhash field1  # 删除hash指定key字段！对应的value值也就消失了！(integer) 1127.0.0.1:6379&gt; hgetall myhash1 ) "field2"2 ) "world"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>hlen127.0.0.1:6379&gt; hmset myhash field1 hello field2 worldOK127.0.0.1:6379&gt; HGETALL myhash1 ) "field2"2 ) "world"3 ) "field1"4 ) "hello"127.0.0.1:6379&gt; hlen myhash  # 获取hash表的字段数量！(integer) 2<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; HEXISTS myhash field1  # 判断hash中指定字段是否存在！(integer) 1127.0.0.1:6379&gt; HEXISTS myhash field3(integer) 0<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><span class="hljs-meta">#</span><span class="bash"> 只获得所有field</span><span class="hljs-meta">#</span><span class="bash"> 只获得所有value</span>127.0.0.1:6379&gt; hkeys myhash  # 只获得所有field1 ) "field2"2 ) "field1"127.0.0.1:6379&gt; hvals myhash  # 只获得所有value1 ) "world"2 ) "hello"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>incr decr127.0.0.1:6379&gt; hset myhash field3 5 #指定增量！(integer) 1127.0.0.1:6379&gt; HINCRBY myhash field3 1(integer) 6127.0.0.1:6379&gt; HINCRBY myhash field3 -1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field4 hello  # 如果不存在则可以设置(integer) 1127.0.0.1:6379&gt; hsetnx myhash field4 world  # 如果存在则不能设置(integer) 0</code></pre><p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！hash 更适合于对象的存储，String更加适合字符串存储！</p><h2 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h2><p>在set的基础上，增加了一个值，set k1 v1   zset k1 score1 v1.</p><pre><code>##########################################################################zadd myset 1 one # 添加一个值zadd myset 2 two 3 three # 添加多个值##########################################################################ZRANGEBYSCORE salary -inf +inf  # 显示全部的用户 从小到大！REVRANGE salary 0 -1 # 从大到进行排序！ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于 2500 员工的升序排序！##########################################################################zrem salary xiaohong # 移除有序集合中的指定元素zcard salary  # 获取有序集合中的个数##########################################################################zcount myset 1 3 # 获取指定区间的成员数量！##########################################################################</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>127.0.0.1:6379&gt; zadd myset 1 one # 添加一个值(integer) 1127.0.0.1:6379&gt; zadd myset 2 two 3 three # 添加多个值(integer) 2127.0.0.1:6379&gt; ZRANGE myset 0 -11 ) "one"2 ) "two"3 ) "three"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>排序如何实现127.0.0.1:6379&gt; zadd salary 2500 xiaohong  # 添加三个用户(integer) 1127.0.0.1:6379&gt; zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379&gt; zadd salary 500 kaungshen(integer) 1<span class="hljs-meta">#</span><span class="bash"> ZRANGEBYSCORE key min max</span>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf  # 显示全部的用户 从小到大！1 ) "kaungshen"2 ) "xiaohong"3 ) "zhangsan"127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 # 从大到进行排序！1) "zhangsan"2) "xiaohong"3) "kaungshen"127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩1 ) "kaungshen"2 ) "500"3 ) "xiaohong"4 ) "2500"5 ) "zhangsan"6 ) "5000"127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于 2500 员工的升序排序！1 ) "kaungshen"2 ) "500"3 ) "xiaohong"4 ) "2500"<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span><span class="hljs-meta">#</span><span class="bash"> 移除rem中的元素</span>127 .0.0.1:6379&gt; zrange salary 0 -11 ) "kaungshen"2 ) "xiaohong"3 ) "zhangsan"127 .0.0.1:6379&gt; zrem salary xiaohong # 移除有序集合中的指定元素(integer) 1127 .0.0.1:6379&gt; zrange salary 0 -11 ) "kaungshen"2 ) "zhangsan"127 .0.0.1:6379&gt; zcard salary  # 获取有序集合中的个数(integer) 2<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span>按区间计算127 .0.0.1:6379&gt; zadd myset 1 hello(integer) 1127 .0.0.1:6379&gt; zadd myset 2 world 3 kuangshen(integer) 2127 .0.0.1:6379&gt; zcount myset 1 3 # 获取指定区间的成员数量！(integer) 3127 .0.0.1:6379&gt; zcount myset 1 2(integer) 2<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#########################################################################</span></span></code></pre><p>案例思路：set 排序 存储班级成绩表，工资表排序！</p><p>普通消息， 1 ， 重要消息 2 ，带权重进行判断！</p><p>排行榜应用实现，取Top N 测试！</p><p>其余操作命令：<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">官方文档</a></p><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门</title>
    <link href="/cxlittlecute/6a343b7f.html"/>
    <url>/cxlittlecute/6a343b7f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>redis是什么？</code></pre><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><pre><code>能干嘛？</code></pre><p>1 、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）<br>2 、效率高，可以用于高速缓存<br>3 、发布订阅系统<br>4 、地图信息分析<br>5 、计时器、计数器（浏览量！）<br>6 、……..</p><pre><code>特性</code></pre><p>1 、多样的数据类型<br>2 、持久化<br>3 、集群<br>4 、事务<br>…</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>redis-benchmark 是一个压力测试工具。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820220749.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820221024.png" srcset="/img/loading.gif" alt=""></p><pre><code>#测试：100 个并发连接 100000 请求redis-benchmark -h localhost -p 6379 -c 100 -n 100000</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820222114.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820222703.png" srcset="/img/loading.gif" alt=""></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有 16 个数据库,默认使用的是第0个。</p><pre><code class="hljs shell">127.0.0.1:6379&gt; select 2 #切换数据库OK127.0.0.1:6379[2]&gt; dbsize #查看数据库大小(integer) 0</code></pre><p>你使用的哪个数据库，那么你的操作都在这个数据库上进行，各个数据库之间的数据是隔离的。</p><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; set name oyOK127.0.0.1:6379[2]&gt; keys * #查看当前数据库中所有的key1) "name"127.0.0.1:6379[2]&gt;</code></pre><p>清除当前数据库 flushdb<br>清除全部数据库的内容 FLUSHALL</p><pre><code class="hljs shell">127.0.0.1:6379[2]&gt; flushdbOK127.0.0.1:6379[2]&gt; FLUSHALLOK</code></pre><pre><code>Redis是单线程的</code></pre><p>明白Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的【内存】和【网络带宽】，既然可以使用单线程来实现，就使用单线程了。所有就使用了单线程了。</p><pre><code>Redis 为什么单线程还这么快？</code></pre><p>1 、误区 1 ：高性能的服务器一定是多线程的？<br>2 、误区 2 ：多线程（CPU上下文会切换！）一定比单线程效率高！</p><p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，多线程<br>（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高<br>的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nosql概述</title>
    <link href="/cxlittlecute/5d70f88d.html"/>
    <url>/cxlittlecute/5d70f88d.html</url>
    
    <content type="html"><![CDATA[<h1 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h1><p>从本篇开始将正式回顾redis系列的知识点。</p><p>我们的第一个问题：</p><h2 id="为什么要用Nosql？"><a href="#为什么要用Nosql？" class="headerlink" title="为什么要用Nosql？"></a>为什么要用Nosql？</h2><p>首先我们需要认识到我们现在处于大数据时代，由于是大数据所以我们一般的数据库是无法进行分析处理的。</p><pre><code>1.刚开始的时代是单击Mysql时代</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820195938.png" srcset="/img/loading.gif" alt=""></p><p>一个网站的访问量不会太大，单个数据库就能支撑起来。</p><p>那么这个时候，我们就需要思考这样系统的瓶颈是什么：</p><pre><code>1.数据量太大，一台机器放不下。2.对于Mysql建立的索引过多，机器也放不下。3.访问量（读写混合），一个服务器承受不了。</code></pre><p>那么这个时候只要出现了里面的这些问题，我们的系统就应该升级。</p><pre><code>2.第二个时代：Memcached（缓存） + MySQL + 垂直拆分 （读写分离）</code></pre><p>我们发现我们网站系统大部分的操作都是去读数据，所以我们希望减轻数据的压力，于是便有了缓存。</p><p>发展过程： 优化数据结构和索引（尝试优化产品本身）–&gt; 文件缓存（IO）—&gt; Memcached（当时最热门的技术！）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820200946.png" srcset="/img/loading.gif" alt=""></p><p>有了Cache读的问题能解决大部分。</p><pre><code>3.第三个时代：分库分表 + 水平拆分 + MySQL集群</code></pre><p>MyISAM：表锁<br>INNODB：行锁</p><p>我们开始使用分库分表解决写的压力。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820201732.png" srcset="/img/loading.gif" alt=""></p><pre><code>4.现在</code></pre><p>我们发现Mysql这样的关系型数据库不够用了，因为现在数据量大而且变化很快。</p><p>如果我们使用能使用专门处理这种大数据大文件的数据库，那么我们Mysql的数据压力就变小很多了。</p><p>最后我们回到问题，为什么要使用Nosql？</p><p>因为它能够很好的处理例如用户个人信息，社交网络，地理位置，用户自己产生的数据，用户日志等等爆发式的增长。</p><h2 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h2><p>NoSQL = Not Only SQL （不仅仅是SQL）</p><p>泛指非关系型数据库。</p><p>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式。</p><p>不需要多余的操作就可以横向扩展的。</p><p>Map&lt;String,Object&gt; 使用键值对来控制。</p><pre><code>Nosql特点</code></pre><p>1 、方便扩展（数据之间没有关系，很好扩展）也就是解耦。<br>2 、大数据量高性能（Redis 一秒写 8 万次，读取 11 万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）<br>3 、数据类型是多样型的（不需要事先设计数据库，随取随用，如果是数据量十分大的表，很多人就无法设计了）</p><pre><code>传统 RDBMS 和 NoSQL的区别传统RDBMS：- 结构化组织- SQL- 数据和关系都存在单独的表中- 操作数据定义语言- 严格的一致性- 基础的事务...Nosql：- 不仅仅是数据- 没有固定的查询语句- 键值对存储，列存储，文档存储，图形数据库（社交关系）- 最终一致性- CAP定理和BASE- 高性能，高可用，高可扩...</code></pre><p>3V+3高</p><p>大数据时代的3V：主要是描述问题的</p><pre><code>1. 海量Volume2. 多样Variety3. 实时Velocity</code></pre><p>大数据时代的 3 高：主要是对程序的要求</p><pre><code>1. 高并发2. 高可扩3. 高性能</code></pre><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h2 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h2><pre><code>- KV键值对- 文档型数据库（bson格式 和json一样）- 列存储数据库- 图关系数据库</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200820211250.png" srcset="/img/loading.gif" alt=""></p><pre><code>参见：B站遇见狂神说</code></pre>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯问题解题思路框架</title>
    <link href="/cxlittlecute/124e11.html"/>
    <url>/cxlittlecute/124e11.html</url>
    
    <content type="html"><![CDATA[<h1 id="回溯问题解题思路框架"><a href="#回溯问题解题思路框架" class="headerlink" title="回溯问题解题思路框架"></a>回溯问题解题思路框架</h1><p>最近学习了 labuladong博主（在我的友链中有他）关于回溯问题的解题思路。</p><p>自己下来也发现这个思路还是比较通用的，于是通过自己的理解再次记录其中的问题。</p><p>我们知道回溯问题就是对决策树的遍历问题，回溯”指的是“状态重置”，可以理解为“回到过去”，而且我们在这颗树上的遍历通常选用深度优先遍历。</p><p>我对博主的框架做了一定的修改如下：</p><pre><code class="hljs java">存放所有结果的集合(一般设置为静态变量)<span class="hljs-keyword">public</span> 存放所有结果的集合 permute(可选列表)     选择的路径集合    backtrack(可选列表,inList);<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(可选列表,选择的路径集合)</span></span><span class="hljs-function">    <span class="hljs-keyword">if</span> 满足结束条件:</span><span class="hljs-function">        result.<span class="hljs-title">add</span><span class="hljs-params">(路径)</span></span><span class="hljs-function">        return</span><span class="hljs-function"></span><span class="hljs-function">    <span class="hljs-keyword">for</span> 选择 in 选择列表:</span><span class="hljs-function">        排除不符合规定的选择</span><span class="hljs-function">        做选择</span><span class="hljs-function">        <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span><span class="hljs-function">        撤销选择</span></code></pre><p>那么大致的框架已经给出了，那么我一一来分析其中的几个概念：</p><p>1、路径：也就是已经做出的选择。<br>2、可选列表：也就是你当前可以做的选择。<br>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>那么我们就以LeeCode上<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a>这个问题进行框架的套用。</p><pre><code class="hljs java"><span class="hljs-comment">// 存放所有结果的集合(一般设置为静态变量)</span>List&lt;List&lt;Integer&gt;&gt; outList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-comment">// 选择的路径集合</span>    LinkedList&lt;Integer&gt; inList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    backtrack(nums,inList);    <span class="hljs-keyword">return</span> outList;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; inList)</span> </span>&#123;    <span class="hljs-comment">// 结束条件</span>    <span class="hljs-keyword">if</span> (nums.length == inList.size())&#123;        outList.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(inList));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;        <span class="hljs-comment">// 排除不符合规定的选择</span>        <span class="hljs-keyword">if</span> (inList.contains(num))&#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">// 做选择</span>        inList.add(num);        <span class="hljs-comment">// 进入下一层决策树</span>        backtrack(nums, inList);        <span class="hljs-comment">// 取消选择</span>        inList.removeLast();    &#125;&#125;</code></pre><p>这里也强调一下:</p><pre><code class="hljs java">outList.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(inList));</code></pre><p>大家肯定疑问为什么这里，不直接将inList放入outList，而要在外面还要套一层（俄罗斯套娃）。</p><p>因为inList这个变量所指向的对象在递归的过程中只有一份，深度优先遍历完成以后，因为回到了根结点，回溯问题从深层结点回到浅层结点的时候，会有撤销的操作，因此inList这个变量回到根结点以后都为空。</p><p>同时我们需要注意的是，在Java中，因为都是值传递，对象类型变量在传参的过程中，复制的都是变量的地址。这些地址被添加到outList变量，但实际上指向的是同一块内存地址，你回溯过后就会把列表清空，得到空的对象集,解决办法就是想上面一样再做一次拷贝工作。</p><p>那么通过上面的思路也可以同样实现所谓的<a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后问题</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeeCode5</span> </span>&#123;    List&lt;List&lt;String&gt;&gt; outList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;        <span class="hljs-comment">// 判断条件是否符合要求</span>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 初始化棋盘(在这里棋盘也是记录路径的作用)</span>        <span class="hljs-keyword">char</span>[][] checkerboard = checkerboard(n);        backtrack(checkerboard, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> outList;    &#125;    <span class="hljs-comment">// 初始化棋盘</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[][] checkerboard(<span class="hljs-keyword">int</span> n)&#123;        <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] chars : board) &#123;            Arrays.fill(chars, <span class="hljs-string">'.'</span>);        &#125;        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 路径：board中小于row的那些行都已经成功放置了皇后</span><span class="hljs-comment">     * 可选择列表: 第row行的所有列都是放置Q的选择</span><span class="hljs-comment">     * 结束条件: row等于board的最后一行</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> board</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-comment">// 结束条件</span>        <span class="hljs-keyword">if</span> (row == board.length) &#123;            outList.add(charToString(board));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 列数</span>        <span class="hljs-keyword">int</span> n = board[row].length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;            <span class="hljs-comment">// 排除不符合规定的选择</span>            <span class="hljs-keyword">if</span> (!isValid(board, row, col))&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 做选择</span>            board[row][col] = <span class="hljs-string">'Q'</span>;            backtrack(board, row + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 撤销选择</span>            board[row][col] = <span class="hljs-string">'.'</span>;        &#125;    &#125;    <span class="hljs-comment">// 判断是否符合规定</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;        <span class="hljs-keyword">int</span> rows = board.length;        <span class="hljs-comment">// 检查列是否有皇后互相冲突</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] chars : board) <span class="hljs-keyword">if</span> (chars[col] == <span class="hljs-string">'Q'</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">// 检查右上方是否有皇后互相冲突</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; rows; i--, j++) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">// 检查左上方是否有皇后互相冲突</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">'Q'</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">charToString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] array)</span> </span>&#123;        List&lt;String&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>[] chars : array) &#123;            result.add(String.valueOf(chars));        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>参考：<br><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域与内存溢出异常（三）-实战：OOM异常</title>
    <link href="/cxlittlecute/ffd7ad5b.html"/>
    <url>/cxlittlecute/ffd7ad5b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常（三）-实战：OOM异常"><a href="#Java内存区域与内存溢出异常（三）-实战：OOM异常" class="headerlink" title="Java内存区域与内存溢出异常（三）-实战：OOM异常"></a>Java内存区域与内存溢出异常（三）-实战：OOM异常</h1><p>在Java虚拟机规范的描述中,除了程序计数器外,虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(下文称00M )异常的可能,本节将通过若干实例来验证异常发生的场景,并且会初步介绍几个与内存相关的最基本的虚拟机参数。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><pre><code>1.通过代码验证《Java虚拟机规范》中描述的各个运行时区域存储的内容。2.在我们遇到实际内存溢出异常时，我们能根据异 常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出,以及出现这些异常后该如何处理。</code></pre><p>下文代码的开头都注释了执行时所需要设置的虚拟机启动参数(注释中“VM Args”后面跟着的参数),这些参数对实验的结果有直接影响,读者调试代码的时候千万不要忽略。</p><p>如果使用的是控制台命令来执行程序，那直接跟在Java命令之后书写就可以。</p><p>本文主要以IntelliJ IDEA作为操作工具。参数设置位置参考：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200812153147.png" srcset="/img/loading.gif" alt=""></p><p>为了进行我们的JVM性能分析，我们选择JProfiler作为我们的性能分析工具。</p><pre><code>JProfiler V11.0.2百度云链接：链接：https://pan.baidu.com/s/1dVpwUXKCUcJUZof0VQDO8g 提取码：gg63安装教程：https://www.isharepc.com/14200.html</code></pre><p>同时我们需要在Idea中下载JProfiler的插件：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200812161824.png" srcset="/img/loading.gif" alt=""></p><h2 id="1-1-Java堆溢出"><a href="#1-1-Java堆溢出" class="headerlink" title="1.1 Java堆溢出"></a>1.1 Java堆溢出</h2><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证【GC Roots】到【对象】之间有【可达路径】来【避免垃圾回收机制】清除这些对象，就会在对象数量到达最大堆的容量限制后产生内存溢出异常。</p><p>下面代码中限制Java堆的大小为20MB，【不可扩展】（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDump OnOutOfMemoryError可以让虚拟机在出现内存溢出异常时【Dump】出当前的内存【堆转储快照】文件以便进行分析。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError </span><span class="hljs-comment"> */</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;OOMObject&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;OOMObject&gt;();        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            list.add(<span class="hljs-keyword">new</span> OOMObject());        &#125;    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200812153614.png" srcset="/img/loading.gif" alt=""></p><p>Java堆内存的OOM异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p><h4 id="如何解决堆内存溢出异常？"><a href="#如何解决堆内存溢出异常？" class="headerlink" title="如何解决堆内存溢出异常？"></a>如何解决堆内存溢出异常？</h4><p>首先要确定内存中导致OOM的对象是否是必要的，也就是到底是【内存泄露】（Memory Leak）还是【内存溢出】(Memory Overflow)造成的。</p><ul><li><p>如果是内存泄漏，可进一步通过工具查看【泄漏对象】到【GC Roots】的【引用链】。于是就能找到泄漏对象是通过怎样的【引用路径】，与哪些GC Roots【相关联】，才导致垃圾收集器无法自动回收它们，根据泄露对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄露的代码的具体位置。</p></li><li><p>如果不存在泄露,换句话说,就是内存中的对象确实都还必须存活着,那就应当检查虛拟机的堆参数(-Xmx与-Xms ) 设置,与机器物理内存对比，看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况,尝试减少程序运行期的内存消耗。</p></li></ul><h2 id="1-2-虚拟机栈和本地方法栈溢出"><a href="#1-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="1.2 虚拟机栈和本地方法栈溢出"></a>1.2 虚拟机栈和本地方法栈溢出</h2><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p><pre><code>1.如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。2.如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</code></pre><p>注意：HotSpot虚拟机是不支持栈的动态扩展的。</p><p>所以，除非在【创建线程申请内存时】无法获得足够内存会出现OutOfMemoryError异常，否则线程在运行时不会因为扩展而导致内存溢出。</p><p>笔者给了我们两个实验，让我们在单线程情况下，尝试下面两种行为是否导致HotSpot产生OutOfMemoryError。</p><pre><code>- 使用-Xss参数减少栈内存容量- 定义大量的本地变量，增大此方法帧中本地变量表的长度。</code></pre><p>他们两的结果都为无法让虚拟机产生OutOfMemoryError异常,尝试的结果都是获得StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p><p>总结:在单个线程下,无论是由于栈帧（一个方法中包含的本地变量数）太大还是虚拟机栈容量（-Xss参数减少每个线程栈内存容量）太小,当内存无法分配的时候,虚拟机拋出的都是StackOverflowError异常。</p><p>我们需要注意在多线程情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。因为每个线程分配到的栈容量越大,可以建立的线程数量自然就越少,建立线程时就越容易把剩下的内存耗尽。</p><p>如果我们使用HotSpot虚拟机【默认参数】，栈深度在大多数情况下(因为每个方法压入栈的帧大小并不是一样的,所以只能说在大多数情况下)达到1000〜2000完全没有问题,对于正常的方法调用(包括递归),这个深度应该完全够用了。但是 ,如果是建立过多线程导致的内存溢出,在不能减少线程数或者更换64位虚拟机的情况下,就只能通过【减少最大堆】和【减少栈容量】的方式来换取更多的线程。</p><h2 id="1-3-方法区和运行时常量池溢出"><a href="#1-3-方法区和运行时常量池溢出" class="headerlink" title="1.3 方法区和运行时常量池溢出"></a>1.3 方法区和运行时常量池溢出</h2><p>首先我们要知道的是在JDK8中完全使用元空间代替永生代。</p><p>然后我们再来了解一个本地方法String::intern()。</p><p>该方法的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p><p>在JDK6之前，由于常量池分配在永生代中，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。</p><p>但是在JDK7起，原本放在永生代的字符串常量池被移植Java堆之中，溢出要看输出信息具体是哪个对象。</p><p>书中有意思的便是下面这个例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeConstantPoolOOM</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String str1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"中国"</span>).append(<span class="hljs-string">"钓鱼岛"</span>).toString();        System.out.println(str1.intern() == str1);        String str2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"ja"</span>).append(<span class="hljs-string">"va"</span>).toString();        System.out.println(str2.intern() == str2);    &#125;   &#125;&#125;</code></pre><p>这段代码在JDK 1.6中运行,会得到两个false,而在JDK 1.7中运行,会得到一个true和一 个false。</p><pre><code>结论：原因就是JDK7起intern()方法不需要再拷贝字符串的实例到永生代了，字符串常量池已经移到了Java堆中，只需要在常量池中记录首次出现的实例引用即可，因此intern( ) 返回的引用和由StringBuilder(）创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString ( ) 之前已经出现过（其他类已经加载过这个字符串进入常量池）,字符串常量池中已经有它的引用了,不符合“ 首次出现” 的原则,而“计算机软件”这个字符串则是首次出现的,因此返回true。</code></pre><p>方法区溢出也是一种常见的内存溢出异常,一个类要被垃圾收集器回收掉,判定条件是比较苛刻的。</p><p>在经常动态生成大量Class的应用场景中,需要特别注意这些类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外,常见的还有:大量JSP或动态产生JSP文件的应用(JSP第一次运行时需要编译为Java类 )、基于OSGi的应用(即使是同一个类文件,被不同的加载器加载也会视为不同的类)等。</p><p>HotSpot提供了一些参数作为元空间的防御措施：</p><pre><code>-XX:MaxMetaspaceSize-XX:MetaspaceSize-XX:MinMetaspaceFreeRatio</code></pre><h2 id="1-4-本机直接内存溢出"><a href="#1-4-本机直接内存溢出" class="headerlink" title="1.4 本机直接内存溢出"></a>1.4 本机直接内存溢出</h2><p>DirectMemory容量可通过-XX : MaxDirectMemorySize指定,如果不指定,则默认与Java堆最大值(-Xmx指定)一样。</p><p>由DirectMemory导致的内存溢出,一个明显的特征是在Heap Dump文件中不会看见明显的异常,如果读者发现OOM之后Dump文件很小,而程序中又直接或间接使用了NIO,那就可以考虑检查一下是不是这方面的原因。</p><pre><code>参考图书：《深入理解Java虚拟机-Java高级特性与最佳实战》第3版</code></pre>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域与内存溢出异常（二）-HotSpot虚拟机对象探秘</title>
    <link href="/cxlittlecute/1b1cef79.html"/>
    <url>/cxlittlecute/1b1cef79.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常（二）-HotSpot虚拟机对象探秘"><a href="#Java内存区域与内存溢出异常（二）-HotSpot虚拟机对象探秘" class="headerlink" title="Java内存区域与内存溢出异常（二）-HotSpot虚拟机对象探秘"></a>Java内存区域与内存溢出异常（二）-HotSpot虚拟机对象探秘</h1><p>在我们了解完Java虚拟机的运行时数据区域之后，我们肯定想要进一步了解虚拟机内存中数据的其他细节，比如它们是【如何创建】、【如何布局】以及【如何访问】的。</p><p>接下来我们就以HotSpot虚拟机来讨论它在Java堆中对象分配、布局和访问的全过程。</p><h2 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h2><p>当Java虚拟机遇到一条字节码new指令时：</p><ul><li>首先，将去检查这个指令的参数是否能在常量池中定位到一个类的【符号引用】，并且检查这个符号引用代表的类是否已被【加载】、【解析】和【初始化】过。如果没有，那么必须先执行相应的类加载过程。</li><li>接着，在类加载检查通过后，接下来虚拟机将为新生对象【分配内存】。对象所需内存的大小在【类加载完成后】便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</li><li>然后，Java虚拟机还要对对象进行必要的设置。（如对象头等信息）</li></ul><p>以上步骤完成后，从虚拟机角度来说，一个新的对象已经产生了。</p><p>注意：对于Java程序的视角来说，对象创建才刚刚开始，因为构造函数，即Class文件中的<init>（）方法还没有执行，所有的字段都是零值。一般来说，new关键字对应的字节码指令分别为new指令和invokespecial指令。只有new指令后接着执行<init>()方法，按照我们的意图对对象进行初始化后，一个真正的对象才算是完全构造出来。</p><h4 id="Java堆给对象分配内存的方式："><a href="#Java堆给对象分配内存的方式：" class="headerlink" title="Java堆给对象分配内存的方式："></a>Java堆给对象分配内存的方式：</h4><p>指针碰撞：</p><pre><code>假设Java堆内存是规整的，所有用过的内存放一边，空闲的方另外一边，中间放着一个指针作为分界点的指示器。那么分配内存时就只需将指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式就称为指针碰撞。</code></pre><p>空闲列表：</p><pre><code>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了。虚拟机就必须维护一个列表，记录上哪些内存是可用的。在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录，这种分配方式称为空闲列表。</code></pre><p>注：选择哪种方式是由【Java堆是否规整】决定，而Java堆是否规整又由所采用的【垃圾收集器】是都带有【压缩整理功能】决定，因此：使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞,而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。这种问题如何解决？</p><p>两种可选方案：</p><ol><li>一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用【CAS配上失败重试】的方式保证更新操作的原子性。</li><li>另一种是把内存分配的动作【按照线程划分】在不同的空间之中进行，即每个线程在Java堆中预先分配一小块儿内存，称为本地线程分配缓冲(Thread LocalAllocation Buffer,TLAB)。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</li></ol><h2 id="1-2-对象的内存布局"><a href="#1-2-对象的内存布局" class="headerlink" title="1.2 对象的内存布局"></a>1.2 对象的内存布局</h2><p>在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分:</p><pre><code>1.对象头2.实例数据3.对齐补充</code></pre><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头部分包含两类信息：</p><ul><li>第一类【存储对象自身的运行时数据】。如哈希码（HashCode）、GC分代年龄、锁状态以及偏向线程的ID等。这部分数据数据长度在32位和64位的虚拟机（未开启指针压缩）中分别为32bit和64bit，官方称为’Mark word’。</li></ul><p>补充：对象须要存储的执行时的数据许多。已经超出了32位、64位Bitmap结构所能记录的限度，可是对象头信息是【与对象自身定义的数据无关的额外存储成本】，考虑到虚拟机的空间效率。Mark work被设计成一个【动态定义的数据结构】，以便在极小空间内存储尽可能多的信息，他会依据对象状态复用自己的存储空间。</p><p>HotSpot中Mark Word的结构：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200812111100.png" srcset="/img/loading.gif" alt=""></p><ul><li>另一部分是【类型指针】，即对象指向它的类型元数据的指针，Java虚拟机通常通过这个指针来确定该对象是哪个类的实例。</li></ul><p>注意：并不是所有的虚拟机实现都必须在对象数据上保留类型指针，简言之，查找对象的元数据信息并不一定要经过对象本身。</p><p>补充：同时如果对象是一个Java数组，在对象头中还应该有一块用于【记录数组长度的数据】，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据存储的是对象【真正的有效数据】，即各个类型字段的内容。无论是子类中定义的，还是从父类继承下来的都需要记录。这部分数据的【存储顺序】受到【虚拟机分配策略参数（-XX:FieldsAllocationStyle参数）】以及字段在类中的定义顺序的影响。</p><p>HotSpot默认的分配策略是将相同宽度的字段分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p><p>如果HotSpot虚拟机的+XX:CompactFields参数值为true（默认），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p><h4 id="对齐补充"><a href="#对齐补充" class="headerlink" title="对齐补充"></a>对齐补充</h4><p>这部分数据不是必然存在的，因为对象的大小总是8字节的整数倍，该数据仅用于补齐实例数据部分不足整数倍的部分，充当占位符的作用。</p><h2 id="1-3-对象的访问定位"><a href="#1-3-对象的访问定位" class="headerlink" title="1.3 对象的访问定位"></a>1.3 对象的访问定位</h2><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。</p><p>reference类型只是一个指向对象的引用，并没有定义它是通过什么方式去定位、访问到堆中对象的具体位置。</p><p>所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有两种：</p><pre><code>1.句柄2.直接指针</code></pre><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>此方式可能在堆中划分出一块内存作为句柄池，reference中存储的是对象的句柄地址。句柄中包含各【对象的实例数据】和【类型数据】各自的地址信息。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200812114215.png" srcset="/img/loading.gif" alt=""></p><p>此方式的好处是reference中保存的是稳定的句柄的地址，因为对象的移动在GC过程中是非常普遍的行为，我们使用这种方式只会改变句柄中的实例数据指针，而reference本身不需要被修改。带来的缺点就是访问效率受影响。</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>即对象引用中保存的直接的对象地址，但Java对中对象的内存布局就必须要考虑如何放置访问类型数据的相关信息。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200812120041.png" srcset="/img/loading.gif" alt=""></p><p>该方式的优点是节省了一次指针定位的开销，访问速度快。缺点是当对象地址发生变化是引用中保存的数据也需要变化。</p><p>在HotSpot中主要使用第二种方式进行对象访问。（但有例外Shenandoah收集器会有一次额外的转发）</p><pre><code>参考图书：《深入理解Java虚拟机-Java高级特性与最佳实战》第3版</code></pre>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域与内存溢出异常（一）-运行时数据区域</title>
    <link href="/cxlittlecute/4d26dbf4.html"/>
    <url>/cxlittlecute/4d26dbf4.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常（一）-运行时数据区域"><a href="#Java内存区域与内存溢出异常（一）-运行时数据区域" class="headerlink" title="Java内存区域与内存溢出异常（一）-运行时数据区域"></a>Java内存区域与内存溢出异常（一）-运行时数据区域</h1><p>本篇文章为这一系列的第一部分，我将描述分析：</p><pre><code>1. Java虚拟机内存各个区域的概念2. 各个区域的作用3. 各个区域服务的对象4. 各个区域中可能会产生的问题</code></pre><h2 id="1-1-运行时数据区域"><a href="#1-1-运行时数据区域" class="headerlink" title="1.1 运行时数据区域"></a>1.1 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中，会把它管理的内存划分为若干个不同的数据区域。</p><p>那么，根据《Java虚拟机规范的规定》，Java虚拟机所管理的内存将会分为以下几个运行时数据区域。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200811194629.png" srcset="/img/loading.gif" alt=""></p><p>所有线程共享的数据区：</p><pre><code>1.方法区2.堆3.执行引擎4.本地方法接口</code></pre><p>线程隔离的数据区：</p><pre><code>1.虚拟机栈VM Stack（Java栈）2.本地方法栈3.程序计数器</code></pre><h3 id="1-1-1-程序计数器"><a href="#1-1-1-程序计数器" class="headerlink" title="1.1.1 程序计数器"></a>1.1.1 程序计数器</h3><p>1.它是一块较小的内存空间，它可以看作是当前线程所执行【字节码的行号指示器】。</p><p>2.字节码解释器就是通过改变它的值来控制下一条需要执行的字节码指令。</p><p>3.它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><pre><code>Java虚拟机中的多线程是通过【线程轮流切换】、【分配处理器执行时间】的方式实现的。所以在任何一个时刻，一个处理器都只会执行一条线程中的指令。</code></pre><p>4.为了每一个线程在切换后【能恢复到正确的执行位置】，每条线程都需要有一个【独立】的程序计数器。所以，每条线程之间的计数器互不影响，独立存储。（我们称为“线程私有”的内存）</p><p>5.线程如果正在执行一个Java方法，计数器会记录【正在执行虚拟机字节码指令的地址】。如果正在执行的是本地(Native)方法，那么计数器的值应该为空（Undefined）。</p><p>6.这个内存区域是【唯一一个】在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="1-1-2-Java虚拟机栈"><a href="#1-1-2-Java虚拟机栈" class="headerlink" title="1.1.2 Java虚拟机栈"></a>1.1.2 Java虚拟机栈</h3><p>1.它描述的是【Java方法执行的线程内存模型】：每个方法被执行的时候，虚拟机会同步创建一个【栈帧】，栈帧用于存放局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用到执行完毕的过程，对应栈帧在虚拟机栈从【入栈】到【出栈】的过程。</p><p>我们常说的“栈”，通常就是这里的虚拟机栈，或者更多时候准确指的是虚拟机栈中【局部变量表】部分。</p><p>2.讲到这里大家肯定想问局部变量表是什么，首选我们要知道局部变量表中存放了【编译期】可知的Java虚拟机中的</p><pre><code>- 基本数据类型（boolean、byte、char、short、int、float、long、double）- 对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的【引用指针】，也可能是指向一个代表对象的【句柄】或者其他与此对象【相关的位置】）- returnAddress类型（指向一条字节码指令的地址）</code></pre><p>3.这些数据类型在局部变量表中的存储空间，以【局部变量槽】（Slot）表示。（除64位长度的long和double类型的数据会占用两个变量槽，其他数据类型只占用一个）。</p><p>4.局部变量表所需要的内存空间在编译期间完成分配，一个方法在栈帧中分配的局部变量空间是确定的，在方法运行期间不会改变局部变量表的大小（大小指槽的数量）。真正需要多大的内存空间实现一个槽，是由虚拟机自己决定的。</p><p>5.在《Java虚拟机规范》中这个内存区域规定了两类异常情况：</p><pre><code>1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。2.如果虚拟机栈容量在动态扩容时（HotSpot虚拟机栈容量是不可以动态扩展的）无法申请到足够的内存，将抛出OutOfMemoryError异常。</code></pre><p>所以，对于HotSpot来说只要线程申请栈空间成功了，就不会出现OOM。</p><h3 id="1-1-3-本地方法栈"><a href="#1-1-3-本地方法栈" class="headerlink" title="1.1.3 本地方法栈"></a>1.1.3 本地方法栈</h3><p>上面我们看了Java虚拟机栈，接下来我们再来了解本地方法栈又是什么。</p><p>1.首先它们两个发挥的作用非常相似，其区别是：</p><pre><code>- 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务- 本地方法栈为虚拟机执行【本地方法】（Native）服务</code></pre><p>注意：在有的Java虚拟机（如HotSpot）直接把本地方法栈和虚拟机栈合二为一，所以也会出现上面两种异常。</p><h3 id="1-1-4-Java堆"><a href="#1-1-4-Java堆" class="headerlink" title="1.1.4 Java堆"></a>1.1.4 Java堆</h3><p>1.Java堆是虚拟机所管理内存中【最大】的部分。它是被【所有线程共享】的一块内存区域，【在虚拟机启动时创建】。</p><p>2.唯一目的就是【存放对象实例】。《Java虚拟机规范》中的描述是：所有的对象实例以及数组都应当在堆上分配。（但是随着Java的发展，这个规定在实现上也变得没有那么绝对）</p><p>3.Java堆是【垃圾收集器管理】的内存区域（也称为GC堆）。</p><pre><code>扩展：从回收内存的角度看，现代垃圾收集器大部分是基于【分代收集理论】设计的。所以会出现“新生代”“老年代”“永生代”等名词。</code></pre><p>4.从分配内存的角度看，所有线程共享的Java堆，可以划分出多个线程私有的【分配缓冲区】（TLAB），以提高对象分配时的效率。</p><p>注意：无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，那就是无论哪个区域，存储的都【只能是对象的实例】。</p><p>5.《Java虚拟机规范》中规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>6.Java堆既可以被实现为【固定大小的】，也可以是【可扩展的】。现在主流的Java虚拟机都是按照可扩展的实现（通过-Xmx和-Xms设置）。这两个参数有没有看起来很熟悉的感觉。</p><p>7.如果在Java堆中没有内存完成实例分配，并且堆无法再扩展，Java虚拟机将会抛出OutOfMemoryError异常。</p><h3 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h3><p>1.方法区和Java堆一样，也是各个【线程共享】的内存区域。</p><p>2.它用于存储【已被虚拟机加载】的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据。</p><p>3.《Java虚拟机规范》对方法区的约束非常宽松，除了和Java堆一样不需要连续内存、可以选择固定大小和可扩展外，甚至还可以选择【不实现垃圾收集】。</p><p>4.该区域的内存回收目标主要是针对【常量池的回收】和对【类型的卸载】。</p><p>5.如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p><h3 id="1-1-6-运行时常量池"><a href="#1-1-6-运行时常量池" class="headerlink" title="1.1.6 运行时常量池"></a>1.1.6 运行时常量池</h3><p>1.运行时常量池是【方法区的一部分】。</p><p>2.Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是【常量池表】，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>3.《Java虚拟机规范》没有对这一部分做任何细节的要求，不同提供商可以按照自己的需要来实现这一区域。不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的【直接引用】也存储在运行时常量池中。</p><p>4.它是方法区的一部分，自然受到【方法区的内存限制】，当常量池无法申请到内存时，会抛出OutOfMemoryError异常。</p><h3 id="1-1-7-直接内存"><a href="#1-1-7-直接内存" class="headerlink" title="1.1.7 直接内存"></a>1.1.7 直接内存</h3><p>1.它并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分经常被使用。</p><pre><code>我们前面的文章讲了NIO，在NIO中引入了一种基于通道和缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存。然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样可以避免Java堆和Native堆中来回复制数据。</code></pre><p>2.当各个内存区域总和大于物理内存限制，就会导致动态扩展时出现OutOfMemoryError异常。</p><pre><code>参考图书：《深入理解Java虚拟机-Java高级特性与最佳实战》第3版</code></pre>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/cxlittlecute/aeafbee0.html"/>
    <url>/cxlittlecute/aeafbee0.html</url>
    
    <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>在网络环境下,通俗的讲,将IO分为两步: 第一步是等待 ; 第二步是数据搬迁.<br>如果想提高IO效率,主要就是降低等待时间,因此衍生出了下面的几种IO模型分类。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><pre><code>1.阻塞IO模型2.非阻塞IO模型3.多路复用IO模型4.信号驱动IO模型5.异步IO模型</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在分别介绍几个IO模型的时候我们需要先掌握以下几个概念。</p><ol><li><p>进程和线程是什么？</p><pre><code>1.进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。2.每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；  线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。3.在操作系统中能同时运行多个进程（程序）；  而在同一个进程（程序）中有多个线程同时执行4.系统在运行的时候会为每个进程分配不同的内存空间;  而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。5.一个进程内有多个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</code></pre></li><li><p>同步和异步是什么？</p><pre><code>同步和异步的概念描述的是用户线程与内核的交互方式。同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行。而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</code></pre></li><li><p>阻塞和非阻塞是什么？</p><pre><code>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式。阻塞是指IO操作需要彻底完成后才返回到用户空间。非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</code></pre></li></ol><p>接下来我们以IO操作的读操作作为示例。</p><h2 id="一、阻塞IO模型"><a href="#一、阻塞IO模型" class="headerlink" title="一、阻塞IO模型"></a>一、阻塞IO模型</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810124543.png" srcset="/img/loading.gif" alt=""></p><p>用户进程向系统内核发送请求后,在等待系统内核处理数据的这段时间,用户进程就会被阻塞,当前什么都不能干,就等待结果.当数据准备好了后,系统内核,将数据拷贝到用户内存,然后返回结果,用户进程才解决阻塞状态,重新运行起来。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810125016.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、非阻塞IO模型"><a href="#二、非阻塞IO模型" class="headerlink" title="二、非阻塞IO模型"></a>二、非阻塞IO模型</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810125213.png" srcset="/img/loading.gif" alt=""></p><p>当用户进程发出请求后,如果内核中的数据还没准备好,那么他不会阻塞用户进程,而是立刻返回一个Error,当用户进程判断结果是一个Error时,他就知道数据还没准备好,于是它可以再次发送请求 ,就这样不停的轮询直到内核数据准备好了,并且再次收到了用户进程的请求,那么就会把数据拷贝到用户内存,然后返回。</p><p>注意：在等待系统内核处理数据的时候,非阻塞IO会不停的轮询查看发起的请求是否有应答结果,但可以去处理其他事情。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810125358.png" srcset="/img/loading.gif" alt=""></p><h2 id="三、多路复用IO模型"><a href="#三、多路复用IO模型" class="headerlink" title="三、多路复用IO模型"></a>三、多路复用IO模型</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810161943.png" srcset="/img/loading.gif" alt=""></p><p>多个进程的IO可以注册到一个复用器(Selector)上,当用户进程调用该Selector,Selector会监听注册进来的所有IO,如果Selector监听所有的IO,在内核上缓冲区上都没有可读的数据时,select调用就会返回,而后select进行线程轮询自己或者通知注册到Selector上面的IO再次发起读取IO,读取内核中准备好的数据,多个进程注册IO后,只有一个select调用进程被阻塞。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810162643.png" srcset="/img/loading.gif" alt=""></p><h2 id="四、信号驱动IO模型"><a href="#四、信号驱动IO模型" class="headerlink" title="四、信号驱动IO模型"></a>四、信号驱动IO模型</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810161309.png" srcset="/img/loading.gif" alt=""></p><p>用户进程预先告知内核,向内核注册一个信号处理函数,然后用户进程返回不阻。,当内核数据就绪时会发送一个信号给进程,用户进程便在信号处理函数中调用IO读取数据。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810162725.png" srcset="/img/loading.gif" alt=""></p><h2 id="五、异步IO模型"><a href="#五、异步IO模型" class="headerlink" title="五、异步IO模型"></a>五、异步IO模型</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810162913.png" srcset="/img/loading.gif" alt=""></p><p>用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810162958.png" srcset="/img/loading.gif" alt=""></p><h2 id="趣味描述"><a href="#趣味描述" class="headerlink" title="趣味描述"></a>趣味描述</h2><p>最后我们通过钓鱼的故事来描述这五个IO模型：</p><ul><li><p>阻塞IO模型:</p><pre><code>我们钓鱼的时候，整个过程一直坐在鱼竿前，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。</code></pre></li><li><p>非阻塞IO模型：</p><pre><code>我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情，比如玩一把王者荣耀、看一集《延禧攻略》等等。但是，我们要时不时的去看一下鱼竿（轮询），一旦发现有鱼儿上钩了，就把鱼钓上来。</code></pre></li><li><p>多路复用IO模型：</p><pre><code>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。</code></pre></li><li><p>信号驱动IO模型：</p><pre><code>我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。</code></pre></li><li><p>异步IO模型：</p><pre><code>我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。</code></pre></li></ul><p>参考转载：<br><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">https://blog.csdn.net/kuangsonghan/article/details/80674777</a><br><a href="https://blog.csdn.net/caoweifeng12/article/details/107902641" target="_blank" rel="noopener">https://blog.csdn.net/caoweifeng12/article/details/107902641</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&amp;mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&amp;source=41&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO（三）-Path Files</title>
    <link href="/cxlittlecute/a4bb995.html"/>
    <url>/cxlittlecute/a4bb995.html</url>
    
    <content type="html"><![CDATA[<h1 id="NIO（三）-Path-Files"><a href="#NIO（三）-Path-Files" class="headerlink" title="NIO（三）-Path Files"></a>NIO（三）-Path Files</h1><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>Path接口是java NIO2的一部分。首次在java 7中引入。Path接口在java.nio.file包下，所以全称是java.nio.file.Path。</p><p>java中的Path表示文件系统的路径。可以指向文件或文件夹。也有相对路径和绝对路径之分。</p><p>在很多方面，java.nio.file.Path接口和java.io.File有相似性，但也有一些细微的差别。在很多情况下，可以用Path来代替File类。</p><h3 id="创建Path实例"><a href="#创建Path实例" class="headerlink" title="创建Path实例"></a>创建Path实例</h3><p>为了使用java.nio.file.Path实例，必须首先创建它。可以使用Paths 类的静态方法Paths.get()来产生一个实例。以下是示例：</p><pre><code>Path path = Paths.get(&quot;1.txt&quot;);//在a-project目录后面的..符号，将指向的目录修改为projects目录，因此，最终path指向another-project目录。String path = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;Path parentDir2 = Paths.get(path); //输出：d:\data\projects\another-project</code></pre><h4 id="Path-normalize"><a href="#Path-normalize" class="headerlink" title="Path.normalize()"></a>Path.normalize()</h4><p>Path 的normalize()方法可以标准化路径。标准化的含义是路径中的.和..都被去掉，指向真正的路径目录地址。下面是Path.normalize()示例：</p><pre><code class="hljs java">String originalPath =<span class="hljs-string">"d:\\data\\projects\\a-project\\..\\another-project"</span>;Path path1 = Paths.get(originalPath);System.out.println(<span class="hljs-string">"path1 = "</span> + path1);Path path2 = path1.normalize();System.out.println(<span class="hljs-string">"path2 = "</span> + path2);</code></pre><p>上文示例，首先创建了一个包含..字符的路径地址。之后输出此路径。</p><p>之后，调用normalize方法，返回一个新的path对象。输出新对象的路径。</p><p>输出结果：</p><pre><code>path1 = d:\data\projects\a-project\..\another-projectpath2 = d:\data\projects\another-project// 标准化后的路径不再包含 a-project\..部分，因为它是多余的。</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810065713.png" srcset="/img/loading.gif" alt=""></p><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>java NIO Files类(java.nio.file.Files) 提供了操作文件的相关方法。它是用于操作文件或目录的工具类。</p><p>java.nio.file.Files类需要和java.nio.file.Path一起使用，在学习Files类前，你需要掌握Path类的相关用法。</p><p>Files类包含了很多方法，本篇文章主要是提出这两个新的API，更多方法请查询JavaDoc文档。</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810072328.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200810072417.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO（二）-非阻塞式网络通信</title>
    <link href="/cxlittlecute/4deaa97d.html"/>
    <url>/cxlittlecute/4deaa97d.html</url>
    
    <content type="html"><![CDATA[<h1 id="NIO（二）-非阻塞式网络通信"><a href="#NIO（二）-非阻塞式网络通信" class="headerlink" title="NIO（二）-非阻塞式网络通信"></a>NIO（二）-非阻塞式网络通信</h1><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809113930.png" srcset="/img/loading.gif" alt=""></p><p>我们使用这个图首先来分析一下什么是阻塞式与非阻塞式网络通信。</p><h2 id="阻塞式和非阻塞式"><a href="#阻塞式和非阻塞式" class="headerlink" title="阻塞式和非阻塞式"></a>阻塞式和非阻塞式</h2><h4 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a>阻塞式</h4><p>什么是阻塞式叻？当Client发送一个请求给Server以后，如果Server无法确定Client发送的这个请求真实有效时，该线程会一直处于一个阻塞状态。</p><p>Server只有当Client发送一个有效数据后，才会开始工作，此时Server端的这个线程是什么都做不了的。</p><p>Client发送数据是先到内核地址空间，Server端就是判断在这个内核地址空间中有没有有效数据，如果没有数据Server就等待，线程阻塞。有数据后，就会把内核地址空间中的数据copy到用户地址空间中，然后就可以读到我们的程序中。</p><p>也正是因为会阻塞，当大量的请求来访问时，就会形成队列。CPU的资源无法很好的利用，导致性能下降。</p><p>怎么解决这个问题叻？</p><p>第一反应肯定是多线程，为我们每一个服务端访问建立一个独立的线程，这样一个线程的阻塞，其他的线程还可以运行，这样可以最大化的利用CPU的资源。</p><p>但是，即便我们使用了多线程，在一个服务器上的线程数量总是有限的，一样会出现阻塞后其他线程也调度不了的情况。</p><h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>上面我们已经分析了阻塞式IO会出现的问题，下面我们来看看非阻塞式IO又是怎么回事叻？</p><p>NIO的非阻塞模式提出了一个很核心的东西-选择器。</p><p>选择器会将客户端和服务端每一个传输数据的通道，都注册到选择器中。</p><p>选择器的作用就是监控这些通道的IO状况。也就是说当某一个通道上，某一个请求事件，完全准备就绪时，那么选择器才会将这个任务分配到服务端的一个或多个线程上再去运行。</p><p>也就是说你客户端的请求没有准备就绪时，你服务端的线程想干什么就干什么。（好比你在家等着收快递，快递没给你发短信，它还没有把快件给你准备好，你就一直在家等着）</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。</p><h3 id="一、为什么使用选择器？"><a href="#一、为什么使用选择器？" class="headerlink" title="一、为什么使用选择器？"></a>一、为什么使用选择器？</h3><p>Selector允许单线程处理多个 Channel。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。实际上我们可以使用选择器，只用一个线程处理所有的通道。</p><p>这是在一个单线程中使用一个Selector处理3个Channel的图示：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809215808.png" srcset="/img/loading.gif" alt=""></p><h3 id="二、如何使用选择器？"><a href="#二、如何使用选择器？" class="headerlink" title="二、如何使用选择器？"></a>二、如何使用选择器？</h3><p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector的创建，通过调用Selector.open()方法创建一个Selector，如下：</p><pre><code>Selector selector = Selector.open();</code></pre><h4 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h4><p>向Selector注册通道，为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p><pre><code>channel.configureBlocking(false);SelectionKey key = channel.register(selector,Selectionkey.OP_READ);</code></pre><p>注意：与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><pre><code>1.Connect2.Accept3.Read4.Write</code></pre><p>通道触发了一个事件意思是该事件已经就绪。</p><p>所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示：</p><pre><code>1.SelectionKey.OP_CONNECT2.SelectionKey.OP_ACCEPT3.SelectionKey.OP_READ4.SelectionKey.OP_WRITE</code></pre><p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p><pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></pre><h3 id="三、Selector-常用方法"><a href="#三、Selector-常用方法" class="headerlink" title="三、Selector 常用方法"></a>三、Selector 常用方法</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809190423.png" srcset="/img/loading.gif" alt=""></p><h3 id="四、SelectableChannle-的结构如下图："><a href="#四、SelectableChannle-的结构如下图：" class="headerlink" title="四、SelectableChannle 的结构如下图："></a>四、SelectableChannle 的结构如下图：</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809185431.png" srcset="/img/loading.gif" alt=""></p><h3 id="五、SelectionKey"><a href="#五、SelectionKey" class="headerlink" title="五、SelectionKey"></a>五、SelectionKey</h3><p>表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809185810.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809190323.png" srcset="/img/loading.gif" alt=""></p><h2 id="使用NIO完成网络通信的三个核心"><a href="#使用NIO完成网络通信的三个核心" class="headerlink" title="使用NIO完成网络通信的三个核心"></a>使用NIO完成网络通信的三个核心</h2><ol><li><p>通道（Channel）：负责连接。</p><pre><code>java.nio.channels.Channel 接口：  |--SelectableChannel    |--SocketChannel（TCP）    |--ServerSocketChannel（TCP）    |--DatagramChannel（UDP）    |--Pipe.SinkChannel    |--Pipe.SourceChannel</code></pre></li><li><p>缓冲区（Buffer）：负责数据的存取。</p></li><li><p>选择器（Selector）：是SelectableChannel 的多路复用器。用于监控SelectableChannel的IO状况。</p></li></ol><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p><p>操作步骤：</p><ul><li>打开 SocketChannel</li><li>读写数据</li><li>关闭 SocketChann</li></ul><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样.</p><h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p> Java NIO中的DatagramChannel是一个能收发UDP包的通道。</p><p> 操作步骤：</p><ul><li>打开 DatagramChannel</li><li>接收/发送数据</li></ul><h3 id="阻塞式IO演示"><a href="#阻塞式IO演示" class="headerlink" title="阻塞式IO演示"></a>阻塞式IO演示</h3><p>我们首先来看阻塞式的代码演示：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nio4</span> </span>&#123;    <span class="hljs-comment">// 客户端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        SocketChannel sChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9898</span>));        FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">"1.txt"</span>), StandardOpenOption.READ);        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-keyword">while</span> (inChannel.read(buf) != -<span class="hljs-number">1</span>) &#123;            buf.flip();            sChannel.write(buf);            buf.clear();        &#125;        <span class="hljs-comment">// 如果不shutdown，服务端就结束不了，因为它不知道客户端有没有发送数据</span>        sChannel.shutdownOutput();        <span class="hljs-comment">// 接收服务端的反馈</span>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-comment">// System.out.println(sChannel.read(buf));</span>        <span class="hljs-keyword">while</span> ((len = sChannel.read(buf)) != -<span class="hljs-number">1</span>) &#123;            buf.flip();            System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));            buf.clear();        &#125;        inChannel.close();        sChannel.close();    &#125;    <span class="hljs-comment">// 服务端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        ServerSocketChannel ssChannel = ServerSocketChannel.open();        FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">"2.txt"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);        ssChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        SocketChannel sChannel = ssChannel.accept();        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-keyword">while</span> (sChannel.read(buf) != -<span class="hljs-number">1</span>) &#123;            buf.flip();            outChannel.write(buf);            buf.clear();        &#125;        <span class="hljs-comment">//发送反馈给客户端</span>        buf.put(<span class="hljs-string">"服务端接收数据成功"</span>.getBytes());        buf.flip();<span class="hljs-comment">//给为读模式</span>        sChannel.write(buf);        sChannel.close();        outChannel.close();        ssChannel.close();    &#125;&#125;</code></pre><p>关键在于sChannel.shutdownOutput();否则线程一直处于阻塞状态。</p><h3 id="非阻塞IO演示"><a href="#非阻塞IO演示" class="headerlink" title="非阻塞IO演示"></a>非阻塞IO演示</h3><h4 id="SocketChannel-1"><a href="#SocketChannel-1" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p><pre><code class="hljs java"><span class="hljs-comment">// 客户端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//1.获取通道</span>        SocketChannel sChannel = SocketChannel.open(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9898</span>));        <span class="hljs-comment">//2.切换非阻塞模式</span>        sChannel.configureBlocking(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//3.分配指定大小的缓冲区</span>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-comment">// 4.发送数据给服务端</span>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (scanner.hasNext())&#123;            String str = scanner.next();            buf.put((LocalDateTime.now().toString() + <span class="hljs-string">"\n"</span> + str).getBytes());            buf.flip();            sChannel.write(buf);            buf.clear();        &#125;        buf.flip();        sChannel.write(buf);        buf.clear();        <span class="hljs-comment">// 5.关闭通道</span>        sChannel.close();    &#125;&#125;<span class="hljs-comment">// 服务端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">server</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//1.获取通道</span>        ServerSocketChannel ssChannel = ServerSocketChannel.open();        <span class="hljs-comment">//2.切换非阻塞式模式</span>        ssChannel.configureBlocking(<span class="hljs-keyword">false</span>);        <span class="hljs-comment">//3.绑定连接</span>        ssChannel.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        <span class="hljs-comment">//4.获取选择器</span>        Selector selector = Selector.open();        <span class="hljs-comment">//5.将通道注册到选择器上，并且指定“监听接收事件”</span>        ssChannel.register(selector, SelectionKey.OP_ACCEPT);        <span class="hljs-comment">//6.轮询式的获取选择器上已经“准备就绪”的事件</span>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//7.获取当前选择器中所有注册的“选择键（已就绪的监听事件）”</span>            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();            <span class="hljs-keyword">while</span> (it.hasNext()) &#123;                <span class="hljs-comment">//8.获取准备“就绪”的事件</span>                SelectionKey sk = it.next();                <span class="hljs-comment">//9.判断具体是什么事件准备就绪</span>                <span class="hljs-keyword">if</span> (sk.isAcceptable()) &#123;                    <span class="hljs-comment">//10.若“接收就绪”，获取客户端连接</span>                    SocketChannel sChannel = ssChannel.accept();                    <span class="hljs-comment">//11.切换非阻塞模式</span>                    sChannel.configureBlocking(<span class="hljs-keyword">false</span>);                    <span class="hljs-comment">//12.将该通道注册到选择器上</span>                    sChannel.register(selector, SelectionKey.OP_READ);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sk.isReadable()) &#123;                    <span class="hljs-comment">//13.获取当前选择器上“读就绪”状态的通道</span>                    SocketChannel sChannel = (SocketChannel) sk.channel();                    <span class="hljs-comment">//14.读取数据</span>                    ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="hljs-number">0</span>) &#123;                        buf.flip();                        System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, len));                        buf.clear();                    &#125;                &#125;                <span class="hljs-comment">//15.取消选择键SelectionKey</span>                it.remove();            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNonBlockingNIO4</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        DatagramChannel dc = DatagramChannel.open();        dc.configureBlocking(<span class="hljs-keyword">false</span>);        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (sc.hasNext()) &#123;            String str = sc.next();            buf.put((<span class="hljs-keyword">new</span> Date().toString() + <span class="hljs-string">":\n"</span> + str).getBytes());            buf.flip();            dc.send(buf, <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9898</span>));            buf.clear();        &#125;        dc.close();    &#125;    <span class="hljs-comment">//服务端</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        DatagramChannel dc = DatagramChannel.open();        dc.configureBlocking(<span class="hljs-keyword">false</span>);        dc.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9898</span>));        Selector selector = Selector.open();        dc.register(selector, SelectionKey.OP_READ);        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();            <span class="hljs-keyword">while</span> (it.hasNext()) &#123;                SelectionKey sk = it.next();                <span class="hljs-keyword">if</span> (sk.isReadable()) &#123;                    ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);                    dc.receive(buf);                    buf.flip();                    System.out.println(<span class="hljs-keyword">new</span> String(buf.array(), <span class="hljs-number">0</span>, buf.limit()));                    buf.clear();                &#125;            &#125;            it.remove();        &#125;    &#125;&#125;</code></pre><h3 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道 (Pipe)"></a>管道 (Pipe)</h3><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809191053.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPipe</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//1.获取管道 （等于两边有两个孔，一面是往外发，一面是往里接收）</span>        Pipe pipe = Pipe.open();        <span class="hljs-comment">//2.将缓冲区中的数据写入管道</span>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        Pipe.SinkChannel sinkChannel = pipe.sink();        buf.put(<span class="hljs-string">"通过单向通道发送数据"</span>.getBytes());        buf.flip();        sinkChannel.write(buf);        <span class="hljs-comment">//3.读取缓冲区中的数据</span>        Pipe.SourceChannel sourceChannel = pipe.source();        buf.flip();        <span class="hljs-keyword">int</span> len = sourceChannel.read(buf);        System.out.println(<span class="hljs-keyword">new</span> String(buf.array(),<span class="hljs-number">0</span>,len));        sourceChannel.close();        sinkChannel.close();    &#125;&#125;</code></pre><p>参考：<br><a href="http://ifeve.com/overview/" target="_blank" rel="noopener">http://ifeve.com/overview/</a></p><p>建议大家都可以系统的读一下这个译文。。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO（一）-标准输入输出</title>
    <link href="/cxlittlecute/429dd195.html"/>
    <url>/cxlittlecute/429dd195.html</url>
    
    <content type="html"><![CDATA[<h1 id="NIO（一）-标准输入输出"><a href="#NIO（一）-标准输入输出" class="headerlink" title="NIO（一）-标准输入输出"></a>NIO（一）-标准输入输出</h1><p>本篇文章主要是对NIO的一些知识点进行一个简单的总结回顾.</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java NIO（New IO或 Non Blocking IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p><p>在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO</p><h2 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h2><p>当然这是小伙伴们第一个想问的问题。</p><p>我们主要可以分为以下三点：</p><ul><li>面向对象对象不同。NIO面向块（buffer），IO面向流（Stream）。</li><li>模式不同。NIO有阻塞和非阻塞两种模式，IO只有阻塞模式。</li><li>选择器不同。NIO的选择器允许一个单独的线程来监视多个输入通道，但IO中没有选择器。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200808210334.png" srcset="/img/loading.gif" alt=""></p><h3 id="什么是面向缓冲区和面向流"><a href="#什么是面向缓冲区和面向流" class="headerlink" title="什么是面向缓冲区和面向流"></a>什么是面向缓冲区和面向流</h3><h4 id="对于IO"><a href="#对于IO" class="headerlink" title="对于IO"></a>对于IO</h4><p>原来我们操作IO的时候是面对里面字节数据的流动，好比自来水管道传输自来水一样。每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。</p><p>而且传统的IO是单向的，比如目标文件传输数据到程序中，需要建立输入流，相反我们想要把程序中的数据，传输到其他地方去也需要另外建立一个输出流的管道。</p><h4 id="对于NIO"><a href="#对于NIO" class="headerlink" title="对于NIO"></a>对于NIO</h4><p>和IO一样同样需要建立一个管道，但是我们称这个管道为[通道]。我们可以把这个通道理解为我们生活中的铁路，那么铁路能自己完成运输吗？当然不能，我们都知道铁路要想完成运输就必须要有火车。</p><p>这里的通道只是目标地点和原地点的连接。通道没有能力单独传输任何数据，在NIO中要想传输数据就要依赖于[缓冲区],这个缓冲区就可以类比于运货的火车，并且它是双向运输的，我们就可以利用缓冲区进行数据的存或者取。</p><h3 id="通道（Channel）与缓冲区（Buffer）"><a href="#通道（Channel）与缓冲区（Buffer）" class="headerlink" title="通道（Channel）与缓冲区（Buffer）"></a>通道（Channel）与缓冲区（Buffer）</h3><p>通过上面火车的描述，对通道和缓冲区已经有了一个认识了。NIO系统中通道和缓冲区就是两个核心。</p><p>简言之，通道负责传输，缓冲区负责运输。</p><p>通道负责打开IO的设备（文件、套接字）的连接。</p><p>缓冲区用于容纳数据。</p><p>我们可以通过操作缓冲区，对数据进行处理。</p><h2 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h2><p>接下来我们来详细讲解缓冲区这个概念和使用。</p><ul><li>缓冲区（Buffer）：一个用于特定[基本数据类型]的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</li><li>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。</li><li>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。</li></ul><h3 id="一、缓冲区的基本用法"><a href="#一、缓冲区的基本用法" class="headerlink" title="一、缓冲区的基本用法"></a>一、缓冲区的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤：</p><pre><code>1.写入数据到Buffer2.调用flip()方法3.从Buffer中读取数据4.调用clear()方法或者compact()方法</code></pre><p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p><h3 id="二、不同数据类型的缓冲区"><a href="#二、不同数据类型的缓冲区" class="headerlink" title="二、不同数据类型的缓冲区"></a>二、不同数据类型的缓冲区</h3><p>缓冲区在Nio中负责数据的存取。缓冲区就是数组。用于存储不同数据类型的数据（根据数据类型不同有对应类型的缓冲区）。</p><p>根据数据类型不同（boolean除外），提供了相应类型的缓冲区。</p><pre><code>* ByteBuffer（常用）* CharBuffer* ShortBuffer* IntBuffer* LongBuffer* FloatBuffer* DoubleBuffer</code></pre><p>上述缓冲区的管理方式几乎一致，通过allocate()获取缓冲区。</p><p>static XxxBuffer allocate(int capacity) : 创建一个容量为capacity 的 XxxBuffer 对象</p> <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.分配一个指定大小的缓冲区</span>    ByteBuffer buf= ByteBuffer.allocate(<span class="hljs-number">1024</span>);&#125;</code></pre><h3 id="三、缓冲区存取数据的两个核心方法："><a href="#三、缓冲区存取数据的两个核心方法：" class="headerlink" title="三、缓冲区存取数据的两个核心方法："></a>三、缓冲区存取数据的两个核心方法：</h3><ul><li>put()：存入数据到缓冲区中。</li><li>get()：获取缓冲区中的数据。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200808225446.png" srcset="/img/loading.gif" alt=""></p><h3 id="四、缓冲区中的四个核心属性："><a href="#四、缓冲区中的四个核心属性：" class="headerlink" title="四、缓冲区中的四个核心属性："></a>四、缓冲区中的四个核心属性：</h3><p>我们知道所有缓冲区都是 Buffer 抽象类的子类。Buffer类中有四个核心属性概念需要我们掌握：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buffer</span> </span>&#123;    <span class="hljs-comment">// Invariants:  mark &lt;= position &lt;= limit &lt;= capacity</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mark = -<span class="hljs-number">1</span>;    ......&#125;</code></pre><ul><li>容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。(数组的大小在初始化后是不可变的)</li><li>限制 (limit) ：第一个不应该读取或写入的数据的索引，即位于 [limit 后的数据不可读写]。缓冲区的限制不能为负，并且不能大于其容量。</li><li>位置 (position)：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制。</li><li>标记 (mark) 与重置 (reset) ：标记是一个索引，通过Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position(简单说就是记录当前position的位置)，之后可以通过调用 reset() 方法恢复到这个mark标记的位置。</li></ul><p>它们的规则就是:</p><pre><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity。</code></pre><h3 id="五、举例操作缓冲区"><a href="#五、举例操作缓冲区" class="headerlink" title="五、举例操作缓冲区"></a>五、举例操作缓冲区</h3><p>那么接下来我们分配、PUT、Get来查看这几个属性的变化情况。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    String str=<span class="hljs-string">"abcde"</span>;    <span class="hljs-comment">//1.分配一个指定大小的缓冲区</span>    ByteBuffer buf= ByteBuffer.allocate(<span class="hljs-number">1024</span>);    System.out.println(<span class="hljs-string">"--------------allocate()----------------"</span>);    System.out.println(buf.position());<span class="hljs-comment">//0</span>    System.out.println(buf.limit());<span class="hljs-comment">//1024</span>    System.out.println(buf.capacity());<span class="hljs-comment">//1024</span>    <span class="hljs-comment">//2.利用put()存放数据到缓冲区中.(Put有很多重载方法)</span>    buf.put(str.getBytes());    System.out.println(<span class="hljs-string">"-------------put（）-------------"</span>);    System.out.println(buf.position());<span class="hljs-comment">//5</span>    System.out.println(buf.limit());<span class="hljs-comment">//1024</span>    System.out.println(buf.capacity());<span class="hljs-comment">//1024</span>    <span class="hljs-comment">//3.切换读取数据模式</span>    buf.flip();    System.out.println(<span class="hljs-string">"--------------flip()------------"</span>);    System.out.println(buf.position());<span class="hljs-comment">//0</span>    System.out.println(buf.limit());<span class="hljs-comment">//5</span>    System.out.println(buf.capacity());<span class="hljs-comment">//1024</span>    <span class="hljs-comment">//4.利用get()读取缓冲区中的数据(等于用篮子去装)</span>    <span class="hljs-keyword">byte</span>[] dst=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.limit()];    buf.get(dst);    System.out.println(<span class="hljs-keyword">new</span> String(dst,<span class="hljs-number">0</span>,dst.length));<span class="hljs-comment">//abcd</span>    System.out.println(<span class="hljs-string">"--------------get()------------"</span>);    System.out.println(buf.position());<span class="hljs-comment">//5</span>    System.out.println(buf.limit());<span class="hljs-comment">//5</span>    System.out.println(buf.capacity());<span class="hljs-comment">//1024</span>    <span class="hljs-comment">//5.rewind():可重复读</span>    buf.rewind();    System.out.println(<span class="hljs-string">"--------------rewind()------------"</span>);    System.out.println(buf.position());<span class="hljs-comment">//0</span>    System.out.println(buf.limit());<span class="hljs-comment">//5</span>    System.out.println(buf.capacity());<span class="hljs-comment">//1024</span>    <span class="hljs-comment">//6.clear():清空缓冲区。但是缓冲区中的数据依然存在，但是处在“被遗忘”状态。（只是指针全部回到了最初的状态）</span>    buf.clear();    System.out.println(<span class="hljs-string">"--------------clear()------------"</span>);    System.out.println(buf.position());<span class="hljs-comment">//0</span>    System.out.println(buf.limit());<span class="hljs-comment">//1024</span>    System.out.println(buf.capacity());<span class="hljs-comment">//1024</span>    System.out.println((<span class="hljs-keyword">char</span>)buf.get());    <span class="hljs-comment">// 接着第6步我们可以查看clear后是否还有数据</span>    System.out.println((<span class="hljs-keyword">char</span>)buf.get()); <span class="hljs-comment">// a</span>&#125;</code></pre><p>mark、reset：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    String str=<span class="hljs-string">"abcde"</span>;    ByteBuffer buf=ByteBuffer.allocate(<span class="hljs-number">1024</span>);    buf.put(str.getBytes());    buf.flip();    <span class="hljs-keyword">byte</span>[] dst=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buf.limit()];    buf.get(dst,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);    System.out.println(<span class="hljs-keyword">new</span> String(dst,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>));<span class="hljs-comment">//ab</span>    System.out.println(buf.position());<span class="hljs-comment">//2</span>    <span class="hljs-comment">//mark():标记</span>    buf.mark();    buf.get(dst,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//再读两个位置</span>    System.out.println(<span class="hljs-keyword">new</span> String(dst, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<span class="hljs-comment">//cd</span>    System.out.println(buf.position());<span class="hljs-comment">//4</span>    <span class="hljs-comment">//reset():恢复到mark的位置</span>    buf.reset();    System.out.println(buf.position());<span class="hljs-comment">//2</span>    <span class="hljs-comment">//判断缓冲区中是否还有剩余数据</span>    <span class="hljs-keyword">if</span>(buf.hasRemaining())&#123;        <span class="hljs-comment">//获取缓冲区中可以操作的数量</span>        System.out.println(buf.remaining());<span class="hljs-comment">//3</span>    &#125;&#125;</code></pre><p>Buffer的常用方法：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200808225001.png" srcset="/img/loading.gif" alt=""></p><h3 id="六、说明方法区别"><a href="#六、说明方法区别" class="headerlink" title="六、说明方法区别"></a>六、说明方法区别</h3><pre><code>1. flip（）方法    flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。    也就是说你之前写了多少内容进去，你就能读多少出来。2. rewind（）方法    将position设回0，所以你可以重读Buffer中的所有数据。其他位置保持不变。3. clear（）方法    将位置设置为0，将limit设置为buffer的capacity，也就是这个buffer的容量。Buffer中的数据并未清除。4. compact（）方法    将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。    limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。5. equals()与compareTo()方法    可以使用equals()和compareTo()方法比较两个Buffer。    equals()方法:    当满足下列条件时，表示两个Buffer相等：    有相同的类型（byte、char、int等）。    Buffer中剩余的byte、char等的个数相等。    Buffer中所有剩余的byte、char等都相同。    注意：equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。    实际上，它只比较Buffer中的剩余元素。    compareTo()方法：    compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：    第一个不相等的元素小于另一个Buffer中对应的元素 。    所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</code></pre><h3 id="七、直接缓冲区和非直接缓冲区"><a href="#七、直接缓冲区和非直接缓冲区" class="headerlink" title="七、直接缓冲区和非直接缓冲区"></a>七、直接缓冲区和非直接缓冲区</h3><p>非直接缓冲区：通过allocate()方法分配缓冲区，将缓冲区建立在JVM的内存中。在每次调用基础操作系统的一个本机IO之前或者之后，虚拟机都会将缓冲区的内容复制到中间缓冲区（或者从中间缓冲区复制内容），缓冲区的内容驻留在JVM内，因此销毁容易，但是占用JVM内存开销，处理过程中有复制操作。</p><p>直接缓冲区：通过allocateDirect()方法分配直接缓冲区，将缓冲区建立物理内存中。可以提高效率。它会在JVM内存外开辟内存，在每次调用基础操作系统的一个本机IO之前或者之后，虚拟机都会避免将缓冲区的内容复制到中间缓冲区（或者从中间缓冲区复制内容），缓冲区的内容驻留在物理内存内，会少一次复制过程。（还可以通过FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建，在后面讲到）</p><p>我们可以画图来体会两个缓冲区的不同：</p><ul><li><p>非直接缓冲区：<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809075124.png" srcset="/img/loading.gif" alt=""></p></li><li><p>直接缓冲区区：<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809075156.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>我们可以看到非直接缓冲区，无论是read还是write操作的时候中间都会有一个copy的操作，这样是很耗费时间的。</p><p>而在直接缓冲区中，我们在用户、内核地址空间之间在物理内存中直接开辟了一个缓冲区，这个缓冲区直接建立在操作系统的物理内存上。等于说这个物理内存的缓冲区直接面对磁盘和应用程序。所以效率就高了。</p><p>当然直接缓冲区也有很大的弊端：</p><ul><li><p>消耗资源大。这样直接在物理内存开辟缓冲区，耗费消耗的资源大。</p></li><li><p>不易控制。并且当我们程序将数据写入物理内存映射文件后，这个文件的数据就不归我们管理了，什么时候写入磁盘就由操作系统去控制。由于不受控制，如果垃圾回收机制不及时回收，可能出现程序后停止的情况。</p></li></ul><p>优缺点对比：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809082037.png" srcset="/img/loading.gif" alt=""></p><p>什么时候选择直接缓冲区？</p><p>主要分配给那些易受基础系统本机 I/O 操作影响的大型、持久的缓冲区.一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们.</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//分配直接缓冲区</span>    ByteBuffer buf=ByteBuffer.allocate(<span class="hljs-number">1024</span>);    System.out.println(buf.isDirect());<span class="hljs-comment">//false</span>        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);    System.out.println(byteBuffer.isDirect()); <span class="hljs-comment">// true</span>&#125;</code></pre><h2 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h2><p>表示IO源节点与目标节点的连接。负责缓冲区中数据的传输，本身不存储任何数据，要配合缓冲区进行传输。</p><h3 id="一、通道的主要实现类"><a href="#一、通道的主要实现类" class="headerlink" title="一、通道的主要实现类"></a>一、通道的主要实现类</h3><p>通道在java.nio.channels.Channel接口下，主要实现类有以下几种：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809090415.png" srcset="/img/loading.gif" alt=""></p><h3 id="二、获取通道"><a href="#二、获取通道" class="headerlink" title="二、获取通道"></a>二、获取通道</h3><ol><li><p>Java支持通道的类提供了getChannel（）方法</p><pre><code>本地IO：    FileInputStream/FileOutputStream    RandomAccessFile网络IO：    Socket    ServerSocker    DatagramSocket</code></pre></li></ol><ol start="2"><li>在JDK 1.7 中的NIO.2 针对各个通道提供了静态方法 open（）</li><li>在JDK 1.7 中的NIO.2 的Files工具类的newByteChannel（）</li></ol><h3 id="三、通道的数据传输"><a href="#三、通道的数据传输" class="headerlink" title="三、通道的数据传输"></a>三、通道的数据传输</h3><ul><li><p>将 Buffer 中数据写入 Channel.</p><pre><code>int bytesWritten = inChannel.write(buf);</code></pre></li><li><p>从 Channel 读取数据到 Buffer.</p><pre><code>int bytesRead = inChannel.read(buf);</code></pre></li></ul><h3 id="四、通道之间的数据传输"><a href="#四、通道之间的数据传输" class="headerlink" title="四、通道之间的数据传输"></a>四、通道之间的数据传输</h3><pre><code>transferFrom（）transferTo（）</code></pre><h3 id="五、分散（Scatter）与聚集（Gather）"><a href="#五、分散（Scatter）与聚集（Gather）" class="headerlink" title="五、分散（Scatter）与聚集（Gather）"></a>五、分散（Scatter）与聚集（Gather）</h3><ul><li>分散读取（Scattering Reads）：将通道中的数据分散到多个缓冲区中。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809102843.png" srcset="/img/loading.gif" alt=""></p><p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。</p><ul><li>聚集写入（Gathering Writes）：将多个缓冲区中的数据聚集到通道中。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200809102957.png" srcset="/img/loading.gif" alt=""></p><p>注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到Channel 。</p><h3 id="六、字符集：Charset"><a href="#六、字符集：Charset" class="headerlink" title="六、字符集：Charset"></a>六、字符集：Charset</h3><p>编码：字符串-&gt;字节数组的过程。<br>解码：字节数组-&gt;字符串的过程。</p><h3 id="七、举例操作管道"><a href="#七、举例操作管道" class="headerlink" title="七、举例操作管道"></a>七、举例操作管道</h3><p>我们使用代码进行操作说明：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nio2</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-comment">//利用通道完成文件的复制(非直接缓冲区)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"1.txt"</span>);        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"2.txt"</span>);        <span class="hljs-comment">// 1. 获取通道</span>        FileChannel inChannel = fis.getChannel();        FileChannel outChannel = fos.getChannel();        <span class="hljs-comment">// 2. 分配指定大小的缓冲区</span>        ByteBuffer buf = ByteBuffer.allocate(<span class="hljs-number">1024</span>);        <span class="hljs-comment">// 3. 将通道中的数据存入缓冲区</span>        <span class="hljs-keyword">while</span> (inChannel.read(buf) != -<span class="hljs-number">1</span>) &#123;            buf.flip();<span class="hljs-comment">//切换读取数据的模式</span>            <span class="hljs-comment">//4.将缓冲区中的数据写入通道中</span>            outChannel.write(buf);            buf.clear();<span class="hljs-comment">//清空缓冲区</span>        &#125;        outChannel.close();        inChannel.close();        fos.close();        fis.close();    &#125;    <span class="hljs-comment">//使用直接缓冲区完成文件的复制(内存映射文件)</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">"1.txt"</span>), StandardOpenOption.READ);        FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">"2.txt"</span>), StandardOpenOption.WRITE,                StandardOpenOption.READ ,StandardOpenOption.CREATE);        <span class="hljs-comment">// 内存映射文件(只有byteBuffer支持)</span>        MappedByteBuffer inMappedBuf = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.size());        MappedByteBuffer outMappedBuf = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.size());        <span class="hljs-comment">// 直接对缓冲区进行数据的读写操作,之前的操作时通过通道去读写，现在的缓冲区直接在内存中，不需要通道</span>        <span class="hljs-keyword">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inMappedBuf.limit()];        inMappedBuf.get(dst);        outMappedBuf.put(dst);        inChannel.close();        outChannel.close();    &#125;    <span class="hljs-comment">// 通道之间的数据传输（直接缓冲区）</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">"1.txt"</span>), StandardOpenOption.READ);        FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">"2.txt"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);        inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);        outChannel.transferFrom(inChannel, <span class="hljs-number">0</span>, inChannel.size());        inChannel.close();        outChannel.close();    &#125;    <span class="hljs-comment">// 输出支持的字符集</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;        Map&lt;String,Charset&gt; map=Charset.availableCharsets();        Set&lt;Map.Entry&lt;String,Charset&gt;&gt; set=map.entrySet();        <span class="hljs-keyword">for</span>(Map.Entry&lt;String,Charset&gt; entry:set)&#123;            System.out.println(entry.getKey()+<span class="hljs-string">"="</span>+entry.getValue());        &#125;    &#125;    <span class="hljs-comment">// 字符集</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CharacterCodingException </span>&#123;        Charset cs1 = Charset.forName(<span class="hljs-string">"GBK"</span>);        <span class="hljs-comment">// 获取编码器</span>        CharsetEncoder ce = cs1.newEncoder();        <span class="hljs-comment">// 获取解码器</span>        CharsetDecoder cd = cs1.newDecoder();        <span class="hljs-comment">// 就是CharBuffer和byteBuffer的转换</span>        CharBuffer cBuf = CharBuffer.allocate(<span class="hljs-number">1024</span>);        cBuf.put(<span class="hljs-string">"冲Ali的OY"</span>);        cBuf.flip();        <span class="hljs-comment">// 编码</span>        ByteBuffer bBuf = ce.encode(cBuf);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            System.out.println(bBuf.get());        &#125;        <span class="hljs-comment">// 解码</span>        bBuf.flip();        CharBuffer cBuf2 = cd.decode(bBuf);        System.out.println(cBuf2.toString());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射问题总结</title>
    <link href="/cxlittlecute/ddf9c207.html"/>
    <url>/cxlittlecute/ddf9c207.html</url>
    
    <content type="html"><![CDATA[<h1 id="反射问题总结"><a href="#反射问题总结" class="headerlink" title="反射问题总结"></a>反射问题总结</h1><p>本文是对反射面试中出现的问题进行总结。</p><h2 id="除了使用new创建对象之外，还可以用什么方法创建对象？"><a href="#除了使用new创建对象之外，还可以用什么方法创建对象？" class="headerlink" title="除了使用new创建对象之外，还可以用什么方法创建对象？"></a>除了使用new创建对象之外，还可以用什么方法创建对象？</h2><ol><li>Class对象newIntance()方法。</li><li>Class对象生成构造器创建对象。</li><li>对象的反序列化。（readObject方法）</li><li>Object对象的clone()方法.(它的作用是创建一个对象的副本)</li></ol><h2 id="Java反射创建对象的效率高，还是操作通过new创建对象的效率高？"><a href="#Java反射创建对象的效率高，还是操作通过new创建对象的效率高？" class="headerlink" title="Java反射创建对象的效率高，还是操作通过new创建对象的效率高？"></a>Java反射创建对象的效率高，还是操作通过new创建对象的效率高？</h2><p>new创建对象的效率高，反射之所以慢,原因是:</p><ol><li>即时编译器(JIT)没法对相关代码进行优化。因为JIT会减少Java字节码再解析的操作。</li><li>反射需要进行参数校验。而直接调用某个方法，JVM已经知道了对象是什么要调哪个方法了，所以不用校验。</li><li>invoke 方法的参数是 Object[] 类型，调用过程中的封装与解封操作，会有额外的开销。</li></ol><h2 id="Java反射的作用？"><a href="#Java反射的作用？" class="headerlink" title="Java反射的作用？"></a>Java反射的作用？</h2><p>通过反射我们可以使程序代码访问已加载到JVM 中的类的内部信息。也就是说我们可以在运行时。</p><ol><li>判断任意一个对象所属的类</li><li>构造任意一个类的对象</li><li>判断任意一个类所具有的成员变量和方法</li><li>调用执行任意一个对象的方法</li></ol><h2 id="哪里会用到反射机制？"><a href="#哪里会用到反射机制？" class="headerlink" title="哪里会用到反射机制？"></a>哪里会用到反射机制？</h2><ol><li>经典的就是在xml文件或者properties里面写好了配置，然后在Java类里面解析xml或properties里面的内容。<br>得到一个字符串，然后用反射机制，根据这个字符串获得某个类的Class实例，这样就可以动态配置一些东西，不用每一次都要在代码里面去new或者做其他的事情。<br>以后要改的话直接改配置文件，代码维护起来就很方便了。<a href="http://ccctop.cn/cxlittlecute/7af799fd.html" target="_blank" rel="noopener">举例，如本文最后的列子。</a></li><li>总的来说，反射的目的就是为了扩展未知的应用，比如你写了一个程序，这个程序定义了一些接口，只要实现了这些接口的dll都可以作为插件来插入到这个程序中。那么怎么实现呢？就可以通过反射来实现。就是把dll加载进内存，然后通过反射的方式来调用dll中的方法。很多工厂模式就是使用的反射。 </li></ol><h2 id="反射的实现方式？"><a href="#反射的实现方式？" class="headerlink" title="反射的实现方式？"></a>反射的实现方式？</h2><p>第一种：通过Object类的getClass方法。<br>第二种：通过对象实例方法获取对象。<br>第三种：通过Class.forName方式。</p><h2 id="实现Java反射的类有哪些？"><a href="#实现Java反射的类有哪些？" class="headerlink" title="实现Java反射的类有哪些？"></a>实现Java反射的类有哪些？</h2><pre><code>java.lang.Class ：一个类java.lang.reflect.Field ：类的成员变量(属性)java.lang.reflect.Method ：类的成员方法java.lang.reflect.Constructor ：类的构造方法java.lang.reflect.Array ：提供了静态方法动态创建数组，访问数组的元素</code></pre><h2 id="反射机制的优缺点？"><a href="#反射机制的优缺点？" class="headerlink" title="反射机制的优缺点？"></a>反射机制的优缺点？</h2><p>优点：</p><ol><li><p>增加程序的灵活性，避免将代码写死在程序中。（建议：都去实现读取文件模拟框架的配置文件读取）.</p></li><li><p>代码简洁，提高代码的复用率，外部调用方便.</p></li><li><p>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法.</p></li></ol><p>缺点：</p><ol><li>性能问题.使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码.它包含一些动态类型，JIT无法对其进行优化。</li><li>使用反射会模糊程序内部逻辑。</li><li>安全限制，使用反射技术要求程序必须在一个没有安全限制的环境中运行。</li></ol><p>参考：<br><a href="https://blog.csdn.net/zhupanlinch/article/details/103004406" target="_blank" rel="noopener">https://blog.csdn.net/zhupanlinch/article/details/103004406</a><br><a href="https://blog.csdn.net/qq_36470686/article/details/85015753" target="_blank" rel="noopener">https://blog.csdn.net/qq_36470686/article/details/85015753</a></p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/cxlittlecute/7af799fd.html"/>
    <url>/cxlittlecute/7af799fd.html</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>反射就是把java类中的各种成分映射成一个个的Java对象.</p><p>用法没有什么好介绍的，我们需要注意的是一个类在被加载后，只会有一个Class对象，类的整个结构信息都保存在这个Class对象中。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在Object类中定了如下的方法,此方法被所有子类继承：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Class <span class="hljs-title">getClass</span><span class="hljs-params">()</span></span></code></pre><p>这个方法的返回值，是一个Class类，这个类就是Java反射的源头。</p><p>所以我们可以根据对象的反射求出类的名称。（反射可以理解为对象照镜子）</p><p>对于Class类我们需要知道：</p><ul><li>Class本身也是一个类。</li><li>一个JVM只会加载一个Class实例。</li><li>Class对象只能由系统建立对象。</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件。</li><li>通过Class对象我们可以得到一个类的所有被加载的结构。</li><li>每个类的实例都会记得自己是由哪个Class实例所创建的。</li></ul><h4 id="Class类的常用方法："><a href="#Class类的常用方法：" class="headerlink" title="Class类的常用方法："></a>Class类的常用方法：</h4><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806192138.png" srcset="/img/loading.gif" alt=""></p><h4 id="获取Class类的实例："><a href="#获取Class类的实例：" class="headerlink" title="获取Class类的实例："></a>获取Class类的实例：</h4><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806192506.png" srcset="/img/loading.gif" alt=""></p><h4 id="内存分析："><a href="#内存分析：" class="headerlink" title="内存分析："></a>内存分析：</h4><p>通过JVM分析我们可以更好的了解Class对象。</p><h5 id="类的加载过程："><a href="#类的加载过程：" class="headerlink" title="类的加载过程："></a>类的加载过程：</h5><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806193925.png" srcset="/img/loading.gif" alt=""></p><h5 id="类的加载与ClassLoader的理解："><a href="#类的加载与ClassLoader的理解：" class="headerlink" title="类的加载与ClassLoader的理解："></a>类的加载与ClassLoader的理解：</h5><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806194218.png" srcset="/img/loading.gif" alt=""></p><p>Class对象是加载进内存才有的，所以说我们不能够主动创建，只能够获取。</p><p>我们用以下的代码分析一下这个过程：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        System.out.println(A.m);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">"A类静态代码块初始化"</span>);        m = <span class="hljs-number">300</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">100</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A类的无参构造初始化"</span>);    &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806200502.png" srcset="/img/loading.gif" alt=""></p><ol><li>我们首先会将类的class文件加载进内存中,也就是我们方法去的静态数据。</li><li>生成一个代表这个类的class对象。</li><li>Class对象形成后，我们准备执行Main方法，根据链接中的准备我们知道m是静态变量，会产生默认为0的值。</li><li>接着执行我们的new A（），这里就会产生一个新的A对象，这个对象会指向A类的class，就能拿到class的数据，然后我们通过这些数据就可以对A类进行显示赋值，开始初始化。</li><li>在初始化过程中A就执行了<clinit>方法，将我们静态代码块和静态代码初始合并了。</li></ol><p>简单表示为:</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806201733.png" srcset="/img/loading.gif" alt=""></p><h4 id="什么时候会发生类的初始化"><a href="#什么时候会发生类的初始化" class="headerlink" title="什么时候会发生类的初始化?"></a>什么时候会发生类的初始化?</h4><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806204557.png" srcset="/img/loading.gif" alt=""></p><h4 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h4><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806212252.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806212545.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806213527.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获取系统类的加载器</span>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        <span class="hljs-comment">// 获取系统类加载器的父类加载器-&gt;扩展类加载器</span>        ClassLoader parent = systemClassLoader.getParent();        System.out.println(parent);        <span class="hljs-comment">// 获取扩展类加载器的父类加载器-&gt;根加载器(c/c++编写的)</span>        ClassLoader parent1 = parent.getParent();        System.out.println(parent1); <span class="hljs-comment">// 获取不到为null</span>        <span class="hljs-comment">// 如何获取系统类加载器可以加载的路径</span>        String property = System.getProperty(<span class="hljs-string">"java.class.path"</span>);        System.out.println(property);    &#125;&#125;</code></pre><p>输出结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806214530.png" srcset="/img/loading.gif" alt=""></p><p>讲到了这里就必要要聊一下双亲委派机制：</p><p>双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。</p><h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200806215253.png" srcset="/img/loading.gif" alt=""></p><p>这里就不用代码演示这些获取的方法了，都是getXxx(),但是区别在于，只有getXxx（）获取的是该类的公开属性或方法和父类的公开属性或方法，getDeclaredXxx（）获取的是该类的所有属性或方法。</p><h2 id="这里我们需要思考有了class对象我们能做什么？"><a href="#这里我们需要思考有了class对象我们能做什么？" class="headerlink" title="这里我们需要思考有了class对象我们能做什么？"></a>这里我们需要思考有了class对象我们能做什么？</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807090855.png" srcset="/img/loading.gif" alt=""></p><p>newInstance()调用的是类的无参构造器。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>难道我们没有无参的构造器就不能进行对象的创建吗？</p><p>当然不是，只要在操作的时候明确的调用类中的构造器,并将参数传递进去之后，就可以实例化操作。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807091928.png" srcset="/img/loading.gif" alt=""></p><h2 id="调用指定的方法"><a href="#调用指定的方法" class="headerlink" title="调用指定的方法"></a>调用指定的方法</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807095448.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807095549.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;        <span class="hljs-comment">// 获取Class对象</span>        Class c1 = Class.forName(<span class="hljs-string">"User"</span>);        <span class="hljs-comment">// 构建一个对象</span>        User user = (User) c1.newInstance();<span class="hljs-comment">// 本质上是调用了类的无参构造器</span>        System.out.println(user);        <span class="hljs-comment">// 通过构造器创建对象</span>        Constructor declaredConstructor = c1.getDeclaredConstructor(Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">String</span>.<span class="hljs-title">class</span>)</span>;        User user2 = (User) declaredConstructor.newInstance(<span class="hljs-number">12</span>, <span class="hljs-string">"OY"</span>);        System.out.println(user2);        <span class="hljs-comment">// 通过反射调用普通方法</span>        User user3 = (User) c1.newInstance();        Method setName = c1.getDeclaredMethod(<span class="hljs-string">"setName"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// invoke：激活 (对象，"方法的值")</span>        setName.invoke(user3, <span class="hljs-string">"OY"</span>);        System.out.println(user3);        <span class="hljs-comment">// 通过反射操作属性</span>        User user4 = (User) c1.newInstance();        user4.setName(<span class="hljs-string">"xxx"</span>);        Field name = c1.getDeclaredField(<span class="hljs-string">"name"</span>);        <span class="hljs-comment">// name是私有属性，不行直接操作，我们需要关闭程序的安全监测，属性或者方法的setAccessible(true)</span>        name.setAccessible(<span class="hljs-keyword">true</span>);        name.set(user4, <span class="hljs-string">"OY4"</span>);        System.out.println(user4.getName());        <span class="hljs-comment">// 调用静态方法</span>        Method test = c1.getDeclaredMethod(<span class="hljs-string">"test"</span>);        test.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><h3 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807100209.png" srcset="/img/loading.gif" alt=""></p><h3 id="操作泛型"><a href="#操作泛型" class="headerlink" title="操作泛型"></a>操作泛型</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807102058.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<span class="hljs-keyword">import</span> java.lang.reflect.Type;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo10</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span> <span class="hljs-params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;        System.out.println(<span class="hljs-string">"test01"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, User&gt; <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"test02"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;        Method method = Demo10.class.getMethod("test01",Map.class,List.class);        Type[] genericParameterTypes= method.getGenericParameterTypes();        <span class="hljs-keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;            System.out.println(<span class="hljs-string">"参数范型"</span>+genericParameterType);            <span class="hljs-keyword">if</span> (genericParameterType <span class="hljs-keyword">instanceof</span> ParameterizedType)&#123;                Type[] actualTypeAnguments=((ParameterizedType)(ParameterizedType) genericParameterType).getActualTypeArguments();                <span class="hljs-keyword">for</span> (Type actualTypeAngument : actualTypeAnguments) &#123;                    System.out.println(<span class="hljs-string">"实际参数范型"</span>+actualTypeAngument);                &#125;            &#125;        &#125;        Method method1 = Demo10.class.getMethod("test02",null);        Type getGenericReturnType= method1.getGenericReturnType();        <span class="hljs-keyword">if</span> (getGenericReturnType <span class="hljs-keyword">instanceof</span>  ParameterizedType) &#123;            Type[] actualTypeArguments = ((ParameterizedType) getGenericReturnType).getActualTypeArguments();            <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;                System.out.println(<span class="hljs-string">"返回值范型"</span> + actualTypeArgument);            &#125;        &#125;    &#125;&#125;</code></pre><p>运行结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200807104903.png" srcset="/img/loading.gif" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结一下：</p><h4 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h4><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li><li>在运行时通过反射越过泛型检查</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：<br>　　反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类<br>缺点：<br>　　（1）性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用。<br>　　2）使用反射会模糊程序内内部逻辑：程序员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><ol><li>我们首先需要获取一个类的Class对象，有三种饭方式。</li><li>接着我们需要创建目标类的实例对象，有两种方式一种是有参构造器，另一种是无参构造器。</li><li>然后我们可以通过class对象获取属性对象和方法对象，然后进行操作。</li></ol><p>最后我们通过一个简单的案例，更好的了解反射为什么有很好的扩展性：<br>需求：在不改变类任何代码的情况下，创建任意类的对象，并且执行其中任意方法。</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 实现：</span><span class="hljs-comment"> * 1.配置文件</span><span class="hljs-comment"> * 2. 反射</span><span class="hljs-comment"> * 步骤：</span><span class="hljs-comment"> * 1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中</span><span class="hljs-comment"> * 2.在程序中加载读取配置文件</span><span class="hljs-comment"> * 3.使用反射来加载类文件进内存</span><span class="hljs-comment"> * 4.创建对象</span><span class="hljs-comment"> * 5.执行方法</span><span class="hljs-comment"> * */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 1. 加载配置文件</span>        <span class="hljs-comment">// 1.1 创建properties对象</span>        Properties pro = <span class="hljs-keyword">new</span> Properties();        <span class="hljs-comment">// 1.2 加载配置文件，转换为一个集合</span>        <span class="hljs-comment">// 1.2.1 获取class目录下的配置文件(通过类加载器完成) 类加载器可以找到类路径下的class文件和配置文件</span>        ClassLoader classLoader = ReflectTest<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;        InputStream is = classLoader.getResourceAsStream(<span class="hljs-string">"pro.properties"</span>);        pro.load(is); <span class="hljs-comment">// 装载为键值对形式</span>        <span class="hljs-comment">// 2. 获取配置文件中定义的数据</span>        String className = pro.getProperty(<span class="hljs-string">"className"</span>);        String methodName = pro.getProperty(<span class="hljs-string">"methodName"</span>);        String name = pro.getProperty(<span class="hljs-string">"name"</span>);        <span class="hljs-comment">// 3. 加载该类进内存</span>        Class cls = Class.forName(className);        <span class="hljs-comment">// 4. 创建对象</span>        Object o = cls.newInstance();        <span class="hljs-comment">// 5. 获取方法对象</span>        Method method = cls.getMethod(methodName,String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 6.执行方法</span>        method.invoke(o,name);    &#125;&#125;</code></pre><p>properties:</p><pre><code class="hljs properties"><span class="hljs-attr">className</span>=<span class="hljs-string">User</span><span class="hljs-attr">methodName</span>=<span class="hljs-string">test</span><span class="hljs-attr">name</span>=<span class="hljs-string">12</span></code></pre><p>参考：<br><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=1" target="_blank" rel="noopener">狂神说</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍类型问题总结</title>
    <link href="/cxlittlecute/3787d48.html"/>
    <url>/cxlittlecute/3787d48.html</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍类型问题总结"><a href="#打家劫舍类型问题总结" class="headerlink" title="打家劫舍类型问题总结"></a>打家劫舍类型问题总结</h1><p>这是刷力扣刷到的一类题型，通过本篇文章做进一步的思考和方法的总结。</p><p>力扣关于这个题型总共分为三道：<br><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a><br><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍 II</a><br><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></p><h2 id="动态规划问题分析"><a href="#动态规划问题分析" class="headerlink" title="动态规划问题分析"></a>动态规划问题分析</h2><p>这一类问题可以归属于动态规划。动态规划的一般形式就是让你求最值。它是运筹学的一种最优化方法。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>关于动态规划问题我们首先要了解以下几个概念：</p><ol><li><p>最优子结构：<br>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。也可以理解为后面阶段的状态可以通过前面状态推导出来。</p></li><li><p>无后效性：<br>某阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。也就是所谓的“未来与过去无关”。</p></li><li><p>重复子问题：<br>动态规划中将问题分为一个或多个子问题，少量子问题可能会被重复执行很多次。</p></li><li><p>状态转移方程：<br>状态转移方程，是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。</p></li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>解决动态规划问题我们可以用到<strong>穷举</strong>，也就是我们可以把所有要发生的情况列举出来，然后找到最值。</p><p>很明显我们不可能通过穷举来实际解决这一类问题,因为这类问题有[重复子问题]存在，因为效率太低下，那么为了优化这个穷举的过程我们引入：</p><ul><li>备忘录</li><li>DP table</li></ul><p>通过这两种方式避免不必要的计算。</p><p>动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。同时我们只有列出正确的「状态转移方程」才能正确地穷举。</p><p>所以重叠子问题、最优子结构、状态转移方程就是动态规划三要素。其中转移方程的编写是最困难的。</p><p>编写状态转移方程的思维框架：</p><p>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义。</p><pre><code class="hljs java"><span class="hljs-comment">// 初始化base case</span>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = base<span class="hljs-comment">// 进行状态转移</span><span class="hljs-keyword">for</span> (状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值)    <span class="hljs-keyword">for</span> (状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值)        <span class="hljs-keyword">for</span> ...            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 求最值(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2</span>...)</code></pre><p>确定「状态」，也就是原问题和子问题中会变化的变量。<br>确定「选择」，也就是导致「状态」产生变化的行为。</p><h4 id="带备忘录的递归解法"><a href="#带备忘录的递归解法" class="headerlink" title="带备忘录的递归解法"></a>带备忘录的递归解法</h4><p>我们知道了动态规划问题会出现重叠子问题发生，那么我们就可以通过备忘录去解决这个问题，这种方法是自顶向下递归的思路。</p><p>那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><h4 id="dp-数组的迭代解法"><a href="#dp-数组的迭代解法" class="headerlink" title="dp 数组的迭代解法"></a>dp 数组的迭代解法</h4><p>其实这个方法和上面带备忘录的递归解法，只是反过来算了而已，备忘录的方法只是自顶向下，而dp数组是自底向上，从规模最小的问题开始向上推，这也就是动态规划摆脱递归，由循环迭代完成的思路。</p><p>并且通过转移方程我们可以发现当前状态只和之前的两个状态有关，并不需要一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了，这样就可以优化dp数组的迭代过程。这个技巧称为状态压缩。</p><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>自底向上：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> length = nums.length;        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; length; i++) &#123;            dp[i] = Math.max(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[length - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre><p>自底向上状态压缩：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> length = nums.length;        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">int</span> first = nums[<span class="hljs-number">0</span>], second = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">int</span> temp = second;            second = Math.max(first + nums[i], second);            first = temp;        &#125;        <span class="hljs-keyword">return</span> second;    &#125;&#125;</code></pre><p>自顶向上：</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-comment">// dp[i] = x 表示：</span>    <span class="hljs-comment">// 从第 i 间房子开始抢劫，最多能抢到的钱为 x</span>    <span class="hljs-comment">// base case: dp[n] = 0</span>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        dp[i] = Math.max(dp[i + <span class="hljs-number">1</span>], nums[i] + dp[i + <span class="hljs-number">2</span>]);    &#125;    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];&#125;</code></pre><p>自顶向上状态压缩：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = nums.length;    <span class="hljs-comment">// 记录 dp[i+1] 和 dp[i+2]</span>    <span class="hljs-keyword">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录 dp[i]</span>    <span class="hljs-keyword">int</span> dp_i = <span class="hljs-number">0</span>;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);        dp_i_2 = dp_i_1;        dp_i_1 = dp_i;    &#125;    <span class="hljs-keyword">return</span> dp_i;&#125;</code></pre><h2 id="打家劫舍-Ⅱ"><a href="#打家劫舍-Ⅱ" class="headerlink" title="打家劫舍 Ⅱ"></a>打家劫舍 Ⅱ</h2><p>这个题就等于一个环形排列，我们可以把它分为两个单排列。</p><p>首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。</p><p>不过，其实我们不需要比较三种情况，只要比较情况二和情况三就行了，因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] nums1 = Arrays.copyOfRange(nums, <span class="hljs-number">1</span>, nums.length);        <span class="hljs-keyword">int</span>[] nums2 = Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> Math.max(subrob(nums1), subrob(nums2));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subrob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);        &#125;        <span class="hljs-keyword">return</span> dp[len - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre><p>优化：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> Math.max(myRob(Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>)),                         myRob(Arrays.copyOfRange(nums, <span class="hljs-number">1</span>, nums.length)));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myRob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>, tmp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums) &#123;            tmp = cur;            cur = Math.max(pre + num, cur);            pre = tmp;        &#125;        <span class="hljs-keyword">return</span> cur;    &#125;&#125;</code></pre><p>关于题目细节的分析：<br>参考以下这篇文章：<br><a href="https://leetcode-cn.com/problems/house-robber-ii/solution/tong-yong-si-lu-tuan-mie-da-jia-jie-she-wen-ti-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-ii/solution/tong-yong-si-lu-tuan-mie-da-jia-jie-she-wen-ti-by-/</a></p><p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot整合ES</title>
    <link href="/cxlittlecute/1b871313.html"/>
    <url>/cxlittlecute/1b871313.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot整合ES"><a href="#Springboot整合ES" class="headerlink" title="Springboot整合ES"></a>Springboot整合ES</h1><h2 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h2><p>Java 操作 ES 的两种方式：<br>1）、9300：TCP (我们不在9300操作，官方也不建议)</p><ul><li><p>spring-data-elasticsearch:transport-api.jar;</p><ul><li>springboot 版本不同，transport-api.jar不同，不能适配es版本</li><li>7.x 已经不建议使用，8 以后就要废弃<br>2、9200：HTTP（推荐使用）</li></ul></li><li><p>JestClient：非官方，更新慢</p></li><li><p>RestTemplate：模拟发 HTTP 请求，ES 很多操作需要自己封装，麻烦</p></li><li><p>HttpClient：同上</p></li><li><p>Elasticsearch-Rest-Client：官方 RestClient，封装了 ES 操作，API 层次分明，上手简单最终选择</p><ul><li>Elasticsearch-Rest-Client(elasticsearch-rest-high-level-client)</li></ul></li></ul><h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><ol><li>创建项目。（注意我们使用idea创建项目的时候，可以选择Spring data Elasticsearch但是它支持的版本过低，所以一般不会勾选）</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804221100.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li><p>查看官网API  <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html" target="_blank" rel="noopener">Java REST Client</a>。</p></li><li><p>High Level对请求进行了更深层的封装。</p></li><li><p>导入Jar包依赖。（注意我们的springboot依赖中有ES的版本控制，如果发现下载ES的Jar包失败，请先删除文件夹中的内容，然后在properites中设置版本，重新下载）</p></li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804221549.png" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>编写配置，给容器中注入一个RestHighLevelClient。</li></ol><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ESconfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestHighLevelClient <span class="hljs-title">esRestHighLevelClient</span><span class="hljs-params">()</span> </span>&#123;        RestHighLevelClient client = <span class="hljs-keyword">new</span> RestHighLevelClient(                <span class="hljs-comment">// 这里可以配置多个 es服务，我当前服务不是集群，所以目前只配置一个</span>                RestClient.builder(                        <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"你的IP地址"</span>, <span class="hljs-number">9200</span>, <span class="hljs-string">"http"</span>)));        <span class="hljs-keyword">return</span> client;    &#125;&#125;</code></pre><ol start="6"><li>我们就可以通过注入RestHighLevelClient进行测试了。</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol><li>在ESconfig中配置设置请求头信息的代码块，现在没有认证就把认证注解了。</li></ol><pre><code class="hljs shell">    public static final RequestOptions COMMON_OPTIONS;    static &#123;        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();        // 这里先注释掉，目前没有用到，后边用到了再解释//        builder.addHeader("Authorization", "Bearer " + TOKEN);//        builder.setHttpAsyncResponseConsumerFactory(//                new HttpAsyncResponseConsumerFactory//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));        COMMON_OPTIONS = builder.build();    &#125;</code></pre><ol start="2"><li>操作的方式。（方式有很多种，选择两种进行测试）<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-low-usage-requests.html#java-rest-low-usage-request-options" target="_blank" rel="noopener">参照官方文档</a></li></ol><pre><code class="hljs shell">    /*    *测试存储数据    * */    @Test    public void indexData() throws IOException &#123;/*        IndexRequest indexRequest = new IndexRequest("users");        indexRequest.id("1");        indexRequest.source("userName","zhangsan","age",18,"gender","男");*/        // 第二种方式（推荐使用）        IndexRequest indexRequest = new IndexRequest("users");        User user = new User();        user.setUserName("zhangsan");        user.setAge(18);        user.setGender("男");        String jsonString = JSON.toJSONString(user);        indexRequest.source(jsonString, XContentType.JSON); //要保存的内容        // 执行操作        IndexResponse index = client.index(indexRequest, ESconfig.COMMON_OPTIONS);        // 提取有用的数据相应        System.out.println(index);    &#125;</code></pre><p>最后，查询到数据。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200805070549.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Swarm</title>
    <link href="/cxlittlecute/656e6847.html"/>
    <url>/cxlittlecute/656e6847.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Swarm 是 Docker 官方提供的一款集群管理工具，其主要作用是把若干台 Docker 主机抽象为一个整体，并且通过一个入口统一管理这些 Docker 主机上的各种 Docker 资源。</p><p>Swarm 和 Kubernetes 比较类似，但是更加轻，具有的功能也较 kubernetes 更少一些。</p><p>Docker Swarm 包含两方面：一个企业级的 Docker 安全集群，以及一个微服务应用编排引擎。</p><p>集群方面，Swarm 将一个或多个 Docker 节点组织起来，使得用户能够以集群方式管理它们。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Swarm的搭建需要有管理结点和工作结点。</p><p>管理结点和管理结点间可以互相通信，同时管理结点也可以控制工作结点。但是工作结点无法控制管理结点，他们的单向的连线。</p><p>我们的操作都在manager上。Raft是一致性算法。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804144828.png" srcset="/img/loading.gif" alt=""></p><h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>我们需要首先购买多台服务器。并且都安装上docker。<a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener">Docker安装</a>。</p><ol><li>我们在未搭建集群前，我们docker中的网络是很干净的。</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804145135.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>接着我们查看docker swarm的命令：</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804145214.png" srcset="/img/loading.gif" alt=""></p><p>上面的命令操作可以简单的理解为：在集群中进行增删改查。</p><ol start="3"><li>我们首先要初始化一个Swarm。</li></ol><p>我们查看docker swarm init –help的用法。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804145521.png" srcset="/img/loading.gif" alt=""></p><p>在这里我们需要配置一个地址，我们可以走私网也可以走公网，因为我们购买的服务器在同一网段，所以服务器属于同一局域网，私网是可以互相ping通的，用私网的话，不会有流量的消耗（节约钱）。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804145759.png" srcset="/img/loading.gif" alt=""></p><ol start="4"><li>初始化成功后，会有如下的提示。</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804145945.png" srcset="/img/loading.gif" alt=""></p><p>它提示我们刚才的地址已经加入到swarm中，当前它是一个manager。</p><ul><li>我们可以使用方框中的命令让其他节点加入进来。</li></ul><p>同时下面也提供了另外一种方式让我们获取生成manager或worker的令牌。</p><pre><code class="hljs shell">docker swarm join-token managerdocker swarm join-token worker</code></pre><p>这样我们可以在leader结点上执行这两个命令，它会分别生成对应命令，让其他节点成为manager或者worker。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804150808.png" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>我们可以通过docker node ls查看结点情况,有一个manager和worker（没有显示的就是worker结点）：</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804150808.png" srcset="/img/loading.gif" alt=""></p><h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p>它的意思就是保证我们大多数结点存活才可以用。</p><p>它的高可用保证必须要&gt;1台机器可以用。比如两主两从挂了一台就不行。同时重新启动会让另一个主机变为leader。</p><h2 id="Swam集群弹性创建服务"><a href="#Swam集群弹性创建服务" class="headerlink" title="Swam集群弹性创建服务"></a>Swam集群弹性创建服务</h2><p>我们要认识到容器脱掉了编排没有任何意义，由于我们搭建了swam也就是一个集群结点，我们的所有东西都变为了服务。</p><p>容器-&gt;服务。</p><pre><code class="hljs shell">docker run 容器启动，不具备扩缩容器的功能docker service 服务，具有扩缩容器的功能，滚动更新</code></pre><p>举例说明，假如某应用有一个 Web 前端服务，该服务有相应的镜像。测试表明对于正常的流量来说 5 个实例可以应对。那么就可以将这一需求转换为一个服务，该服务声明了容器使用的镜像，并且服务应该总是有 5 个运行中的副本。</p><p>使用 docker service create 命令创建一个新的服务。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804154657.png" srcset="/img/loading.gif" alt=""></p><p>我们可以看到我们的服务中只有一个副本，假设业务呈爆发式增长，我们就可以进行服务的扩缩容：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 给我们图中的my-nginx服务创建副本</span>docker service update --replicas 3 my-nginx或docker servoce scale my-nginx=3</code></pre><p>集群就是一个整体，这个整体中有很多服务器，服务器中运行着各种的容器，但是对于用户来说，它把这个集群看成一个服务，集群里可以随时的进行扩缩容.</p><p>只要是服务，它可以在集群中任意结点进行访问。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804155340.png" srcset="/img/loading.gif" alt=""></p><h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><h4 id="swarm"><a href="#swarm" class="headerlink" title="swarm"></a>swarm</h4><p>简单的说就是进行集群的管理和编码，docker可以初始化一个swarm集群，让其他节点可以加入。（管理、工作者）</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node就是一个docker结点，多个结点就组成了一个网络集群。管理者就是我们的swarm。</p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>服务，可以在我们的管理结点和工作结点运行。是docker集群的核心。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804160242.png" srcset="/img/loading.gif" alt=""></p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>容器内的命令，细节任务。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804160130.png" srcset="/img/loading.gif" alt=""></p><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200804160526.png" srcset="/img/loading.gif" alt=""></p><p>命令-&gt;管理-api-&gt;调度-&gt;工作结点(创建Task容器维护创建)</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Compose</title>
    <link href="/cxlittlecute/60641507.html"/>
    <url>/cxlittlecute/60641507.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>之前我们使用docker的时候，需要使用docker build命令去构建dockerfile,然后通过docker run去执行容器。</p><p>这些我们都是一步步的手动操作，而且这只是单个容器。</p><p>如果，我们的微服务很多，按照之前的流程肯定是很麻烦的。而且服务之间可能也存在依赖关系。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Compose是用于定义和运行多容器Docker应用程序的工具。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>Dockerfile保证我们的项目可以在任何地方运行。</p></li><li><p>定义一个服务将我们的应用程序写入docker-compose.yml中，这样我们可以在单独的环境中把程序运行起来。</p></li><li><p>启动项目。</p></li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803154636.png" srcset="/img/loading.gif" alt=""></p><p>阅读了官方文档，我们可以提出以下几个问题：</p><ol><li>如何定义、运行多个容器。</li><li>YAML配置文件如何编写。</li><li>single command命令有哪些。</li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>根据你自己写的配置文件，进行容器编排。</p><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>我们需要认识到的是，docker compose不是docker内置的东西，而是docker官方的开源项目。我们需要安装。</p><p>dockerfile让程序可以在任何地方运行。也就是让运维和部署简化了。如果我们要启动很多容器，一步步的去做事很浪费时间的。</p><p>那么compose可以像这样编写yaml的配置文件实现这个操作：</p><p>这是官网的yaml文件样例：</p><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'2.0'</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">web:</span>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>    <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">"5000:5000"</span>    <span class="hljs-attr">volumes:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">.:/code</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">logvolume01:/var/log</span>    <span class="hljs-attr">links:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><span class="hljs-attr">volumes:</span>  <span class="hljs-attr">logvolume01:</span> <span class="hljs-string">&#123;&#125;</span></code></pre><p>最后我们通过docker compose up一键上线这些服务。</p><h2 id="Compose中的重要概念"><a href="#Compose中的重要概念" class="headerlink" title="Compose中的重要概念"></a>Compose中的重要概念</h2><ul><li>服务service，容器，应用。（web,mysql,nginx…应用）</li><li>项目project。一组关联的容器。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs shell">sudo curl -L "https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</code></pre><p>上面是官方的源，但是下载的非常缓慢.我们可以换成下面的源下载。</p><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></pre><p>我们可以进入/usr/local/bin，看是否有docker-compose文件。</p><p>接着，我们需要修改这个文件的权限777.</p><pre><code class="hljs shell">chmod +x docker-compose</code></pre><p>然后我们使用命令验证是否安装成功。</p><pre><code class="hljs shell">docker-compose version</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803162835.png" srcset="/img/loading.gif" alt=""></p><h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>我们根据docker文档进行初体验。一个python的计数器。</p><p><a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">https://docs.docker.com/compose/gettingstarted/</a></p><ol><li>应用app.py文件</li><li>Dockerfile应用打包为镜像</li><li>Docker-compose yaml文件，定义整个服务，需要的环境。</li><li>启动compose项目。</li></ol><p>默认的服务名：文件名_服务名_num</p><p>在项目构建的时候会创建网络，我们的环境都会部署到同一个网络下，这样我们就可以通过服务名访问。</p><h2 id="yaml规则"><a href="#yaml规则" class="headerlink" title="yaml规则"></a>yaml规则</h2><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">官方文档地址</a></p><p>我们可以简单的把yaml文件分为3层。</p><pre><code class="hljs yaml"><span class="hljs-comment"># 3层</span><span class="hljs-attr">version:</span> <span class="hljs-string">''</span> <span class="hljs-comment">#版本</span><span class="hljs-attr">service:</span> <span class="hljs-comment"># 服务</span>  <span class="hljs-string">服务1：web</span>    <span class="hljs-comment"># 服务配置</span>    <span class="hljs-string">images</span>    <span class="hljs-string">build</span>    <span class="hljs-string">network</span>    <span class="hljs-string">...</span> <span class="hljs-comment"># 对docker容器的配置</span>  <span class="hljs-string">服务2：redis</span>    <span class="hljs-string">...</span>  <span class="hljs-string">服务3：redis</span><span class="hljs-comment">#其他配置 网络/卷/全局规则</span><span class="hljs-attr">volumes:</span><span class="hljs-attr">networks:</span><span class="hljs-attr">configs:</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot微服务打包Docker镜像</title>
    <link href="/cxlittlecute/a2729756.html"/>
    <url>/cxlittlecute/a2729756.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot微服务打包Docker镜像"><a href="#Springboot微服务打包Docker镜像" class="headerlink" title="Springboot微服务打包Docker镜像"></a>Springboot微服务打包Docker镜像</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>构建好Springboot项目</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803115814.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>打包应用</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803115848.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li>编写Dockerfile</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803135012.png" srcset="/img/loading.gif" alt=""></p><ol start="4"><li>构建镜像</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803135056.png" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>发布运行</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803135609.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803135538.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker发布镜像</title>
    <link href="/cxlittlecute/f67daaf8.html"/>
    <url>/cxlittlecute/f67daaf8.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker发布镜像"><a href="#Docker发布镜像" class="headerlink" title="Docker发布镜像"></a>Docker发布镜像</h1><p>Docker发布镜像有两种方式：</p><ul><li>发布到 Docker Hub</li><li>发布到 阿里云</li></ul><h2 id="发布到-Docker-Hub"><a href="#发布到-Docker-Hub" class="headerlink" title="发布到 Docker Hub"></a>发布到 Docker Hub</h2><p>1、 地址 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p>2、 注册账号</p><p>3、 账号登录</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker login --<span class="hljs-built_in">help</span></span>Usage:  docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options:  -p, --password string   Password      --password-stdin    Take the password from stdin  -u, --username string   Username<span class="hljs-meta">#</span><span class="bash"> 账号登录</span><span class="hljs-meta">$</span><span class="bash"> docker login -u 你的用户名 -p 你的密码</span></code></pre><p>使用docker images查看自己要提交镜像的image名称。</p><p>这里会出现一个问题，你被拒绝访问:</p><pre><code>access to the requested resource is not authorized</code></pre><p>首先说明原因可能是因为你的image命名不规范。也就是必须为username/image。</p><p>例如：我的ID是oysl image改成 oysl/MyimagesName 就行了。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了</span><span class="hljs-meta">$</span><span class="bash"> docker build -t oysl/mytomcat:0.1 .</span><span class="hljs-meta">#</span><span class="bash"> 第二种 使用docker tag <span class="hljs-comment">#然后再次push</span></span><span class="hljs-meta">$</span><span class="bash"> docker tag 容器id oysl/mytomcat:1.0 </span><span class="hljs-meta">#</span><span class="bash">然后再次push</span><span class="hljs-meta">$</span><span class="bash"> docker push oysl/mytomcat:1.0</span></code></pre><p>这样就可以正常push了。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802224300.png" srcset="/img/loading.gif" alt=""></p><h2 id="发布阿里云镜像服务"><a href="#发布阿里云镜像服务" class="headerlink" title="发布阿里云镜像服务"></a>发布阿里云镜像服务</h2><p>1、 登录阿里云</p><p>2、 找到容器镜像服务</p><p>3、 创建命名空间</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802225103.png" srcset="/img/loading.gif" alt=""></p><p>4、 创建镜像仓库</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802225157.png" srcset="/img/loading.gif" alt=""></p><p>5、 点击仓库名，查看操作指南。（文档步骤十分详细）</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerFile</title>
    <link href="/cxlittlecute/f61655ea.html"/>
    <url>/cxlittlecute/f61655ea.html</url>
    
    <content type="html"><![CDATA[<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>Dockerfile是用来构建docker镜像的文件的命令参数脚本。</p><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><p>1、 编写一个dockerfile文件</p><p>2、 docker build 构建称为一个镜像</p><p>3、 docker run运行镜像</p><p>4、 docker push发布镜像（DockerHub 、阿里云仓库)</p><p>我们可以通过DockerHub查看官网所构建的一些dockerfile文件。</p><h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>1、每个保留关键字(指令）都是必须是大写字母</p><p>2、执行从上到下顺序</p><p>3、#表示注释</p><p>4、每一个指令都会创建一个新的镜像层并提交。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><pre><code class="hljs shell">FROM# from:基础镜像，一切从这里开始构建MAINTAINER# maintainer:镜像是谁写的， 姓名+邮箱RUN# run:镜像构建的时候需要运行的命令ADD# add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR# workdir:镜像的工作目录VOLUME# volume:挂载的目录EXPOSE# expose:保留端口配置CMD# cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT# entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD# onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令COPY# copy:类似ADD，将我们文件拷贝到镜像中ENV# env:构建的时候设置环境变量！</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802184453.png" srcset="/img/loading.gif" alt=""></p><h2 id="制作一个Tomcat镜像"><a href="#制作一个Tomcat镜像" class="headerlink" title="制作一个Tomcat镜像"></a>制作一个Tomcat镜像</h2><ol><li><p>创建tomcat目录。</p></li><li><p>tomcat目录下存放tomcat和jdk的tar.gz压缩包。</p></li><li><p>创建readme.txt和Dockerfile文件</p></li><li><p>编写Dockerfile。</p></li></ol><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vim dockerfile</span>FROM centos # 基础镜像centosMAINTAINER oysl&lt;xxx@qq.com&gt;# 作者COPY README /usr/local/README # 复制README文件ADD jdk-8u231-linux-x64.tar.gz /usr/local/ # 添加jdk，ADD 命令会自动解压ADD apache-tomcat-9.0.35.tar.gz /usr/local/ # 添加tomcat，ADD 命令会自动解压RUN yum -y install vim# 安装 vim 命令ENV MYPATH /usr/local # 环境变量设置 工作目录WORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.8.0_231 # 环境变量： JAVA_HOME环境变量ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35 # 环境变量： tomcat环境变量ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.35<span class="hljs-meta">#</span><span class="bash"> 设置环境变量 分隔符是：</span>ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 # 设置暴露的端口CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out # 设置默认命令</code></pre><ol start="5"><li>构建镜像。</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件</span><span class="hljs-meta">$</span><span class="bash"> docker build -t mytomcat:0.1 .</span></code></pre><ol start="6"><li>run镜像。</li></ol><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200803092255.png" srcset="/img/loading.gif" alt=""></p><p>博客跳转：<a href="http://ccctop.cn/cxlittlecute/f67daaf8.html" target="_blank" rel="noopener">Docker发布镜像</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker具名和匿名挂载</title>
    <link href="/cxlittlecute/d367fe76.html"/>
    <url>/cxlittlecute/d367fe76.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker具名和匿名挂载"><a href="#Docker具名和匿名挂载" class="headerlink" title="Docker具名和匿名挂载"></a>Docker具名和匿名挂载</h1><p>挂载对于docker的使用是很重要的一个操作，因为我们可以通过挂载，将容器中的数据同步到本地主机上，这样就实现了容器数据的持久化或者数据共享。</p><h2 id="挂载方式"><a href="#挂载方式" class="headerlink" title="挂载方式"></a>挂载方式</h2><ol><li>直接使用命令挂载 -v分为以下几种情况：</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 三种挂载： 匿名挂载、具名挂载、指定路径挂载</span>-v 容器内路径#匿名挂载-v 卷名：容器内路径  #具名挂载-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</code></pre><ol start="2"><li>还可以使用DockerFile实现自动挂载。</li><li>以及使用数据卷容器进行挂载。</li></ol><h2 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span><span class="hljs-meta">#</span><span class="bash"> -v 容器内路径!</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx01 -v /etc/nginx nginx</span><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls    </span>DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c</code></pre><p>这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径。</p><h2 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 具名挂载 -P:表示随机映射端口</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume(卷)的情况</span><span class="hljs-meta">$</span><span class="bash"> docker volume ls                  </span>DRIVER              VOLUME NAMElocal               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802clocal               juming-nginx #多了一个名字<span class="hljs-meta">#</span><span class="bash"> 通过 -v 卷名：查看容器内路径</span><span class="hljs-meta">#</span><span class="bash"> 查看一下这个卷</span><span class="hljs-meta">$</span><span class="bash"> docker volume inspect juming-nginx</span>[    &#123;        "CreatedAt": "2020-05-23T13:55:34+08:00",        "Driver": "local",        "Labels": null,        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data", #默认目录        "Name": "juming-nginx",        "Options": null,        "Scope": "local"    &#125;]</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>所有的docker容器内的卷，没有指定目录的情况下都是在<strong>/var/lib/docker/volumes/自定义的卷名/_data</strong>下。</p><p>如果指定了目录，也就是第三种指定路径挂载通过-v /宿主机路径：容器内路径，docker volume ls 是查看不到的。</p><p>那么我们都可以通过docker inspect去查看宿主机的挂载目录。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span>ro #readonly 只读rw #readwrite 可读可写<span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><span class="hljs-meta">$</span><span class="bash"> docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span></code></pre><p>我们经常会看到以上的这两个用法，区别就是：ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！默认是rw。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker常用命令（转载）</title>
    <link href="/cxlittlecute/c8b964af.html"/>
    <url>/cxlittlecute/c8b964af.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker常用命令（转载）"><a href="#Docker常用命令（转载）" class="headerlink" title="Docker常用命令（转载）"></a>Docker常用命令（转载）</h1><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802123615.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs shell">attach  Attach to a running container      #当前shell下attach下连接指定运行镜像build   Build an image form a Dockerfile   #通过Dockerfile定制镜像commit  Create a new image form a container changes #提交当前容器为新的镜像cp Copy file/folders from the containers filesystem to the host path # 容器中拷贝指定文件或者目录到宿主机上create  Create a new Container            #创建一个新的容器，同run，但是不会启动容器diff  Inspect changes on a Container’s filesystem #查看docker 容器的变化exec  Run a Command in an existing container  #在已存在的容器上运行命令export   Stream the contents of a container as a tar archive   #导出容器的内容作为一个tar 归档文件[对应import]history    Show the history of an image     # 展示一个镜像形成历史images     List images    #列出系统当前镜像import     Create a new filesystem image form the contents of a tarball # 从tar包中的内容创建一个新的文件系统镜像[对应export]info     Display system-while information       # 显示系统相关信息inspect    Return low—level  information on a container    # 查看容器详细信息kill   kill a running container      # kill 指定docker 容器load    Load an image from a tar archive      # 从一个tar包中加载一个镜像[对应save]login   Register or login to the docker registry server    # 注册或者登陆一个Docker源服务器logout    Log out from a Docker registry server    # 从当前Docker registry  退出logs     Fetch  the logs of a container      # 输出当前容器日志信息port     Lookup  the public-facing port which  is NAT-ed to PRIVATE-PORT   # 查看映射端口对应的容器内部源端口pause   Pause all processes within a container   # 暂停容器ps     List containers         # 列出容器列表pull   Pull an image or a repository from the docker registry server  # 从docker镜像服务器拉取指定镜像或者库镜像push   Push  an image or a repository from the docker registry server  # 推送指定镜像或者库镜至docker 源服务器restart  Restart a running container       # 重启运行的容器rm    Remove  one or more container        # 移除一个或者多个容器rmi   Remove  one or more images           # 移除一个或多个镜像[无容器使用该镜像才可以删除，否则需删除相关容器才可继续  或者-f强制删除]run    Run a  command  in a new container       # 创建一个新的容器并运行一个命令save   Save an image  to a tar archive          # 保存一个镜像为一个tar包[对应load]search  Search for an image on the Docker Hub   # 在docker hub 中搜索镜像start   Start a  stoped containers              # 启动容器stop    Stop  a running container               # 停止容器tag     Tag an image into a repository          # 给源中镜像打标签top     Lookup the running proesses of a container # 查看容器中运行的进程信息unpause  Unpause a paused container             # 取消暂停容器version  Show the docker version information    # 查看docker版本号wait   Block until a container stops, then print its exit code # 截取容器停止时的退出状态值</code></pre><p>笔记出自bilibili 博主：遇见狂神说</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（七）-分词</title>
    <link href="/cxlittlecute/3cc92c66.html"/>
    <url>/cxlittlecute/3cc92c66.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（七）-分词"><a href="#Elasticsearch（七）-分词" class="headerlink" title="Elasticsearch（七）-分词"></a>Elasticsearch（七）-分词</h1><p>分词的作用就是将一段话，分为一个个单词，利用单词的相关性匹配，最终完成我们的全文检索功能。</p><p>分词在ES中是使用分词器进行的，一个 tokenizer (分词器)接收一个字符流,将之分割为独立的 tokens (词元，通常是独立的单词)，然后输出 tokens流。</p><p>例如, whitespace tokenizer 遇到空白字符时分割文本。它会将文本”Quick brown fox!”分割为[Quick， brown， fox!l。</p><p>该 tokenizer (分词器)还负责记录各个 term (词条)的顺序或 position位置(用于 phrase短语和 word proximity 词近邻查询) ，以及 term (词条)所代表的原始 word (单词)的 start(起始)和 end (结束)的 character offsets (字符偏移量) (用于高亮显示搜索的内容)。</p><p>Elasticsearch 提供了很多内置的分词器，可以用来构建 custom analyzers (自定义分词器) </p><h2 id="测试-ES-默认的标准分词器"><a href="#测试-ES-默认的标准分词器" class="headerlink" title="测试 ES 默认的标准分词器"></a>测试 ES 默认的标准分词器</h2><pre><code class="hljs shell">POST _analyze&#123;  "analyzer": "standard",  "text": "The 2 QUICK Brown-Foxes jumped over the lazy dog's bone."&#125;</code></pre><p>我们可以将上面那段话分为如下的形式：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801152017.png" srcset="/img/loading.gif" alt=""></p><p>但是我们需要注意的是，ES中内置的分词器都是对英文很友好，使用中文进行分词的话，它就会将一个个的字分开。</p><p>我们执行下面这一条语句看一下：</p><pre><code class="hljs shell">POST _analyze&#123;  "analyzer": "standard",  "text": "pafcmall电商项目"&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801152301.png" srcset="/img/loading.gif" alt=""></p><p>所以我们要进行其他分词器的安装。</p><h2 id="安装-ik-分词器"><a href="#安装-ik-分词器" class="headerlink" title="安装 ik 分词器"></a>安装 ik 分词器</h2><p>IK版本对应ES。</p><p>1、进入 es 容器内部 plugins 目录</p><pre><code class="hljs shell">docker exec -it 容器id /bin/bashwget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</code></pre><p>如果没有安装wget，就只有通过git下载zip后再上传到相应挂载的目录。用wget下载可能很慢，建议先下载zip后使用XFtp上传。</p><ol start="2"><li>unzip 下载文件并解压</li></ol><p>使用 unzip 解压 elasticsearch-analysis-ik-7.4.2.zip 发现 unzip 命令还未安装，先安装 unzip.</p><pre><code class="hljs shell">yum install unzip</code></pre><p>我使用的是Xftp上传。</p><ol start="3"><li><p>修改文件名，给对应目录修改权限。</p><pre><code class="hljs shell">将文件名改为ik。chmod -R 777 ik/</code></pre></li><li><p>安装并重启docker<br>进入ES的bin目录</p></li></ol><pre><code class="hljs shell">elasticsearch-plugin list</code></pre><p>执行安装，然后重启docker。最终执行结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801160226.png" srcset="/img/loading.gif" alt=""></p><p>官方文档位置:<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html</a></p><h2 id="自定义扩展词库"><a href="#自定义扩展词库" class="headerlink" title="自定义扩展词库"></a>自定义扩展词库</h2><p>我们发现虽然我们安装了ik分词器，但是我们的分词效果并不明显，因为它不能很好的按照我们的想法去进行分词。</p><p>所以，我们要进行自定义扩展词库。</p><p>要自定义拓展词库，可以修改 ik 分词器的配置文件，指定一个远程词库，让 ik 分词器向远程发送请求，要到一些最新的单词，这样最新的单词就会作为最新的词源进行分解。<br>自定义词库有两种方式实现：</p><ol><li>自己实现一个服务，处理 ik 分词器的请求，让 ik 分词器的给自定义的项目发送请求</li><li>搭建一个 nginx 服务器，将最新词库放到 nginx 中，让 ik 分词器给 nginx 发送请求，由 nginx 给 ik 分词器返回最新的词库，这样 ik 分词器就可以将原来的词库和新词库合并起来。</li></ol><p>我们主要讲解第二种方式：</p><ol><li><p>创建之前我们首先要安装好nginx。</p></li><li><p>我们在nginx/html目录下，创建一个es的文件夹，并且在里面创建一个txt文件。</p></li><li><p>我们可以通过浏览器路径直接访问我们的txt文件内容。例如：<a href="http://47.106.192.255/es/fenci.txt" target="_blank" rel="noopener">http://47.106.192.255/es/fenci.txt</a></p></li><li><p>如果访问成功,接下来我们就需要修改我们ik分词器的配置。</p><ul><li>修改分词器ik/config文件下的配置文件IKAnalyzer.cfg.xml。</li></ul></li></ol><p>xml中的修改情况如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801181856.png" srcset="/img/loading.gif" alt=""></p><p>注意：</p><ul><li>如果打开 IKAnalyzer.cfg.xml 为乱码的话，可以在先退出当前文件，在命令行输入 vi /etc/virc，然后在文件添加 set encoding=utf-8，保存退出，重新打开 IKAnalyzer.cfg.xml 即可。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801182052.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果出现nginx访问txt出现乱码情况。在nginx.conf中增加如下配置：然后nginx -s reload，重新加载或者重启容器。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200802100655.png" srcset="/img/loading.gif" alt=""></p><ol start="5"><li>最后我们需要重启ES容器。然后使用Kibana进行分词测试。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（六）-映射&amp;数据迁移</title>
    <link href="/cxlittlecute/6e27786d.html"/>
    <url>/cxlittlecute/6e27786d.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（六）-映射-amp-数据迁移"><a href="#Elasticsearch（六）-映射-amp-数据迁移" class="headerlink" title="Elasticsearch（六）-映射&amp;数据迁移"></a>Elasticsearch（六）-映射&amp;数据迁移</h1><p>首先我们需要知道ES7以后的一个改动：</p><p>ES7 及以上移除了 type 的概念。</p><p>关系型数据库中两个数据表是独立的，即使他们里面有相同名称的列也不影响使用，但ES中不是这样的。 elasticsearch 是基于 Lucene 开发的搜索引擎，而 ES 中不同type下名称相同的 filed 最终在 Lucene 中的处理方式是一样的。<br>两个不同 type 下的两个 user_name，在ES同一个索引下其实被认为是同一个 filed，你必须在两个不同的 type 中定义相同的 filed 映射。否则，不同 type 中的相同字段名称就会在处理中出现冲突的情况，导致 Lucene 处理效率下降。</p><p>去掉type就是为了提高 ES 处理数据的效率。</p><p>Elasticsearch 7.x：<br>URL中的 type 参数为可选。比如，索引一个文档不再要求提供文档类型。<br>Elasticsearch 8.x：<br>不再支持URL中的type参数。</p><h2 id="1）字段类型"><a href="#1）字段类型" class="headerlink" title="1）字段类型"></a>1）字段类型</h2><h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><ul><li>字符串（string）<br>text，keyword</li><li>数字类型（Numeric）<br>long, integer, short, byte, double, float, half_float, scaled_float</li><li>日期类型（Date）<br>date</li><li>布尔类型（Boolean）<br>boolean</li><li>二进制类型（Binary）<br>binary</li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul><li>数组类型（Array）<br>Array 支持不针对特定的数据类型</li><li>对象类型（Object）<br>object 用于单个JSON对象的对象</li><li>嵌套类型（Nested）<br>nested 用于JSON对象的数组</li></ul><h3 id="地理类型（Geo）"><a href="#地理类型（Geo）" class="headerlink" title="地理类型（Geo）"></a>地理类型（Geo）</h3><ul><li>地理坐标（Geo-point）<br>geo_point 纬度/经度坐标</li><li>地理圆形（Geo-shape）<br>geo_shape 用于多边形等复杂形状</li></ul><h3 id="特定类型"><a href="#特定类型" class="headerlink" title="特定类型"></a>特定类型</h3><ul><li>IP 类型（IP）<br>ip 用于描述 IPv4 和 IPv6 地址</li><li>补全类型（Completion）<br>completion 提供自动完成提示</li><li>令牌计数类型（Token count）<br>token_count 用来统计字符串中词条的数量</li><li>附件类型（attachment）<br>参考 mapper-attachments 插件，支持将附件例如Microsoft Office格式，open document格式，ePub，HTML等索引为 attachment 数据类型。</li><li>抽取类型（Percolator）<br>接受来自领域特定语言（query-dsl）的查询</li></ul><p>可参考文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</a></p><h2 id="2）映射"><a href="#2）映射" class="headerlink" title="2）映射"></a>2）映射</h2><p>映射是定义文档及其包含的字段的存储和索引方式的过程。</p><ul><li>哪些字符串字段应视为全文字段。</li><li>哪些字段包含数字，日期或地理位置。</li><li>日期值的格式。</li><li>自定义规则，用于控制动态添加字段的映射 。</li></ul><h2 id="3）使用"><a href="#3）使用" class="headerlink" title="3）使用"></a>3）使用</h2><h5 id="查看-mapping-信息："><a href="#查看-mapping-信息：" class="headerlink" title="查看 mapping 信息："></a>查看 mapping 信息：</h5><p>GET bank/_mapping</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801110112.png" srcset="/img/loading.gif" alt=""></p><ul><li>创建索引并指定映射：</li></ul><pre><code class="hljs shell">PUT /my-index&#123;  "mappings": &#123;//映射规则    "properties": &#123;      "age":    &#123; "type": "integer" &#125;,        "email":  &#123; "type": "keyword"  &#125;,//keyword不会进行全文检索       "name":   &#123; "type": "text"  &#125;//text保存的时候进行分词，搜索的时候进行全文检索       &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801111205.png" srcset="/img/loading.gif" alt=""></p><p>如果不设置mapping信息，那么ES会根据你的值自动设置相应的类型。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801112343.png" srcset="/img/loading.gif" alt=""></p><h5 id="添加新的字段映射"><a href="#添加新的字段映射" class="headerlink" title="添加新的字段映射"></a>添加新的字段映射</h5><pre><code class="hljs shell">PUT /my-index/_mapping&#123;  "properties": &#123;    "employee-id": &#123;      "type": "keyword",      "index": false//索引选项控制是否对字段值建立索引。 它接受true或false，默认为true。未索引的字段不可查询。也就是控制这个字段是否参与检索。    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801120301.png" srcset="/img/loading.gif" alt=""></p><h5 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h5><p>对于已经存在的映射字段，我们不能更新。更新必须创建新的索引进行数据迁移。</p><h2 id="4）数据迁移"><a href="#4）数据迁移" class="headerlink" title="4）数据迁移"></a>4）数据迁移</h2><p>先创建出 twitter 的正确映射。然后使用如下方式进行数据迁移:</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7.x 之后的写法</span>POST _reindex//固定写法&#123;  "source": &#123;//老索引    "index": "twitter"  &#125;,  "dest": &#123;//目标索引    "index": "new_twitter"  &#125;&#125;<span class="hljs-meta">#</span><span class="bash"> 7.x之前的带 <span class="hljs-built_in">type</span> 的写法</span>将旧索引的 type 下的数据进行迁移POST _reindex//固定写法&#123;  "source": &#123;    "index": "twitter", //老索引    "type": "twitter",  //老类型  &#125;,  "dest": &#123;//目标索引    "index": "new_twitter"  &#125;&#125;</code></pre><p>举例：<br>将bank索引下，account类型的数据进行迁移。</p><ol><li>创建一个新的索引：<pre><code class="hljs shell">PUT /newbank&#123;  "mappings": &#123;    "properties": &#123;      "account_number": &#123;        "type": "long"      &#125;,      "address": &#123;        "type": "text"      &#125;,      "age": &#123;        "type": "integer"      &#125;,      "balance": &#123;        "type": "long"      &#125;,      "city": &#123;        "type": "keyword"      &#125;,      "email": &#123;        "type": "keyword"      &#125;,      "employer": &#123;        "type": "keyword"      &#125;,      "firstname": &#123;        "type": "text"      &#125;,      "gender": &#123;        "type": "keyword"      &#125;,      "lastname": &#123;        "type": "text"      &#125;,      "state": &#123;        "type": "keyword"      &#125;    &#125;  &#125;&#125;</code></pre><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801145343.png" srcset="/img/loading.gif" alt=""></li></ol><ol start="2"><li><p>数据迁移：</p><pre><code class="hljs shell">POST _reindex&#123;  "source": &#123;    "index": "bank",    "type": "account"  &#125;,  "dest": &#123;    "index": "newbank"  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801145422.png" srcset="/img/loading.gif" alt=""></p></li><li><p>查看迁移后的结果：</p></li></ol><pre><code class="hljs shell">GET newbank/_search</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801145614.png" srcset="/img/loading.gif" alt=""></p><p>详情请参考文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（五）-聚合分析</title>
    <link href="/cxlittlecute/6765e78b.html"/>
    <url>/cxlittlecute/6765e78b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（五）-聚合分析"><a href="#Elasticsearch（五）-聚合分析" class="headerlink" title="Elasticsearch（五）-聚合分析"></a>Elasticsearch（五）-聚合分析</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面我们已经了解了ES的存储、检索功能，那么还剩下第三个强大的分析功能。</p><h4 id="aggregations-执行聚合"><a href="#aggregations-执行聚合" class="headerlink" title="aggregations (执行聚合)"></a>aggregations (执行聚合)</h4><p>聚合提供了从数据中分组和提取数据的能力。<br>最简单的聚合方法大致等于 SQL GROUP BY 和 SQL 聚合函数。</p><pre><code class="hljs shell">"aggregations" : &#123;    "&lt;aggregation_name&gt;" : &#123;        "&lt;aggregation_type&gt;" : &#123;            &lt;aggregation_body&gt;        &#125;        [,"meta" : &#123;  [&lt;meta_data_body&gt;] &#125; ]?        [,"aggregations" : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]?    &#125;    [,"&lt;aggregation_name_2&gt;" : &#123; ... &#125; ]*&#125;</code></pre><p>聚合分析有四种：<br>metrics：指标分析聚合<br>bucket：分桶类型<br>pipeline：管道分析<br>matrix：矩阵分析</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><h5 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h5><ul><li>搜索address中包含mill的所有人的年龄分布以及平均年龄，但不显示这些人的详情。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123; //查询    "match": &#123;      "address": "mill"    &#125;  &#125;,  "aggs": &#123; //聚合    "ageAgg": &#123; //年龄分布      "terms": &#123;        "field": "age",        "size": 10 //只取10中聚合的结果      &#125;    &#125;,    "ageAvg":&#123;//平均年龄，基于上一次的结果      "avg": &#123;        "field": "age"      &#125;    &#125;,    "balanceAvg":&#123;//平均薪资      "avg": &#123;        "field": "balance"      &#125;    &#125;  &#125;,  "size": 0 //不显示搜索数据，只显示聚合结果&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801092324.png" srcset="/img/loading.gif" alt=""></p><p>aggs，执行聚合。聚合语法如下：</p><pre><code class="hljs shell">"aggs":&#123;"ages_name 这次聚合的名字,方便展示在结果集中":&#123;"AGG-TYPE 聚合的类型(avg,term,terms) ":&#123;&#125;&#125;&#125;</code></pre><h5 id="复杂聚合"><a href="#复杂聚合" class="headerlink" title="复杂聚合"></a>复杂聚合</h5><ul><li>按照年龄聚合，并且请求这些年龄段的这些人的平均薪资（使用一个子聚合）</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "aggs": &#123;    "ageAgg": &#123;      "terms": &#123;//年龄范围分布聚合        "field": "age",        "size": 100//返回100中情况      &#125;,      "aggs": &#123;//基于ageAgg的结果做聚合        "ageAvg": &#123;          "avg": &#123;//求balance的平均值            "field": "balance"          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801093745.png" srcset="/img/loading.gif" alt=""></p><ul><li>查出所有年龄分布，并且这些年龄段中M的平均薪资和F的平均薪资以及这个年龄段的总体平均新资。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "aggs": &#123;//聚合    "ageAgg":&#123;      "terms": &#123;//年龄分布        "field": "age",        "size": 100      &#125;,      "aggs": &#123;//基于ageAgg做聚合        "genderAgg": &#123;//性别分布          "terms": &#123;            //文本字段聚合使用keyword进行精确匹配，否则会报错            "field": "gender.keyword",            "size": 10          &#125;,          "aggs": &#123;//基于genderAgg做聚合            "balanceAvg": &#123;//求性别为M和F的各自的平均薪资              "avg": &#123;                "field": "balance"              &#125;            &#125;          &#125;        &#125;,        "ageBalanceAvg":&#123;//基于ageAgg，求各个年龄段的平均薪资          "avg": &#123;            "field": "balance"          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200801102703.png" srcset="/img/loading.gif" alt=""></p><p>聚合分析的其他用法可以参考官方文档或者以下博客：</p><p><a href="https://www.cnblogs.com/xiaobaozi-95/p/9197616.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaobaozi-95/p/9197616.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（四）-检索</title>
    <link href="/cxlittlecute/8fb22cc.html"/>
    <url>/cxlittlecute/8fb22cc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（四）-检索"><a href="#Elasticsearch（四）-检索" class="headerlink" title="Elasticsearch（四）-检索"></a>Elasticsearch（四）-检索</h1><h2 id="1-检索"><a href="#1-检索" class="headerlink" title="1. 检索"></a>1. 检索</h2><p>ES 支持两种基本方式检索：</p><ul><li>一个是通过使用 REST request URI 发送搜索参数(uri+检索参数)</li><li>另一个是通过使用 REST requestbody 来发送它们(uri+请求体)</li></ul><p>一切检索从_search开始</p><ol><li>uri+检索参数 进行检索：</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731095204.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731095315.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>uri+请求体 进行检索:</li></ol><pre><code class="hljs java">GET /bank/_search&#123;  <span class="hljs-string">"query"</span>: &#123;    <span class="hljs-string">"match_all"</span>: &#123;&#125;  &#125;,  <span class="hljs-string">"sort"</span>: [    &#123;      <span class="hljs-string">"account_number"</span>: <span class="hljs-string">"asc"</span>    &#125;,    &#123;      <span class="hljs-string">"balance"</span>: <span class="hljs-string">"desc"</span>    &#125;  ]&#125;</code></pre><p>这种查询风格，我们称为Query DSL。</p><p>可以参照ES文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></p><h2 id="2-Query-DSL"><a href="#2-Query-DSL" class="headerlink" title="2. Query DSL"></a>2. Query DSL</h2><h4 id="1）基本语法："><a href="#1）基本语法：" class="headerlink" title="1）基本语法："></a>1）基本语法：</h4><p>Elastisearch 提供了一个可以执行查询的 Json 风格的 DSl (domain-specific language 领域特定语言) 。这个被称为Query DSL。该查询语言非常全面。</p><ul><li>查询语句的典型结构<pre><code class="hljs shell">&#123;QUERY_NAME:&#123;ARGUMENT: VALUE,ARGUMENT: VALUE,...&#125;&#125;</code></pre>例如查询所有：</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;&#125;</code></pre><ul><li>如果是针对某个字段,那么它的结构如下：</li></ul><pre><code class="hljs shell">&#123;QUERY_NAME:&#123;FIELD_NAME:&#123;ARGUMENT: VALUE,ARGUMENT: VALUE,...&#125;&#125;&#125;</code></pre><p>例如下面我们指定字段进行排序：</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "sort": [    &#123;      "balance": &#123;        "order": "desc"      &#125;    &#125;  ],  "from": 0,  "size": 5&#125;</code></pre><ul><li>query 定义如何查询；</li><li>match_all 查询类型【代表查询所有的所有】， es 中可以在 query 中组合非常多的查询类型完成复杂查询</li><li>除了 query 参数之外，我们也可以传递其它的参数以改变查询结果。如 sort，size；</li><li>from+size 限定，完成分页功能；</li><li>sort 排序，多字段排序，会在前序字段相等时后续字段内部排序，否则以前序为准.</li></ul><h4 id="2-返回部分字段"><a href="#2-返回部分字段" class="headerlink" title="2) 返回部分字段"></a>2) 返回部分字段</h4><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_all": &#123;&#125;  &#125;,  "sort": [    &#123;      "balance": &#123;        "order": "desc"      &#125;    &#125;  ],  "from": 0,  "size": 5,  "_source": ["balance","firstname"]&#125;</code></pre><p>只返回 _source 中指定的字段，类似于 MySQL 中的 select field_1,field_2,… from table。</p><h4 id="3）match【匹配查询】"><a href="#3）match【匹配查询】" class="headerlink" title="3）match【匹配查询】"></a>3）match【匹配查询】</h4><ul><li>基本类型（非字符串），精确匹配</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "account_number": 20    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731103245.png" srcset="/img/loading.gif" alt=""></p><ul><li>字符串，全文检索</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "address": "Kings"    &#125;  &#125;&#125;</code></pre><p>最终查询出 address 中包含 Kings 单词的所有记录，当搜索字符串类型的时候，会进行全文检索，并且每条记录有相关性得分。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731103406.png" srcset="/img/loading.gif" alt=""></p><ul><li>字符串，多个单词（分词+全文检索）</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "address": "Mill Lane"    &#125;  &#125;&#125;</code></pre><p>最终查询出 address 中包含 Mill 或者 Lane 或者 Mill Lane 的所有记录,并给出相关性得分.最后的结果也是按照得分的高低进行排序的。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731103655.png" srcset="/img/loading.gif" alt=""></p><h4 id="4）match-phrase-【短语匹配】"><a href="#4）match-phrase-【短语匹配】" class="headerlink" title="4）match_phrase 【短语匹配】"></a>4）match_phrase 【短语匹配】</h4><p>将需要匹配的值当成一个整体单词(不分词)进行检索。</p><p>举例：查出 address 中包含 mill road 的所有记录，并给出相关性得分。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match_phrase": &#123;      "address": "mill road"    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731104445.png" srcset="/img/loading.gif" alt=""></p><h4 id="5）multi-match-【多字段匹配】"><a href="#5）multi-match-【多字段匹配】" class="headerlink" title="5）multi_match 【多字段匹配】"></a>5）multi_match 【多字段匹配】</h4><p>举例：检索在address 或 state 字段包含 mill的。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "multi_match": &#123;      "query": "mill",      "fields": ["address","state"]    &#125;  &#125;&#125;</code></pre><p>只要有一个字段包含，就能检索出数据。多字段匹配仍然进行了分词。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731105103.png" srcset="/img/loading.gif" alt=""></p><h4 id="6）bool-【复合查询】"><a href="#6）bool-【复合查询】" class="headerlink" title="6）bool 【复合查询】"></a>6）bool 【复合查询】</h4><p>复合语句可以合并任何其它查询语句，包括复合语句，了解这一点是很重要的。<br>这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。</p><ul><li>must：必须达到 must 列举的所有条件。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;          "match": &#123;            "gender": "F"          &#125;        &#125;,        &#123;          "match": &#123;            "address": "Mill"          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731110610.png" srcset="/img/loading.gif" alt=""></p><ul><li>must_not：子句（查询）不得出现在匹配的文档中。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;          "match": &#123;            "gender": "F"          &#125;        &#125;,        &#123;          "match": &#123;            "address": "Mill"          &#125;        &#125;      ],      "must_not": [        &#123;"match": &#123;          "age": 30        &#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731110842.png" srcset="/img/loading.gif" alt=""></p><ul><li>should：子句（查询）应出现在匹配的文档中。（should表示有最好，没有也可以）。</li></ul><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;          "match": &#123;            "gender": "M"          &#125;        &#125;,        &#123;          "match": &#123;            "address": "Mill"          &#125;        &#125;      ],      "must_not": [        &#123;"match": &#123;          "age": 30        &#125;&#125;      ],      "should": [        &#123;"match": &#123;          "lastname": "Holland"        &#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731110936.png" srcset="/img/loading.gif" alt=""></p><h4 id="7-filter-【结果过滤】"><a href="#7-filter-【结果过滤】" class="headerlink" title="7) filter 【结果过滤】"></a>7) filter 【结果过滤】</h4><p>在 filter 元素下指定的查询对得分没有影响-得分以 0 形式返回。分数仅受指定查询的影响。must和filter的不同就是，使用filter查询出的结果和must查询出的结果是一致的，差异仅是没有相关性得分。</p><p>Filter子句在filter上下文中执行，这意味着计分被忽略，并且子句被考虑用于缓存。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "must": [        &#123;"range": &#123;          "age": &#123;            "gte": 18,            "lte": 30          &#125;        &#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731112923.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "bool": &#123;      "filter": &#123;        "range": &#123;          "age": &#123;            "gte": 18,            "lte": 30          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731113054.png" srcset="/img/loading.gif" alt=""></p><p>所以我们可以在最后进行filter条件过滤。</p><h4 id="8-term"><a href="#8-term" class="headerlink" title="8) term"></a>8) term</h4><p>和 match 一样。匹配某个属性的值。全文检索字段用 match，其他非 text 字段匹配用 term。</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "term": &#123;      "age":28    &#125;  &#125;&#125;</code></pre><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200731113922.png" srcset="/img/loading.gif" alt=""></p><p>match 的 xxx.keyword，文本的精确匹配检索:</p><pre><code class="hljs shell">GET /bank/_search&#123;  "query": &#123;    "match": &#123;      "address.keyword": "789 Madison"    &#125;  &#125;&#125;</code></pre><p>和match_phrase的区别在于，xxx.keyword是必须文本内容完全相同，而match_phrase是只要文本中出现了这个完整句子就可以。</p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（三）-数据操作</title>
    <link href="/cxlittlecute/bfd63ba9.html"/>
    <url>/cxlittlecute/bfd63ba9.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（三）-数据操作"><a href="#Elasticsearch（三）-数据操作" class="headerlink" title="Elasticsearch（三）-数据操作"></a>Elasticsearch（三）-数据操作</h1><p> ES将所有请求都封装成了 REST API，因此我们可以使用 postman 和图形化界面kibana来访问它。</p><p> 使用 postman 或者在浏览器地址栏输入请求路径：</p><pre><code>http://IP:端口/_cat/xxx</code></pre><p>###1. _cat (节点信息查看)</p><ul><li>GET /_cat/nodes:查看所有节点</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105612.png" srcset="/img/loading.gif" alt=""></p><ul><li>GET /_cat/health:查看es健康状况</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105720.png" srcset="/img/loading.gif" alt=""></p><ul><li>GET /_cat/master:查看主节点</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105841.png" srcset="/img/loading.gif" alt=""></p><ul><li>GET /_cat/indices:查看所有索引 ；相当于 MySQL 的 show databases;</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730105913.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-put-amp-post-（新增数据）"><a href="#2-put-amp-post-（新增数据）" class="headerlink" title="2. put&amp;post （新增数据）"></a>2. put&amp;post （新增数据）</h3><ul><li><p>索引一个文档(对应成Mysql就是保存一条记录)</p><p>  保存一个数据，保存在哪个索引的哪个类型下，指定用哪个唯一标识PUT customer/external/1。</p><p>  在 customer 索引下的 external 类型下保存 1 号数据为：</p>  <pre><code class="hljs json">&#123;“name”:“lohn Doe”&#125;</code></pre><p>那么我们可以使用postman发送这个Json请求。</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730110736.png" srcset="/img/loading.gif" alt=""></p><p>返回体的内容,返回一些基本信息：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730110853.png" srcset="/img/loading.gif" alt=""></p><p>注意：<br>PUT 和 POST 都可以。<br>POST 新增。如果不指定id，会自动生成 id。指定 id 如果第二次提交就会修改这个数据，并新增版本号；<br>PUT 可以新增也可以修改。PUT 必须指定 id；由于 PUT 需要指定 id，我们一般都用来做修改；</p><h3 id="3-get-（查询数据）-amp-乐观锁字段"><a href="#3-get-（查询数据）-amp-乐观锁字段" class="headerlink" title="3. get （查询数据）&amp;乐观锁字段"></a>3. get （查询数据）&amp;乐观锁字段</h3><p>我们通过GET 索引/类型/ID查询数据</p><p>查询结果：</p><pre><code class="hljs json">&#123;    “_index”: “customer”, //在哪个索引    “_type”: “external”, //在哪个类型    “_id”: “1”, //记录id    “_version”: 4, //版本号    “_seq_no”: 5, //并发控制字段,每次更新就会+1,用来做乐观锁    “_primary_term”: 1, //同上,主分片重新分配,如重启,就会变化    “found”: true, //表示找到了数据    “_source”: &#123; //数据内容        “name”: “lohn Doe”    &#125;&#125;</code></pre><p>我们可以看到在查询结果中有我们的乐观锁字段“_seq_no”,它是为了保证我们多线程访问的情况下，保证数据的一致性。</p><p>我们要使用乐观锁修改，我们就需要在 put 或 post 请求的路径中加上?if_seq_no=0&amp;if_primary_term=1字段。</p><p>这样就可以根据去判断版本是否对应，是否能够修改成功。</p><p>如果访问版本不对应的数据会出现以下报错：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730113015.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-put-amp-post-更新文档"><a href="#4-put-amp-post-更新文档" class="headerlink" title="4. put&amp;post (更新文档)"></a>4. put&amp;post (更新文档)</h3><p>更新的操作主要分为三种：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730113722.png" srcset="/img/loading.gif" alt=""></p><p>不同：</p><ol><li>POST带_update操作会对比源文档数据,如果相同不会有什么操作,文档 version 、_seq_no 不增加;</li><li>POST不带_update和PUT操作都不会检查源数据，都会迭代版本更新。</li></ol><p>更新同时增加属性：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730114255.png" srcset="/img/loading.gif" alt=""></p><p>总之：带_update操作就会对比源文档数据，其他的只会直接更新。</p><h3 id="5-DELETE-（删除数据）"><a href="#5-DELETE-（删除数据）" class="headerlink" title="5. DELETE （删除数据）"></a>5. DELETE （删除数据）</h3><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730114745.png" srcset="/img/loading.gif" alt=""></p><p>注意：在ES中，一个索引下有很多种类型，但是 ES 没有提供删除类型的方法，删除了索引，就会删除所有类型。</p><h3 id="6-bulk批量操作"><a href="#6-bulk批量操作" class="headerlink" title="6. bulk批量操作"></a>6. bulk批量操作</h3><p>语法格式：</p><pre><code class="hljs shell">&#123;action: &#123;metadata&#125;&#125;\n&#123;request body&#125;\n&#123;action: &#123;metadata&#125;&#125;\n&#123;request body&#125;\n</code></pre><p>action:(行为)<br>create:文档不存在时创建<br>update:更新文档<br>index:创建新文档或替换已有文档<br>delete:删除一个文档<br>metadata:_index,_type,_id</p><p>create和index的区别:<br>如果数据存在,使用create操作失败,会提示文档已经存在,使用index可以成功执行。</p><p>1.批量添加:</p><pre><code class="hljs shell">POST /lib2/books/_bulk&#123;"index":&#123;"_id":1&#125;&#125;&#123;"title":"Java","price":55&#125;&#123;"index":&#123;"_id":2&#125;&#125;&#123;"title":"Html5","price":45&#125;&#123;"index":&#123;"_id":3&#125;&#125;&#123;"title":"Php","price":35&#125;&#123;"index":&#123;"_id":4&#125;&#125;&#123;"title":"Python","price":50&#125;</code></pre><ol start="2"><li>批量获取:</li></ol><pre><code class="hljs shell">GET /lib2/books/_mget&#123;  "ids":["1","2","3","4"]&#125;</code></pre><ol start="3"><li><p>批量删除:没有请求体<br>POST /_bulk<br>{“delete”:{“_index”:“website”,”_type”:“blog”,”_id”:“123”}}</p></li><li><p>批量修改</p></li></ol><p>{“update”:{“_index”:“website”,”_type”:“blog”,”_id”:“123”}}<br>{“doc”:{“title”:“My updated blog post”}}</p><p>我们可以在kibana 的控制台，选择 DevTools，完成我们的bulk批量操作。</p><p>下面是ES官方提供的样本数据：<br><a href="https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（二）-镜像下载启动</title>
    <link href="/cxlittlecute/f2c898fb.html"/>
    <url>/cxlittlecute/f2c898fb.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（二）-镜像下载启动"><a href="#Elasticsearch（二）-镜像下载启动" class="headerlink" title="Elasticsearch（二）-镜像下载启动"></a>Elasticsearch（二）-镜像下载启动</h1><p>本文主要记录自己在docker安装Elasticsearch时出现的问题，以及解决方式。</p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><pre><code class="hljs shell">docker pull elasticsearch:7.4.2 # 存储和检索数据</code></pre><h2 id="挂载配置文件"><a href="#挂载配置文件" class="headerlink" title="挂载配置文件"></a>挂载配置文件</h2><p>在挂载配置文件的时候可能会出现两个问题：</p><ol><li>虚拟机中的文件权限不足。</li><li>挂载的文件路径错误。</li></ol><p>解决问题：<br>问题一：修改虚拟机中挂载的文件权限。<br>问题二：核对挂载的文件路径是否正确。</p><pre><code class="hljs shell">mkdir -p /mydata/elasticsearch/config # 在mydata文件夹下创建es的config文件夹，将docker中es的配置挂载在外部，当我们在linux虚拟机中修改es的配置文件时，就会同时修改docker中的es的配置mkdir -p /mydata/elasticsearch/data #在mydata文件夹下创建es的data文件夹echo "http.host: 0.0.0.0" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml # [http.host: 0.0.0.0]允许任何远程机器访问es，并将其写入es的配置文件中chmod -R 777 /mydata/elasticsearch/ # 保证权限问题</code></pre><p>启动容器：</p><pre><code class="hljs shell">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \-e "discovery.type=single-node" \-e ES_JAVA_OPTS="-Xms64m -Xmx512m" \-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-d elasticsearch:7.4.2<span class="hljs-meta">#</span><span class="bash"> docker run --name elasticsearch 创建一个es容器并起一个名字；</span><span class="hljs-meta">#</span><span class="bash"> -p 9200:9200 将linux的9200端口映射到docker容器的9200端口，用来给es发送http请求</span><span class="hljs-meta">#</span><span class="bash"> -p 9300:9300 9300是es在分布式集群状态下节点之间的通信端口  \ 换行符</span><span class="hljs-meta">#</span><span class="bash"> -e 指定一个参数，当前es以单节点模式运行</span><span class="hljs-meta">#</span><span class="bash"> *注意，ES_JAVA_OPTS非常重要，指定开发时es运行时的最小和最大内存占用为64M和128M，否则就会占用全部可用内存</span><span class="hljs-meta">#</span><span class="bash"> -v 挂载命令，将虚拟机中的路径和docker中的路径进行关联</span><span class="hljs-meta">#</span><span class="bash"> -d 后台启动服务</span></code></pre><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><p>在我启动容器后，没有出现报错，但是使用命令docker ps，发现容器并没有启动成功，也就是没有正常运行。</p><p>解决：</p><p> 使用docker logs -f 容器ID查看容器运行的日志。</p><p> 发现出现以下问题：</p><pre><code>OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0....</code></pre><p>这是由于jdk版本太低造成的，jdk版本需要在9.0以上，因此需要重新安装jdk。重新安全JDK后就可以正常启动了。<br>还有就是允许任何远程机器访问es中的http.host: 0.0.0.0是有空格的，如果没有空格它也会报错elasticsearch.yml有问题。</p><p>使用IP+端口访问es,出现下图说明安装成功：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730091722.png" srcset="/img/loading.gif" alt=""></p><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>最后我们也可以安装es的可视化界面-kibana。</p><pre><code class="hljs shell">docker pull kibana:7.4.2</code></pre><pre><code class="hljs shell">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://47.106.192.255:9200 -p 5601:5601 \-d kibana:7.4.2</code></pre><p>注意修改将IP和端口，修改对应为你自己ES的IP和端口。</p><p>最后我们可以通过IP和端口进行访问：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200730102948.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch（一）- 基本概念</title>
    <link href="/cxlittlecute/c2de7423.html"/>
    <url>/cxlittlecute/c2de7423.html</url>
    
    <content type="html"><![CDATA[<h1 id="Elasticsearch（一）-基本概念"><a href="#Elasticsearch（一）-基本概念" class="headerlink" title="Elasticsearch（一）- 基本概念"></a>Elasticsearch（一）- 基本概念</h1><h2 id="什么是Elasticsearch"><a href="#什么是Elasticsearch" class="headerlink" title="什么是Elasticsearch"></a>什么是Elasticsearch</h2><p>Elasticsearch是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。</p><h2 id="什么是全文检索"><a href="#什么是全文检索" class="headerlink" title="什么是全文检索"></a>什么是全文检索</h2><p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>Index（索引）： Elasticsearch 数据管理的顶层单位，相当于Mysql中的库。每个Index的名字必须是小写。</p></li><li><p>Type（类型）：可以在Index中定义一个或多个类型，它是虚拟的逻辑分组，用来过滤 Document，类似Mysql中的数据表。</p></li><li><p>Document（文档）：Index里面单条的记录称为 Document（文档），文档是JSON格式的，Document就像是Mysql中的某个Table里面的内容。</p></li><li><p>倒排索引（Inverted Index）：倒排索引以字或词为关键字进行索引，索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。Elasticsearch能够实现快速、高效的搜索功能，正是基于倒排索引原理。</p></li><li><p>文档编号(Document ID)：在搜索引擎内部，会将文档集合内每个文档赋予一个唯一的内部编号，以此编号来作为这个文档的唯一标识，这样方便内部处理，每个文档的内部编号即称之为“文档编号”，后文有时会用DocID来便捷地代表文档编号。</p></li><li><p>单词编号(Word ID)：与文档编号类似，搜索引擎内部以唯一的编号来表示某个单词，单词编号可以作为某个单词的唯一表示。</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729170338.png" srcset="/img/loading.gif" alt=""></p><p>保存和检索的时候都是先进行分词，然后在倒排索引表中进行插入和检索，最后根据相关性得分进行得到最后的数据。</p><ul><li><p>单词词典(Lexicon)：单词词典是由文档集合中出现过的所有单词构成的字符串集合。搜索引擎的通常索引单位是单词，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</p></li><li><p>倒排列表(PostingList)：倒排列表记载了出现过某个单词的所有文档的文档列表及单词在该文档中出现的位置信息，每条记录称为一个倒排项(Posting)。根据倒排列表，即可获知哪些文档包含某个单词。</p></li><li><p>倒排文件(Inverted File)：所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件即被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</p></li></ul><p>上面三者的关系我们可以通过下图清楚的看出：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729201139.png" srcset="/img/loading.gif" alt=""></p><p>参考：<br><a href="https://blog.csdn.net/starzhou/article/details/87519973" target="_blank" rel="noopener">https://blog.csdn.net/starzhou/article/details/87519973</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树折纸问题</title>
    <link href="/cxlittlecute/9672ca82.html"/>
    <url>/cxlittlecute/9672ca82.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树折纸问题"><a href="#二叉树折纸问题" class="headerlink" title="二叉树折纸问题"></a>二叉树折纸问题</h1><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。</p><p>给定一个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729144138.png" srcset="/img/loading.gif" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们根据输出的结果分析，需要把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构来描述对折后产生的折痕。</p><p>这棵树有这样的特点：</p><ol><li>根结点为下折痕；</li><li>每一个结点的左子结点为下折痕；</li><li>每一个结点的右子结点为上折痕；</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200729144428.png" srcset="/img/loading.gif" alt=""></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>定义结点类</li><li>构建深度为N的折痕树；</li><li>使用中序遍历，打印出树中所有结点的内容。</li></ol><p>构建深度为N的折痕树：</p><ol><li>第一次对折，只有一条折痕，创建根结点；</li><li>如果不是第一次对折，则使用队列保存根结点；</li><li>循环遍历队列：</li><li>1 从队列中拿出一个结点；</li><li>2 如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；</li><li>3 如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</li><li>4 判断当前结点的左子结点和右子结点是否都为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaperFolding</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//构建折痕树</span>        Node tree = createTree(<span class="hljs-number">2</span>);        <span class="hljs-comment">//遍历折痕树，并打印</span>        printTree(tree);    &#125;    <span class="hljs-comment">// 定义结点类</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-comment">//存储结点元素</span>        String item;        <span class="hljs-comment">//左子结点</span>        Node left;        <span class="hljs-comment">//右子结点</span>        Node right;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String item, Node left, Node right)</span> </span>&#123;            <span class="hljs-keyword">this</span>.item = item;            <span class="hljs-keyword">this</span>.left = left;            <span class="hljs-keyword">this</span>.right = right;        &#125;    &#125;    <span class="hljs-comment">// 使用中序遍历，打印树中的所有节点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(Node tree)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (tree.left != <span class="hljs-keyword">null</span>) &#123;            printTree(tree.left);        &#125;        System.out.print(tree.item + <span class="hljs-string">" "</span>);        <span class="hljs-keyword">if</span> (tree.right != <span class="hljs-keyword">null</span>) &#123;            printTree(tree.right);        &#125;    &#125;    <span class="hljs-comment">// 构建深度为N的折痕树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        Node root = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//1.第一次对折，只有一条折痕，创建根结点；</span>                root = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">"down"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">//2.如果不是第一次对折，则使用队列保存根结点；</span>                Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;&gt;();                queue.enqueue(root);                <span class="hljs-comment">//3.循环遍历队列：</span>                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    <span class="hljs-comment">//3.1从队列中拿出一个结点</span>                    Node tmp = queue.dequeue();                    <span class="hljs-comment">//3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中</span>                    <span class="hljs-keyword">if</span> (tmp.left != <span class="hljs-keyword">null</span>) &#123;                        queue.enqueue(tmp.left);                    &#125;                    <span class="hljs-comment">//3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中</span>                    <span class="hljs-keyword">if</span> (tmp.right != <span class="hljs-keyword">null</span>) &#123;                        queue.enqueue(tmp.right);                    &#125;                    <span class="hljs-comment">//3.4判断当前结点的左子结点和右子结点是否都为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</span>                    <span class="hljs-keyword">if</span> (tmp.left == <span class="hljs-keyword">null</span> &amp;&amp; tmp.right == <span class="hljs-keyword">null</span>) &#123;                        tmp.left = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">"down"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                        tmp.right = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">"up"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树最大深度和最小深度问题</title>
    <link href="/cxlittlecute/bb5d33c4.html"/>
    <url>/cxlittlecute/bb5d33c4.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树最大深度和最小深度问题"><a href="#二叉树最大深度和最小深度问题" class="headerlink" title="二叉树最大深度和最小深度问题"></a>二叉树最大深度和最小深度问题</h1><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>最大深度：树的根节点到最远叶子结点的最长路径上的结点数。</p><p>实现步骤：</p><ol><li>如果根结点为空，则最大深度为0；</li><li>计算左子树的最大深度；</li><li>计算右子树的最大深度；</li><li>当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 计算指定树x的最大深度</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node x)</span></span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// x的最大深度</span>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 左子树的最大深度</span>    <span class="hljs-keyword">int</span> maxL = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 右子树的最大深度</span>    <span class="hljs-keyword">int</span> maxR = <span class="hljs-number">0</span>;    <span class="hljs-comment">//2.计算左子树的最大深度；</span>    <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;        maxL = maxDepth(x.left);    &#125;    <span class="hljs-comment">//3.计算右子树的最大深度；</span>    <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;        maxR = maxDepth(x.right);    &#125;    <span class="hljs-comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span>    max = maxL &gt; maxR ? maxL + <span class="hljs-number">1</span> : maxR + <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><h2 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h2><p>最小深度：从根节点到最近叶节点的最短路径上的节点数。</p><p>实现步骤：</p><ol><li>如果根结点为空，则最小深度为0；</li><li>如果左子树为空，右子树不为空，最小深度=右子树的最小深度+1；</li><li>如果右子树为空，左子树不为空，最小深度=左子树的最小深度+1；</li><li>当前树的最小深度=左子树的最小深度和右子树的最小深度中的较小者+1。</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> minDepth(root);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(Node x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> minDepth(x.right) + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> minDepth(x.left) + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> Math.min(minDepth(x.left), minDepth(x.right)) + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的基本遍历</title>
    <link href="/cxlittlecute/86071d60.html"/>
    <url>/cxlittlecute/86071d60.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的基本遍历"><a href="#二叉树的基本遍历" class="headerlink" title="二叉树的基本遍历"></a>二叉树的基本遍历</h1><p>树需要我们选择用什么样的搜索路径进行遍历。</p><p>我们可以把树看做一个根节点、一个左子树、一个右子树组成，按照根节点什么时候被访问，我们可以分为以下四种情况：</p><ol><li>前序遍历:<br>先访问根结点，然后再访问左子树，最后访问右子树。</li><li>中序遍历:<br>先访问左子树，中间访问根节点，最后访问右子树。</li><li>后序遍历:<br>先访问左子树，再访问右子树，最后访问根节点。</li><li>层序遍历:<br>从根节点（第一层）开始，依次向下，获取每一层所有结点的值。</li></ol><p>通过以下的图例我们可以得到三种遍历的结果：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200728142006.png" srcset="/img/loading.gif" alt=""></p><p>那么接下来我们就通过代码分别实现这三种遍历方式。</p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>实现步骤：</p><ol><li>把当前结点的key放入到队列中;</li><li>找到当前结点的左子树，如果不为空，递归遍历左子树;</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用前序遍历，获取整个树中的所有键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">preErgodic</span><span class="hljs-params">()</span> </span>&#123;    Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    preErgodic(root, keys);    <span class="hljs-keyword">return</span> keys;&#125;<span class="hljs-comment">// 使用前序遍历，把指定树x中的所有键放入到keys队列中</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preErgodic</span><span class="hljs-params">(Node x, Queue&lt;Key&gt; keys)</span> </span>&#123;    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 1.将当前结点的key放入结点中</span>    keys.add((Key) x.key);    <span class="hljs-comment">// 2.找到当前结点的左子树，如果不为空，递归遍历左子树</span>    <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;        preErgodic(x.left, keys);    &#125;    <span class="hljs-comment">// 3.找到当前结点的右子树，如果不为空，递归遍历右子树</span>    <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;        preErgodic(x.right, keys);    &#125;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.preErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>实现步骤：</p><ol><li>找到当前结点的左子树，如果不为空，递归遍历左子树；</li><li>把当前结点的key放入到队列中;</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用中序遍历，获取整个树中的所有键</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">midErgodic</span><span class="hljs-params">()</span> </span>&#123;     Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();     midErgodic(root, keys);     <span class="hljs-keyword">return</span> keys; &#125; <span class="hljs-comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midErgodic</span><span class="hljs-params">(Node x, Queue&lt;Key&gt; keys)</span> </span>&#123;     <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;     &#125;     <span class="hljs-comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span>     <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;         midErgodic(x.left, keys);     &#125;     <span class="hljs-comment">//2.把当前结点的key放入到队列中;</span>     keys.add((Key) x.key);     <span class="hljs-comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span>     <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;         midErgodic(x.right, keys);     &#125; &#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.midErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>实现步骤：</p><ol><li>找到当前结点的左子树，如果不为空，递归遍历左子树;</li><li>找到当前结点的右子树，如果不为空，递归遍历右子树;</li><li>把当前结点的key放入到队列中。</li></ol><pre><code class="hljs java"><span class="hljs-comment">//使用后序遍历，获取整个树中的所有键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">afterErgodic</span><span class="hljs-params">()</span></span>&#123;    Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    afterErgodic(root,keys);    <span class="hljs-keyword">return</span> keys;&#125;<span class="hljs-comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterErgodic</span><span class="hljs-params">(Node x,Queue&lt;Key&gt; keys)</span></span>&#123;    <span class="hljs-keyword">if</span> (x==<span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span>    <span class="hljs-keyword">if</span> (x.left!=<span class="hljs-keyword">null</span>)&#123;        afterErgodic(x.left,keys);    &#125;    <span class="hljs-comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span>    <span class="hljs-keyword">if</span> (x.right!=<span class="hljs-keyword">null</span>)&#123;        afterErgodic(x.right,keys);    &#125;    <span class="hljs-comment">//3. 把当前结点的key放入到队列中;</span>    keys.add((Key) x.key);&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.afterErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200728154653.png" srcset="/img/loading.gif" alt=""></p><p>层序遍历结果为： EBGADFHC</p><p>对上图进行层序遍历图例分析：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200728155023.png" srcset="/img/loading.gif" alt=""></p><p>实现步骤：</p><ol><li>创建队列，存储每一层的结点；</li><li>使用循环从队列中弹出一个结点：<br> 2.1 获取当前结点的key；<br> 2.2 如果当前结点的左子结点不为空，则把左子结点放入到队列中。<br> 2.3 如果当前结点的右子结点不为空，则把右子结点放入到队列中。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用层序遍历得到树中所有的键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Queue&lt;Key&gt; <span class="hljs-title">layerErgodic</span><span class="hljs-params">()</span> </span>&#123;    Queue&lt;Key&gt; keys = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    Queue&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();    nodes.add(root);    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;        Node x = nodes.poll();        keys.add((Key) x.key);        <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;            nodes.add(x.left);        &#125;        <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;            nodes.add(x.right);        &#125;    &#125;    <span class="hljs-keyword">return</span> keys;&#125;</code></pre><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BinaryTree&lt;String, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-string">"E"</span>, <span class="hljs-string">"5"</span>);        bt.put(<span class="hljs-string">"B"</span>, <span class="hljs-string">"2"</span>);        bt.put(<span class="hljs-string">"G"</span>, <span class="hljs-string">"7"</span>);        bt.put(<span class="hljs-string">"A"</span>, <span class="hljs-string">"1"</span>);        bt.put(<span class="hljs-string">"D"</span>, <span class="hljs-string">"4"</span>);        bt.put(<span class="hljs-string">"F"</span>, <span class="hljs-string">"6"</span>);        bt.put(<span class="hljs-string">"H"</span>, <span class="hljs-string">"8"</span>);        bt.put(<span class="hljs-string">"C"</span>, <span class="hljs-string">"3"</span>);        Queue&lt;String&gt; queue = bt.layerErgodic();        <span class="hljs-keyword">for</span> (String key : queue) &#123;            System.out.println(key+<span class="hljs-string">"="</span>+bt.get(key));        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉查找树的创建</title>
    <link href="/cxlittlecute/16592e4a.html"/>
    <url>/cxlittlecute/16592e4a.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h1><h2 id="二叉树的基本定义"><a href="#二叉树的基本定义" class="headerlink" title="二叉树的基本定义"></a>二叉树的基本定义</h2><p>首先我们来回顾一下什么是二叉树，二叉树有哪些分类。</p><ul><li><p>二叉树：<br>  二叉树就是度不超过 2的树(每个结点最多有两个子结点)。</p><p>  <img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727153402.png" srcset="/img/loading.gif" alt=""></p></li><li><p>满二叉树：<br>  一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。节点数的计算n=2^k - 1,k表示深度，也就是层数，第i层的节点数n= 2^(i- 1),它的节点数是一系列固定的数，如果节点数不是序列中的数的话，就不是满二叉树</p><p>  <img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727153507.png" srcset="/img/loading.gif" alt=""></p></li><li><p>完全二叉树<br>  叶节点只能出现在最下层和次下层，当二叉树的深度为h时，它的h层节点必须都是连续靠左并不可隔开的(满二叉树也符合)，并且1～h-1层的结点数都达到最大个数(即1~h-1层为一个满二叉树)。<br>  （也就是说我们往完全二叉树放元素的时候，我们都是在非满的一层从左往右放结点）</p></li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727154354.png" srcset="/img/loading.gif" alt=""></p><p>注意：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。</p><h2 id="二叉查找树的创建-1"><a href="#二叉查找树的创建-1" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h2><p>我们根据上面的图看出，树其实就是一个个结点组成的，那么我们就利用面向对象的思想，来设计二叉树。</p><ol><li><p>创建Node结点类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">Key</span>, <span class="hljs-title">Value</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> Node left;    <span class="hljs-comment">// 记录左子结点</span>    <span class="hljs-keyword">public</span> Node right;   <span class="hljs-comment">// 记录左子结点</span>    <span class="hljs-keyword">public</span> Key key;      <span class="hljs-comment">// 存储键</span>    <span class="hljs-keyword">public</span> Value value;  <span class="hljs-comment">// 存储值</span>    <span class="hljs-comment">// 创建Node对象</span>    Node(Key key, Value value, Node left, Node right) &#123;        <span class="hljs-keyword">this</span>.key = key;        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;</code></pre></li><li><p>插入方法put（）实现分析：</p><ul><li><p>如果当前树中没有任何一个结点，则直接把新结点当做根结点使用。</p></li><li><p>如果当前树不为空，则从根结点开始：（三种情况）</p><ul><li>如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</li><li>如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</li><li>如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</li></ul></li></ul></li></ol><pre><code class="hljs java"><span class="hljs-comment">//向树中添加元素key-value</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key, Value value)</span> </span>&#123;    root = put(root, key, value);&#125;<span class="hljs-comment">//向指定的树x中添加key-value,并返回添加元素后新的树</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x, Key key, Value value)</span> </span>&#123;    <span class="hljs-comment">//如果x子树为空，</span>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        N++;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(key, value, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-comment">//如果x子树不为空</span>    <span class="hljs-comment">//比较x结点的键和key的大小：</span>    <span class="hljs-keyword">int</span> cmp = key.compareTo(x.key);    <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key大于x结点的键，则继续找x结点的右子树</span>        x.right = put(x.right, key, value);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>        x.left = put(x.left, key, value);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果key等于x结点的键，则替换x结点的值为value即可</span>        x.value = value;    &#125;    <span class="hljs-keyword">return</span> x;&#125;</code></pre><ol start="3"><li><p>查询方法get实现分析：</p><p> 从根节点开始：</p><ul><li>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</li><li>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</li><li>如果要查询的key等于当前结点的key，则树中返回当前结点的value。</li></ul></li></ol><pre><code class="hljs java"><span class="hljs-comment">//查询树中指定key对应的value</span><span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Key key)</span> </span>&#123;    <span class="hljs-keyword">return</span> get(root, key);&#125;<span class="hljs-comment">//从指定的树x中，查找key对应的值</span><span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Node x, Key key)</span> </span>&#123;    <span class="hljs-comment">//x树为null</span>    <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">//x树不为null</span>    <span class="hljs-comment">//比较key和x结点的键的大小</span>    <span class="hljs-keyword">int</span> cmp = key.compareTo(x.key);    <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key大于x结点的键，则继续找x结点的右子树</span>        <span class="hljs-keyword">return</span> get(x.right, key);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>        <span class="hljs-keyword">return</span> get(x.left, key);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可</span>        <span class="hljs-keyword">return</span> x.value;    &#125;&#125;</code></pre><ol start="4"><li><p>删除方法delete()实现分析：</p><ul><li>找到被删除结点；</li><li>找到被删除结点右子树中的最小结点minNode</li><li>删除右子树中的最小结点</li><li>让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树</li><li>让被删除结点的父节点指向最小结点minNode</li></ul></li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span>&lt;<span class="hljs-title">Key</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Key</span>&gt;, <span class="hljs-title">Value</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Node root; <span class="hljs-comment">//记录根结点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> N; <span class="hljs-comment">//记录树中元素的个数</span>    <span class="hljs-comment">// 向树中插入一个键值对</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Key key, Value value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.root = put(root, key, value);    &#125;    <span class="hljs-comment">// 给指定树x上，添加键一个键值对，并返回添加后的新树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">put</span><span class="hljs-params">(Node x, Key key, Value val)</span> </span>&#123;        <span class="hljs-comment">// 如果root为空也就是没有root结点，则将当前结点作为root结点</span>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            N++;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node&lt;Key, Value&gt;(key, val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        &#125;        <span class="hljs-comment">// 如果不为空，就需要比较结点的key大小</span>        <span class="hljs-keyword">int</span> cmp = key.compareTo((Key) x.key);        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;            x.right = put(x.right, key, val);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>            x.left = put(x.left, key, val);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果key等于x结点的键，则替换x结点的值为value即可</span>            x.value = val;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-comment">// 根据key，从树中找出对应的值</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Key key)</span> </span>&#123;        <span class="hljs-keyword">return</span> get(root, key);    &#125;    <span class="hljs-comment">// 从指定的树x中，找出key对应的值</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Value <span class="hljs-title">get</span><span class="hljs-params">(Node x, Key key)</span> </span>&#123;        <span class="hljs-comment">// x为null</span>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// x树不为空</span>        <span class="hljs-comment">// 比较key和x结点的键的大小</span>        <span class="hljs-keyword">int</span> cmp = key.compareTo((Key) x.key);        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果key大于x结点的键，则继续找x结点的右子树</span>            <span class="hljs-keyword">return</span> get(x.right, key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 如果key小于x结点的键，则继续找x结点的左子树</span>            <span class="hljs-keyword">return</span> get(x.left, key);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可</span>            <span class="hljs-keyword">return</span> (Value) x.value;        &#125;    &#125;    <span class="hljs-comment">// 根据key，删除树中对应的键值对</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Key key)</span> </span>&#123;        delete(root, key);    &#125;    <span class="hljs-comment">// 删除指定树x上的键为key的键值对，并返回删除后的新树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node x, Key key)</span> </span>&#123;        <span class="hljs-comment">// x树为null</span>        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// x树不为null</span>        <span class="hljs-keyword">int</span> cmp = key.compareTo((Key) x.key);        <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果key大于x结点的键，则继续找x结点的右子树</span>            x.right = delete(x.right, key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//如果key小于x结点的键，则继续找x结点的左子树</span>            x.left = delete(x.left, key);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 让元素个数-1</span>            N--;            <span class="hljs-comment">//如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；</span>            <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 右子树为空</span>                <span class="hljs-keyword">return</span> x.left;            &#125;            <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 左子树为空</span>                <span class="hljs-keyword">return</span> x.right;            &#125;            <span class="hljs-comment">// 得找到右子树中最小的结点</span>            Node minNode = x.right;            <span class="hljs-keyword">while</span> (minNode.left != <span class="hljs-keyword">null</span>)&#123;                minNode = minNode.left;            &#125;            <span class="hljs-comment">// 删除右子树中最小的结点</span>            Node n = x.right;            <span class="hljs-keyword">while</span> (n.left != <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">if</span> (n.left.left == <span class="hljs-keyword">null</span>)&#123;                    n.left = <span class="hljs-keyword">null</span>;                &#125;<span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 变换n结点即可</span>                    n = n.left;                &#125;            &#125;            <span class="hljs-comment">// 让x结点的左子树成为minNode的左子树</span>            minNode.left = x.left;            <span class="hljs-comment">// 让x结点的右子树成为minNode的右子树</span>            minNode.right = x.right;            <span class="hljs-comment">// 让x结点的父结点指向minNode</span>            x = minNode;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-comment">// 获取树中元素的个数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> N;    &#125;&#125;</code></pre><ol start="5"><li>测试：<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BinaryTree&lt;Integer, String&gt; bt = <span class="hljs-keyword">new</span> BinaryTree&lt;&gt;();        bt.put(<span class="hljs-number">4</span>, <span class="hljs-string">"二哈"</span>);        bt.put(<span class="hljs-number">1</span>, <span class="hljs-string">"张三"</span>);        bt.put(<span class="hljs-number">3</span>, <span class="hljs-string">"李四"</span>);        bt.put(<span class="hljs-number">5</span>, <span class="hljs-string">"王五"</span>);        System.out.println(bt.size());        bt.put(<span class="hljs-number">1</span>,<span class="hljs-string">"老三"</span>);        System.out.println(bt.get(<span class="hljs-number">1</span>));        System.out.println(bt.size());        bt.delete(<span class="hljs-number">1</span>);        System.out.println(bt.size());        System.out.println(bt.get(<span class="hljs-number">1</span>));    &#125;&#125;</code></pre></li></ol><h2 id="二叉查找树的其他方法："><a href="#二叉查找树的其他方法：" class="headerlink" title="二叉查找树的其他方法："></a>二叉查找树的其他方法：</h2><h3 id="查找二叉树中的最小和最大值"><a href="#查找二叉树中的最小和最大值" class="headerlink" title="查找二叉树中的最小和最大值"></a>查找二叉树中的最小和最大值</h3><p>在某些情况下，我们需要查找出树中存储所有元素的键的最小和最大值，比如我们的树中存储的是学生的排名和姓名数据，那么需要查找出排名最高最低是谁。</p><pre><code class="hljs java"><span class="hljs-comment">//查找整个树中最小的键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (Key) min(root).key;&#125;<span class="hljs-comment">//在指定树x中找出最小键所在的结点</span><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">min</span><span class="hljs-params">(Node x)</span> </span>&#123;    <span class="hljs-comment">//需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点</span>    <span class="hljs-keyword">if</span> (x.left != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> min(x.left);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> x;    &#125;&#125;<span class="hljs-comment">//在整个树中找到最大的键</span><span class="hljs-function"><span class="hljs-keyword">public</span> Key <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> (Key) max(root).key;&#125;<span class="hljs-comment">//在指定的树x中，找到最大的键所在的结点</span><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">max</span><span class="hljs-params">(Node x)</span> </span>&#123;    <span class="hljs-comment">//判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点</span>    <span class="hljs-keyword">if</span> (x.right != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> max(x.right);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> x;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本定义和相关术语</title>
    <link href="/cxlittlecute/291a9097.html"/>
    <url>/cxlittlecute/291a9097.html</url>
    
    <content type="html"><![CDATA[<h1 id="树的基本定义和相关术语"><a href="#树的基本定义和相关术语" class="headerlink" title="树的基本定义和相关术语"></a>树的基本定义和相关术语</h1><p>树的一些基本定义和术语还是很重要的，再次总结它，是为了更好的向别人描述清楚树是什么东西，而不是停留在感觉自己懂，但是讲不清楚的状态。</p><h2 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h2><p>树是一种非常重要的数据结构，主要是它能大量应用于我们生活中的一些事物，例如：家族和单位的组织架构等等。</p><p>树是由（n&gt;=1)个有限结点组成的一个具有层次关系的集合。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727145343.png" srcset="/img/loading.gif" alt=""></p><h2 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h2><ol><li>每个结点有零个或多个子结点。</li><li>根节点没有父节点。</li><li>每一个非根结点只有一个父结点。</li><li>我们可以把每个结点及其子结点整体上看做是一棵树，称为当前结点的父结点的一个子树。</li></ol><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><h4 id="结点的度"><a href="#结点的度" class="headerlink" title="结点的度"></a>结点的度</h4><p>一个结点拥有子结点的数量称为该结点的度。</p><h4 id="叶结点"><a href="#叶结点" class="headerlink" title="叶结点"></a>叶结点</h4><p>度为0的结点称为叶结点，也可以叫做终端结点。</p><h4 id="分支结点"><a href="#分支结点" class="headerlink" title="分支结点"></a>分支结点</h4><p>度不为0的结点称为分支结点，也可以叫做非终端结点。</p><h4 id="结点的层次"><a href="#结点的层次" class="headerlink" title="结点的层次"></a>结点的层次</h4><p>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。</p><h4 id="结点的层序编号"><a href="#结点的层序编号" class="headerlink" title="结点的层序编号"></a>结点的层序编号</h4><p> 将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</p><h4 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h4><p>树中所以结点的度的最大值。</p><h4 id="树的高度-深度"><a href="#树的高度-深度" class="headerlink" title="树的高度(深度)"></a>树的高度(深度)</h4><p>树中结点的最大层次</p><h4 id="孩子结点"><a href="#孩子结点" class="headerlink" title="孩子结点"></a>孩子结点</h4><p>一个结点的直接后继结点称为该结点的孩子结点。</p><h4 id="双亲结点-父结点"><a href="#双亲结点-父结点" class="headerlink" title="双亲结点(父结点)"></a>双亲结点(父结点)</h4><p>一个结点的直接前驱称为该结点的双亲结点。</p><h4 id="兄弟结点"><a href="#兄弟结点" class="headerlink" title="兄弟结点"></a>兄弟结点</h4><p>同一双亲结点的孩子结点间互称兄弟结点。</p><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><p>m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200727151238.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hashcode和equals方法为什么要重写</title>
    <link href="/cxlittlecute/910e2ef6.html"/>
    <url>/cxlittlecute/910e2ef6.html</url>
    
    <content type="html"><![CDATA[<h1 id="hashcode和equals方法为什么要重写"><a href="#hashcode和equals方法为什么要重写" class="headerlink" title="hashcode和equals方法为什么要重写"></a>hashcode和equals方法为什么要重写</h1><p>我们知道Java的顶级父类Object中有两个方法，经常被重写，一个是equals()另一个是hashcode。而且只要我们重写了equals方法我们就必须重写hashcode。</p><p>那么我们的疑问就是为什么要这样，如果我们不同时重写它们两个方法又会发生什么事情了？</p><h2 id="Object源码分析"><a href="#Object源码分析" class="headerlink" title="Object源码分析"></a>Object源码分析</h2><p>我们首先来看一看在Object类中的equals和hashcode：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == var1;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;</code></pre><p>我们可以看到Object类中的equals方法，在不被重写的情况下，使用是和我们==比较是一样的。比较的是非空对象的引用地址，而非对象本身的字符串内容或数值是否相同。</p><p>（==和equals的区别可查看我的另一篇文章：<a href="http://ccctop.cn/cxlittlecute/f30662c7.html）" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/f30662c7.html）</a></p><p>hashcode方法被native关键字修饰，如果不了解native关键字下面简单介绍了一下：</p><p>1、一个native方法就是一个Java调用非Java代码的接口。一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。</p><p>2、在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外面实现的。</p><p>3、因为JAVA无法对操作系统底层进行操作，但是可以通过jni(java native interface)调用其他语言来实现底层的访问。</p><p>hashCode方法本质就是一个哈希函数，就是将我们对象的地址映射为Integer类型的哈希值。</p><p>同时在Object类中规定：当我们将equals方法重写后有必要将hashCode方法也重写，这样做才能保证不违背hashCode方法中“相同对象必须有相同哈希值”的约定。</p><h2 id="为什么要遵循相同对象必须有相同哈希值的约定了？"><a href="#为什么要遵循相同对象必须有相同哈希值的约定了？" class="headerlink" title="为什么要遵循相同对象必须有相同哈希值的约定了？"></a>为什么要遵循相同对象必须有相同哈希值的约定了？</h2><p>在hashCode方法注释中，我们可以知道：</p><ol><li>一个对象多次调用它的hashCode方法，应当返回相同的integer（哈希值）。</li><li>两个对象如果通过equals方法判定为相等，那么就应当返回相同integer。</li><li>两个地址值不相等的对象调用hashCode方法不要求返回不相等的integer。</li></ol><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200726184559.png" srcset="/img/loading.gif" alt=""></p><p>也就是说这是一条规范，如果不这样做就会导致Object类无法结合所有基于散列的集合（HashMap,HashSet,HashTable）一起正常运作。</p><p>如果相同的对象也就是，重写了equals比较返回true的对象，不重写hashcode,导致具有不同的hashCode，那么将对象放入hashMap中，对象会被存放到不同的桶中，当去get 时，虽然是同一个对象，但是由于生成的hashCode不同，会到不同的桶中去找，此时便找不到那个对象。</p><p>所以我们的equals方法必须要和hashcode配套使用。hashcode方法要做的事情就是，当equals方法认定为相同的对象时，要返回相同的哈希值。</p><h2 id="为什么说不重写它们两个方法在集合中就不能使用了？"><a href="#为什么说不重写它们两个方法在集合中就不能使用了？" class="headerlink" title="为什么说不重写它们两个方法在集合中就不能使用了？"></a>为什么说不重写它们两个方法在集合中就不能使用了？</h2><p>根据上面我们知道了，hashCode方法是根据对象的地址生成的一个Integer整数，默认它和地址一一对应的，如果不重写，那么只有对象地址一样的情况下，哈希值才相等。</p><p>equals默认用来比较地址是否相同，但当集合中元素增多时，再使用equals判断，效率是比较低的；而哈希值是可以快速定位到指定的元素的，所以默认Java就使用哈希值来比较定位，因此有了Object.hashCode的约定。</p><p>总结：除非你能保证你重写equals的类不被Set,Map使用，否则你就必须同时重写equals和hashCode。</p><p>1.使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</p><p>2.保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</p><h2 id="如何重写equals与hashCode？"><a href="#如何重写equals与hashCode？" class="headerlink" title="如何重写equals与hashCode？"></a>如何重写equals与hashCode？</h2><ol><li>重写equals：<ul><li>通过==判断是否是同一个引用</li><li>通过instanceof判断是否是相同类型</li><li>把参数转为正确的类型</li><li>对比双方各个属性值是否相同<pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;     <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;     Goods goods = (Goods) o;     <span class="hljs-keyword">return</span> Double.compare(goods.price, price) == <span class="hljs-number">0</span> &amp;&amp;             Objects.equals(name, goods.name); &#125;</code></pre></li></ul></li></ol><ol start="2"><li>重写hashCode<ul><li>hashCode方法应该为“不相等的对象产生不相等的哈希值”</li><li>计算是根据你equals中用来比较的属性的hashCode组合计算的，不过目前JDK和一些类库已经给我提供了很好的重写方式<pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Objects.hash(name, price);&#125;</code></pre>或者使用lombok：<pre><code class="hljs java"><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>, <span class="hljs-title">Comparator</span> </span>&#123;&#125;</code></pre></li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；</li><li>重写equals()必须重写hashCode()，二者参与计算的自身属性字段应该相同；</li><li>hash类型的存储结构，添加元素重复性校验的标准就是先取hashCode值，后判断equals()；</li><li>equals()相等的两个对象，hashcode()一定相等；</li><li>反过来：hashcode()不等，一定能推出equals()也不等；<br>hashcode()相等，equals()可能相等，也可能不等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的DFS和BFS</title>
    <link href="/cxlittlecute/e494e2f9.html"/>
    <url>/cxlittlecute/e494e2f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h1><p>上一篇博客记录了自己初次学习图遍历的代码实现方法，有朋友评论讲的过于细致化，今天刚好重新参考看了一篇博客的实现，相比来说确实要简单明了很多，于是再次记录关于DFS和BFS的相关内容。</p><p>上一篇博客：<a href="http://ccctop.cn/cxlittlecute/f1a8c9e2.html" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/f1a8c9e2.html</a></p><p>如果上一篇博客没有太明白的朋友，可以参考看一看这一篇。</p><p>上一篇博客我们说了图的实现方式主要是邻接矩阵和邻接表，那么今天我们就用邻接表再次分析图的DFS和BFS过程。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725204054.png" srcset="/img/loading.gif" alt=""></p><h2 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h2><ul><li>使用一个大小为V的数组 List<Integer>[] head（通图adj[]），把索引看做是顶点</li><li>每个索引处head[v]存储了一个数组或队列，该队列中存储的是所有与该顶点相邻的其他顶点</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> Graph2</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 14:12</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph2</span> </span>&#123;    <span class="hljs-comment">// 记录顶点的个数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> V;    <span class="hljs-comment">// 保存头结点</span>    List&lt;Integer&gt;[] head;    <span class="hljs-comment">// 记录边的数量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;    Graph2(<span class="hljs-keyword">int</span> V) &#123;        <span class="hljs-keyword">this</span>.V = V;        <span class="hljs-keyword">this</span>.E = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> ArrayList[V];        <span class="hljs-comment">// 初始化邻接表中的队列</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; V ;i++)&#123;            head[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        &#125;    &#125;    <span class="hljs-comment">// 获取图中顶点的数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">V</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> V;    &#125;    <span class="hljs-comment">// 获取图中边的数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">E</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> E;    &#125;    <span class="hljs-comment">// 向图中添加一条边</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;        head[v].add(w);        head[w].add(v);        E++;    &#125;    <span class="hljs-comment">//获取和顶点v相邻的所有顶点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">adj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;        <span class="hljs-keyword">return</span> head[v];    &#125;&#125;</code></pre><h2 id="DFS的实现"><a href="#DFS的实现" class="headerlink" title="DFS的实现"></a>DFS的实现</h2><p>所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205248.png" srcset="/img/loading.gif" alt=""></p><p>我们可以根据上图清楚的知道DFS的一个执行顺序。<br>很明显，在由于边是没有方向的，所以，如果 4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true，<br>如果没有搜索，标记为false；</p><p>主要有两点需要注意：</p><ol><li>如果已经访问过的会直接跳过。</li><li>由于是DFS是深度优先，所以我们每次遍历都会以邻接结点为下一次遍历的头。（特点）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearch</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 17:42</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepthFirstSearch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    DepthFirstSearch(Graph2 G,<span class="hljs-keyword">int</span> s)&#123;        <span class="hljs-keyword">this</span>.marked  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        dfs(G,s);    &#125;    <span class="hljs-comment">// 使用深度优先搜索找出G图中v顶点的所有相通顶点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Graph2 G, <span class="hljs-keyword">int</span> v)</span></span>&#123;        System.out.print(v+<span class="hljs-string">"-&gt;"</span>);        <span class="hljs-comment">// 把v顶点标识为以搜索</span>        marked[v] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (Integer w : G.adj(v)) &#123;            <span class="hljs-comment">// 判断有没有被搜索过，如果没有被搜索过则递归调用dfs进行深度搜索</span>            <span class="hljs-keyword">if</span> (!marked[w])&#123;                dfs(G, w);            &#125;        &#125;        count++;    &#125;    <span class="hljs-comment">// 判断w顶点与s顶点是否相通</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">marked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;        <span class="hljs-keyword">return</span> marked[w];    &#125;    <span class="hljs-comment">// 获取与顶点s相通的所有顶点的总数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>照着下面的图片进行建图然后测试：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205322.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearchTest</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 18:32</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepthFirstSearchTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备图</span>        Graph2 graph2 = <span class="hljs-keyword">new</span> Graph2(<span class="hljs-number">13</span>);        <span class="hljs-comment">// 准备结点</span>        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);                graph2.addEdge(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        <span class="hljs-comment">// 准备要DFS搜索的对象</span>        DepthFirstSearch depthFirstSearch = <span class="hljs-keyword">new</span> DepthFirstSearch(graph2, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 测试与某个顶点相同的顶点数量</span>        <span class="hljs-keyword">int</span> count = depthFirstSearch.count();        System.out.println(count);        <span class="hljs-comment">// 测试某个顶点是否与起点想通</span>        <span class="hljs-keyword">boolean</span> marked = depthFirstSearch.marked(<span class="hljs-number">5</span>);        System.out.println(marked);    &#125;&#125;</code></pre><h2 id="BFS实现"><a href="#BFS实现" class="headerlink" title="BFS实现"></a>BFS实现</h2><p>而BFS刚好相反，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205105.png" srcset="/img/loading.gif" alt=""></p><p>如果我们现在以0为顶点，它会先去找0这个顶点的邻接表，也就是有6、2、1、5这几个相邻的顶点，然后我们分别以这几个相邻的点为顶点去找它们的邻接表。（类似于二叉树的层序遍历）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725205132.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> BreadthFirstSearch</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 21:02</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadthFirstSearch</span> </span>&#123;    <span class="hljs-comment">// 索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;    <span class="hljs-comment">// 记录有多少个顶点与s顶点相通</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">// 用来存储待搜索邻接表的点</span>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; waitSearch;    <span class="hljs-comment">// 构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点</span>    BreadthFirstSearch(Graph2 G, <span class="hljs-keyword">int</span> s) &#123;        <span class="hljs-keyword">this</span>.marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.waitSearch = <span class="hljs-keyword">new</span> Queue&lt;Integer&gt;();        bfs(G, s);    &#125;    <span class="hljs-comment">// 使用广度优先搜索找出G图中v顶点的所有相邻顶点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Graph2 G, <span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-comment">// 把当前顶点标记为已搜索</span>        marked[v] = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 让顶点v进入队列，待搜索</span>        waitSearch.enqueue(v);        <span class="hljs-comment">// 通过循环，如果队列不为空，则从队列中，则从队列汇总弹出一个待搜索的顶点，进行搜索</span>        <span class="hljs-keyword">while</span> (!waitSearch.isEmpty()) &#123;            <span class="hljs-comment">// 弹出待搜索的顶点</span>            <span class="hljs-keyword">try</span> &#123;                Integer wait = waitSearch.dequeue();                <span class="hljs-comment">// 遍历wait顶点的邻接表</span>                <span class="hljs-keyword">for</span> (Integer w : G.adj(wait)) &#123;                    <span class="hljs-comment">// 判断是否被搜索</span>                    <span class="hljs-keyword">if</span> (!marked[w])&#123;                        bfs(G, w);                    &#125;                &#125;                <span class="hljs-comment">/* 第二种方式：</span><span class="hljs-comment">                for (Integer w : G.adj(wait)) &#123;</span><span class="hljs-comment">                    if (!marked[w])&#123;</span><span class="hljs-comment">                        System.out.print(w+"-&gt;");</span><span class="hljs-comment">                        waitSearch.enqueue(w);</span><span class="hljs-comment">                        marked[w] = true;</span><span class="hljs-comment">                    &#125;</span><span class="hljs-comment">                &#125;*/</span>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-comment">// 想通的结点+1</span>        count++;    &#125;    <span class="hljs-comment">// 判断w顶点与s顶点是否相通</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">marked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span> </span>&#123;        <span class="hljs-keyword">return</span> marked[w];    &#125;    <span class="hljs-comment">// 获取与顶点s相通的所有顶点的总数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre><p>注意：BFS会把兄弟结点访问完毕了，也就是队列中的结点，然后再以队列中的每个结点为头找他们的子结点。</p><p>测试：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearchTest</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 18:32</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadFirstSearchTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备图</span>        Graph2 graph2 = <span class="hljs-keyword">new</span> Graph2(<span class="hljs-number">13</span>);        <span class="hljs-comment">// 准备结点</span>        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        <span class="hljs-comment">// 准备要DFS搜索的对象</span>        BreadthFirstSearch search = <span class="hljs-keyword">new</span> BreadthFirstSearch(graph2, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 测试与某个顶点相同的顶点数量</span>        <span class="hljs-keyword">int</span> count = search.count();        System.out.println(count);        <span class="hljs-comment">// 测试某个顶点是否与起点想通</span>        <span class="hljs-keyword">boolean</span> marked = search.marked(<span class="hljs-number">5</span>);        System.out.println(marked);    &#125;&#125;</code></pre><p>这样的方式实现就会更加明了简单，如果还没有明白的朋友可以debug一下跑一跑。如果还有任何优化建议的朋友，可以在评论区留言，我会第一时间回复。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/cxlittlecute/f1a8c9e2.html"/>
    <url>/cxlittlecute/f1a8c9e2.html</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>所谓的图的遍历就是对图中结点的访问，一个图有很多的结点，我们如何去遍历它们了？</p><p>那么需要我们制定相应的访问策略：</p><ul><li>方式一：深度优先遍历（DFS）</li><li>方式二：广度优先遍历（BFS)</li></ul><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><h3 id="DFS思想"><a href="#DFS思想" class="headerlink" title="DFS思想"></a>DFS思想</h3><ul><li>深度优先遍历，从你定的初始访问结点出发，那么我们初始访问结点可能有很多邻接结点，深度优先遍历的策略就是：首先访问第一个邻接结点，然后再以这个被访问的临界点作为初始结点，访问它的第一个邻接结点。（总之，就是每次访问完当前结点后首先访问当前结点的第一个邻接结点）</li></ul><p>举例：如果说v1-&gt;v2-&gt;v3同时v1-&gt;v3,那么通过DFS仍然是通过v2才访问到v3的。</p><ul><li>我们可以通过上面的例子看到，这种访问策略是优先向纵向挖掘深度，而不是对一个结点的所有邻接结点进行横向访问。</li><li>DFS是一个递归过程。</li></ul><h3 id="DFS算法步骤"><a href="#DFS算法步骤" class="headerlink" title="DFS算法步骤"></a>DFS算法步骤</h3><ol><li>访问初始结点v,并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当成一个另一个v，进行123操作）</li><li>若w已经被访问了，查找结点v的邻接结点w的下一个邻接结点，进入步骤3</li></ol><h3 id="DFS举例分析"><a href="#DFS举例分析" class="headerlink" title="DFS举例分析"></a>DFS举例分析</h3><p>那么我们举例来分析一下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724144623.png" srcset="/img/loading.gif" alt=""></p><p>我们在集合中存放结点的顺序是ABCDE。<br>那么我们通过DFS遍历的步骤是：</p><ol><li>A的邻接结点为B，B存在同时未被访问，这样就遍历到了B</li><li>接着对B进行DFS递归，把B当成初始结点同上访问到了C</li><li>这个时候我们已经把C当做了初始结点了，C的下一个邻接结点应该是D，但是它们并不是连通的</li><li>于是D就不能马上输出，则执行DFS算法步骤的第3步，从v的下一个结点继续，也就是从B继续</li><li>这个时候发现C已经被访问了，则会查找B的邻接结点C的下一个邻接结点也就是D，这样就能完成我们的DFS遍历。</li></ol><h3 id="DFS代码实现"><a href="#DFS代码实现" class="headerlink" title="DFS代码实现"></a>DFS代码实现</h3><ol><li>定义给数组boolean[],记录某个结点是否被访问过:<pre><code class="hljs java"><span class="hljs-comment">//定义给数组boolean[],记录某个结点是否被访问过</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isVisited;</code></pre></li><li>得到第一个邻接结点的下标w<pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 得到第一个邻接结点的下标w</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 当前结点的下标</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果存在就返回对应下标，否则返回-1</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFirstNeighbor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexList.size(); j++) &#123;        <span class="hljs-keyword">if</span> (edges[index][j] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据矩阵中的值大于0说明当前结点的下一个邻接结点是存在的</span>            <span class="hljs-keyword">return</span> j;        &#125;    &#125;    <span class="hljs-comment">//如果存在就返回对应的下0标否则返回-1</span>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></li><li>根据前一个邻接结点的下标来获取下一个邻接结点 等同于第五步<pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据前一个邻接结点的下标来获取下一个邻接结点 等同于第五步</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v1 结点v</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v2 结点v的邻接结点w</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNeighhor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v2 + <span class="hljs-number">1</span>; j &lt; vertexList.size(); j++) &#123;        <span class="hljs-keyword">if</span> (edges[v1][j] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> j;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></li><li>深度优先遍历算法实现(部分方法衔接 博客：图-<a href="http://ccctop.cn/cxlittlecute/ee040603.html" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/ee040603.html</a>)</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *深度优先遍历算法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isVisited</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i 第一次就是0,等于说进入步骤第一步</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-comment">//首先我们访问该结点，输出</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">"-&gt;"</span>); <span class="hljs-comment">//返回结点i（下标）对应的数据0-&gt;"A"  1-&gt;"B"  2-&gt;"c"</span>    <span class="hljs-comment">//将已经访问的结点设置为已经访问过</span>    isVisited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//查找结点i的第一个邻接结点w  等于步骤第二步</span>    <span class="hljs-keyword">int</span> w = getFirstNeighbor(i);    <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//说明有邻接结点 使用while循环的原因是如果存在就会继续往下递归</span>        <span class="hljs-keyword">if</span> (!isVisited[w]) &#123; <span class="hljs-comment">// 说明没有被访问</span>            dfs(isVisited, w);        &#125;        <span class="hljs-comment">//如果w这个结点已经被访问过,我们就应该访问邻接结点的下一个结点</span>        w = getNextNeighhor(i, w);    &#125;&#125;</code></pre><p>但是写到这里并没有结束，因为我们第3步中-回到第1步，将从v的下一个结点继续，这一步骤还未完成,不然会出现中间有一个结点走不下去程序就结束了。</p><pre><code class="hljs java"><span class="hljs-comment">// 对dfs进行重载</span><span class="hljs-comment">// 因为我们第3步中-回到第1步，将从v的下一个结点继续，这一步骤还未完成,不然会出现中间有一个结点走不下去程序就结束了</span><span class="hljs-comment">// 遍历我们所有的结点，并进行dfs</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 遍历所有的结点，进行dfs【回溯】</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            dfs(isVisited, i);        &#125;    &#125;&#125;</code></pre><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><h3 id="BFS思想"><a href="#BFS思想" class="headerlink" title="BFS思想"></a>BFS思想</h3><p>BFS需要使用一个队列，用来保存访问过的结点的顺序，类似于一个分层搜索的过程，我们使用这个顺序来访问这些结点的邻接结点。</p><h3 id="BFS算法步骤"><a href="#BFS算法步骤" class="headerlink" title="BFS算法步骤"></a>BFS算法步骤</h3><ol><li>访问初始结点v并标记结点v为已访问</li><li>将结点v加入队列</li><li>当队列非空时，继续执行，否则算法结束（这里的算法结束指的是对v这个结点的算法结束）。</li><li>出队列，取得头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行下面三个步骤：<br> 6.1 若结点w未被访问，则访问w并标记为已访问。<br> 6.2 结点w入队列。(w的访问顺序同样也被记录在队列中)<br> 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol><h3 id="BFS举例分析"><a href="#BFS举例分析" class="headerlink" title="BFS举例分析"></a>BFS举例分析</h3><p>我们同样来举例分析一下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724180549.png" srcset="/img/loading.gif" alt=""></p><ol><li>我们还是从A开始，先访问自己，A就输出了</li><li>接着看A的下一个邻接结点B，判断B能访问于是B也就被输出了</li><li>接着就和DFS不一样的地方出现了，我们DFS中时根据B作为新的初始结点去访问C，而我们的BFS中仍是以A为初始结点，去找B结点的邻接结点也就是C，发现C同样也能访问，于是就访问到了C。</li><li>然后再去通过c找它的后继结点，发现找不到了。</li><li>这个时候我们的B已经在队列中，A访问过后已经被弹出了队列，然后就从队列中弹出B（它现在位于队列头）。</li><li>然后根据B去找，发现访问过的就跳过，跳过AC后发现能访问到D，然后又能访问到E。</li><li>最后把剩下的CDE都作为队列头走一圈，发现都访问过了，就退出了。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs java"><span class="hljs-comment">//对一个节点进行广度优先遍历的方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//表示队列头结点对应下标</span>    <span class="hljs-keyword">int</span> w;<span class="hljs-comment">//邻接结点w</span>    <span class="hljs-comment">//队列,记录结点访问的顺序</span>    LinkedList queue = <span class="hljs-keyword">new</span> LinkedList();    <span class="hljs-comment">//访问结点,输出结点信息</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">"-&gt;"</span>);    <span class="hljs-comment">//标记为已访问</span>    isVisited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//将结点加入队列</span>    queue.addLast(i);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-comment">//取出队列的头结点下标</span>        u = (Integer) queue.removeFirst();        <span class="hljs-comment">//得到第一个邻接点的下标 w</span>        w = getFirstNeighbor(u);        <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找到</span>            <span class="hljs-comment">//是否访问过</span>            <span class="hljs-keyword">if</span> (!isVisited[w]) &#123;                System.out.println(getValueByIndex(w) + <span class="hljs-string">"=&gt;"</span>);                <span class="hljs-comment">//标记已经访问</span>                isVisited[w] = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">//入队列</span>                queue.addLast(w);            &#125;            <span class="hljs-comment">//如果访问过了，以U为前驱结点，找w后面的下一个结点</span>            w = getNextNeighhor(u, w);<span class="hljs-comment">//体现了广度优先</span>        &#125;    &#125;&#125;<span class="hljs-comment">//遍历所有的结点，都进行广度优先搜索</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            bfs(isVisited, i);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/cxlittlecute/ee040603.html"/>
    <url>/cxlittlecute/ee040603.html</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>最近复习数据结构和算法，对一些基础知识进行总结和深化。</p><h2 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h2><p>图是一种数据结构，它不同于我们学习的线性表和树，我们的线性表局限于一个直接前驱和一个直接后继的关系，树也只有一个直接前驱的父节点。</p><p>当我们要表示多对多关系的时候我们就需要用到树。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li>顶点（结点）：可以有零个或多个相邻元素。</li><li>边 ：两个结点的连接称为边。</li><li>路径 ： 一个结点到另一个结点的边和。</li></ul><p>无向图：顶点之间的连接没有方向。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112212.png" srcset="/img/loading.gif" alt=""></p><p>有向图：顶点之间有连接方向。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112244.png" srcset="/img/loading.gif" alt=""></p><p>带权图：带有权值的图也称为网。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112325.png" srcset="/img/loading.gif" alt=""></p><h2 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h2><ul><li>方式一：邻接矩阵（二维数组表示）<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724113306.png" srcset="/img/loading.gif" alt=""></li></ul><p>矩阵外的编号代表，图中的编号，0和0也就是自己和自己连，一般用0或者∞表示。1就代表可以直接连接。</p><p>邻接矩阵需要为每个顶点都分配n个边的空间，我们可以发现很多边是没有必要存在的，这样就会造成空间上的浪费。</p><ul><li>方式二：邻接表（链表表示）<br>邻接表的实现只关心存在的边，因此没有空间上的浪费，由数组+链表组成。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724113938.png" srcset="/img/loading.gif" alt=""></p><h2 id="举例创建图"><a href="#举例创建图" class="headerlink" title="举例创建图"></a>举例创建图</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724115625.png" srcset="/img/loading.gif" alt=""></p><p>思路分析：</p><ol><li>创建存储顶点的集合、存储图对应的邻接矩阵、表示该结点有多少条边。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="hljs-comment">//存储顶点集合</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;<span class="hljs-comment">//存储图对应的，邻结矩阵</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;<span class="hljs-comment">//表示边的数目</span></code></pre><p>初始化矩阵：</p><pre><code class="hljs java"><span class="hljs-comment">//构造器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//初始化矩阵和ArrayList</span>    edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];    vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);    numOfEdges = <span class="hljs-number">0</span>;&#125;</code></pre><p>编写方法：</p><pre><code class="hljs java"><span class="hljs-comment">//插入顶点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;    vertexList.add(vertex);&#125;<span class="hljs-comment">//添加边</span><span class="hljs-comment">//v1表示点的下标表示第几个顶点</span><span class="hljs-comment">//v2表示第二个顶点的下标</span><span class="hljs-comment">//weight表示他们之间的关联关系</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;    edges[v1][v2] = weight;    edges[v2][v1] = weight;    numOfEdges++; <span class="hljs-comment">// 每添加一个关系就增加一条边</span>&#125;</code></pre><p>这样一个图的基本构造就出来了，接下来我们再举例几个常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">//图中常用的方法：</span><span class="hljs-comment">//返回结点个数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfVertex</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> vertexList.size();&#125;<span class="hljs-comment">//得到边的数目</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfEdges</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> numOfEdges;&#125;<span class="hljs-comment">//返回结点i（下标）对应的数据0-&gt;"A"  1-&gt;"B"  2-&gt;"c"</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValueByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> vertexList.get(i);&#125;<span class="hljs-comment">//返回v1和v2的权值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;    <span class="hljs-keyword">return</span> edges[v1][v2];&#125;<span class="hljs-comment">//显示图对应的矩阵</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] link : edges) &#123;        System.out.println(Arrays.toString(link));    &#125;&#125;</code></pre><p>最后在main方法中进行真正的构建:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-comment">//结点的个数</span>    String VertexValue[] = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;    <span class="hljs-comment">//创建图对象</span>    Graph graph = <span class="hljs-keyword">new</span> Graph(n);    <span class="hljs-comment">//循环的添加顶点</span>    <span class="hljs-keyword">for</span> (String value : VertexValue) &#123;        graph.insertVertex(value);    &#125;    <span class="hljs-comment">//添加边</span>    <span class="hljs-comment">//A-B A-C B-C B-D B-E</span>    graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//显示</span>    graph.showGraph();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP实现</title>
    <link href="/cxlittlecute/3d4e4ac2.html"/>
    <url>/cxlittlecute/3d4e4ac2.html</url>
    
    <content type="html"><![CDATA[<h1 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h1><p>总结一下使用根据最大长度表实现KMP算法。</p><p>首先，KMP是一个解决模式串在文本串是否出现过，以及若是出现时，最早出现的位置的经典算法。</p><p>我们惯用的思路都是属于暴力匹配：</p><ul><li>如果当前字符匹配成功（即s1[i] == s2[j]），则i++，j++，继续匹配下一个字符；</li><li>如果失配（即s1[i] == s2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 暴力匹配</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">violenceMatch</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] s1 = str1.toCharArray();    <span class="hljs-keyword">char</span>[] s2 = str2.toCharArray();    <span class="hljs-keyword">int</span> s1length = s1.length;    <span class="hljs-keyword">int</span> s2length = s2.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// i指向s1</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// j指向s2</span>    <span class="hljs-keyword">while</span> (i &lt; s1length &amp;&amp; j &lt;s2length) &#123;        <span class="hljs-keyword">if</span> (s1[i] == s2[j]) &#123;            i++;            j++;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有匹配成功</span>            i = i - j + <span class="hljs-number">1</span>;            j = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">// 判断是否匹配成功</span>    <span class="hljs-keyword">if</span> (j == s2length)&#123;        <span class="hljs-keyword">return</span> i - j;    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>如果用暴力方法解决的话就会有大量的回溯造成，因为我们不匹配的时候会j 被置为0，i往后移动一位，但是我们通过分析可以清楚的知道，中间已经匹配过的字符是不用再次匹配的，也就是说不可能匹配上的，但是还是回溯回去做了相同的工作，这样就造成了时间上的大量浪费。</p><p>所以，kmp方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String str1 = <span class="hljs-string">"BBC ABCDAB ABCDABCDABDE"</span>;    <span class="hljs-comment">// String str2 = "ABCDABD";</span>    String str2 = <span class="hljs-string">"ABCDABD"</span>;    <span class="hljs-keyword">int</span>[] next = kmpNext(<span class="hljs-string">"ABCDABD"</span>);    <span class="hljs-comment">//System.out.println(Arrays.toString(next));</span>    <span class="hljs-keyword">int</span> index = kmpSearch(str1, str2, next);    System.out.println(<span class="hljs-string">"index"</span> + index);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kmpSearch</span><span class="hljs-params">(String str1, String str2, <span class="hljs-keyword">int</span>[] next)</span> </span>&#123;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 失配时模式串移动的位数</span>        &#125;        <span class="hljs-keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;            j++;        &#125;        <span class="hljs-keyword">if</span> (j == str2.length()) &#123;            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取到一个字符串（子串）的部分匹配值表（最大长度表）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] kmpNext(String dest) &#123;    <span class="hljs-comment">// 创建一个next数组保存部分匹配值</span>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[dest.length()];    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果字符串的长度为1 部分匹配值就是0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; dest.length(); i++) &#123;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;            j = next[j - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;            j++;        &#125;        next[i] = j;    &#125;    <span class="hljs-keyword">return</span> next;&#125;</code></pre><p>以上方法的KMP实现只需要大家掌握两个地方：</p><ul><li>什么是最大长度表，它是如何计算的（参考下面链接）。</li><li>失配时应该怎么计算模式串移动的位数：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。</li></ul><p>本文只是对KMP进行了简单实现，如果想深入了解可以参考看一下下面的链接，感谢原作者的付出。</p><p>参考链接：<br><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈StringBuilder和StringBuffer</title>
    <link href="/cxlittlecute/b1c49b5c.html"/>
    <url>/cxlittlecute/b1c49b5c.html</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈StringBuilder和StringBuffer"><a href="#浅谈StringBuilder和StringBuffer" class="headerlink" title="浅谈StringBuilder和StringBuffer"></a>浅谈StringBuilder和StringBuffer</h1><p>一个很常见的面试题相信大家都看过，也就是询问StringBuilder和StringBuffer的区别是什么，这个问题大部分人只会考虑线程安不安全的方面。</p><p>也就说StringBuilder:线程不安全，StringBuffer：线程安全。</p><p>那么在这里我们需要多想一下：为什么安全以及不安全，同时它们的内部是如何实现扩容的，它们的toString（）方法的构建是否有区别。</p><h3 id="为什么StringBuffer线程安全？"><a href="#为什么StringBuffer线程安全？" class="headerlink" title="为什么StringBuffer线程安全？"></a>为什么StringBuffer线程安全？</h3><p>线程安全是由于StringBuffer类中的方法都被synchronized关键字所修饰。synchronized修饰在方法上也称为对象锁，多个线程调用同一个对象的同步方法会阻塞，调用不同对象的同步方法不会阻塞。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722215902.png" srcset="/img/loading.gif" alt=""></p><p>所以也就保证了它在多线程的情况下不会出现线程安全问题。</p><p>那么我们接着来分析一下：</p><h3 id="StringBuilder不安全的点又在哪里？"><a href="#StringBuilder不安全的点又在哪里？" class="headerlink" title="StringBuilder不安全的点又在哪里？"></a>StringBuilder不安全的点又在哪里？</h3><p>首先我们根据源码可知StringBuffer和StringBuilder都是继承于AbstractStringBuilder父类。</p><p>父类中有重要的两个变量:</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-keyword">char</span>[] value; <span class="hljs-comment">// 通过字符数组存储字符串的具体内容</span>    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 记录已使用字符数组的数量</span>&#125;</code></pre><p>接着我们看一看StringBuilder方法中append是如何实现的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">super</span>.append(var1);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>它通过调用父类的append方法，那我们接着进去看一看。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.appendNull();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> var2 = var1.length();        <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.count + var2); <span class="hljs-comment">// 确保数组的容量足够，如果容量不够，将对value数组进行扩容</span>        var1.getChars(<span class="hljs-number">0</span>, var2, <span class="hljs-keyword">this</span>.value, <span class="hljs-keyword">this</span>.count);<span class="hljs-comment">// 将需要拼接的StringBuffer型变量str拼接到value数组中</span>        <span class="hljs-keyword">this</span>.count += var2;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><p>那么由于我们的方法没有被synchronized修饰，也就无法保证我们是原子操作。那么当我们多个线程进行数据修改的时候，可能不造成拿到的值，不是另一个线程已经修改的最新值，导致结果出现错误。</p><p>看到这里大家一定也看到了这个ensureCapacityInternal（）方法。</p><h3 id="ensureCapacityInternal（）方法在这里有什么作用？"><a href="#ensureCapacityInternal（）方法在这里有什么作用？" class="headerlink" title="ensureCapacityInternal（）方法在这里有什么作用？"></a>ensureCapacityInternal（）方法在这里有什么作用？</h3><p>ensureCapacityInternal（）方法是检查StringBuilder的对象的原字符数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity（）方法对字符数组进行扩容。</p><p>AbstractStringBuilder类的各个append()方法大同小异。append()方法在追加字符到value数组中之前都会调用ensureCapacityInternal()方法来确保value数组有足够的容量，然后才把字符追加到value数组中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 - <span class="hljs-keyword">this</span>.value.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.value = Arrays.copyOf(<span class="hljs-keyword">this</span>.value, <span class="hljs-keyword">this</span>.newCapacity(var1));    &#125;&#125;</code></pre><p>通过Arrays.copyOf（）函数将原数组的内容复制到新数组，最后将新数组的指针重新指向value。</p><h3 id="StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同"><a href="#StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同" class="headerlink" title="StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同"></a>StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同</h3><p>StringBuffer代码片段：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.toStringCache == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.toStringCache = Arrays.copyOfRange(<span class="hljs-keyword">this</span>.value, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.count);     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">this</span>.toStringCache, <span class="hljs-keyword">true</span>); &#125;</code></pre><p>StringBuilder代码片段：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">this</span>.value, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.count);&#125;</code></pre><p>toString()方法返回一个表示该字符序列的字符串。在StringBuffer中当toStringCache缓存不为null时（表示该StringBuffer对象未被修改），直接返回一个表示该字符序列的字符串。<br>反之，当toStringCache缓存为null时（表示该StringBuffer对象已被修改），调用Arrays类的copyOfRange()静态方法来创建一个新数组和拷贝value数组中的字符到新数组，并将toStringCache指向新数组，然后才返回一个表示该字符序列的字符串。</p><p>通过使用toStringCache缓存，当StringBuffer对象未被修改时，减少了一次创建新数组和拷贝数组的开销。</p><p>而StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p><h3 id="如何扩容？"><a href="#如何扩容？" class="headerlink" title="如何扩容？"></a>如何扩容？</h3><p>我们可以根据源码可知不管是StringBuilder还是StringBuffer都是调用父类的构造方法创建字符数组。<br>默认构造方法设置了value数组的初始容量为16。<br>其他情况概述为设置value数组的初始容量为对象的长度+16，并把String对象中的字符添加到value数组中</p><p>我们在上面提到了他们都会调用父类的ensureCapacityInternal（）方法去检测value数组的容量是否足够，如果不够就涉及到我们的数组扩容，用expandCapacity()方法进行扩容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;        value = Arrays.copyOf(value,                newCapacity(minimumCapacity));    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>; <span class="hljs-comment">// 乘2再加2</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;        newCapacity = minCapacity;    &#125;    <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)        ? hugeCapacity(minCapacity)        : newCapacity;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError(); <span class="hljs-comment">//防溢出</span>    &#125;    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125;</code></pre><p>扩容方式为先将容量乘2再加2，再与所需容量进行比较，若小于所需容量，则取所需容量，后面还有防止溢出的操作，写得非常严谨，获得更新后的容量后，新建一个新的容量的数组，并将之前的数据用Arrays.copyOf()方法复制进去，并更新为新的成员变量value。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建多线程的四种方式</title>
    <link href="/cxlittlecute/459fe412.html"/>
    <url>/cxlittlecute/459fe412.html</url>
    
    <content type="html"><![CDATA[<h1 id="创建多线程的四种方式"><a href="#创建多线程的四种方式" class="headerlink" title="创建多线程的四种方式"></a>创建多线程的四种方式</h1><p>在这里总结一下Java创建多线程的四种方式。</p><p>在Jdk1.5之前创建线程的方式主要是继承Thread类的方式和实现Runnable接口的方式。</p><h2 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h2><ol><li>定义子类继承Thread类</li><li>子类重写Thread类中的run方法。</li><li>创建Thread对象，则创建了线程的对象。</li><li>调用线程的Start方法启动线程，调用run方法。（注意：这里如果是直接用对象调用run方法是不会有新的线程创建的）</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        TestThread tt = <span class="hljs-keyword">new</span> TestThread();        tt.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">":"</span>+i);        &#125;    &#125;&#125;</code></pre><p>注意：<br>生成新的对象并且调用Start方法都是我们主线程做的，当我们调用完start后新的线程就开始执行它的run方法了。</p><h2 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h2><ol><li>定义子类实现Runnable接口。</li><li>子类中重写Runnable接口中的run方法。</li><li>通过Thread类含参构造器创建线程对象。</li><li>将Runnable接口的子类对象作为参数传递给Thread类的构造器中。</li><li>调用Thread类的start方法：开启线程，调用Runnable子类接口中的run方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-meta">@Override</span>　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  　　 System.out.println(<span class="hljs-string">"MyThread"</span>);  　　&#125;  &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        MyThread myThread = <span class="hljs-keyword">new</span> MyThread();          Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);          thread.start();      &#125;&#125;</code></pre><p>那么已经看了两种创建线程的方式了，它们的区别也是很明显的，一个需要继承Thread类，另一个需要实现Runnable接口，那么建议使用的肯定是实现接口的方式去创建线程，原因有主要有两个：</p><ol><li>实现接口可以避免单继承的局限性。</li><li>(重点)多个线程可以共享同一个接口实现类的对象，反之继承的话只能通过static修饰后才能共享对象信息，使用接口的实现非常适合相同线程来处理同一份资源。</li></ol><h2 id="方法三：实现Callable接口"><a href="#方法三：实现Callable接口" class="headerlink" title="方法三：实现Callable接口"></a>方法三：实现Callable接口</h2><ol><li>创建一个实现Callable接口的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象。</li><li>将FutureTask对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start（）</li><li>如果想要返回值。就通过futureTask对象获取Callable中call方法的返回值。</li></ol><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre><p>说到FutureTask类我们就要看一下Future接口，FutureTask类是这个接口的唯一实现类。</p><p>可以对具体的Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。</p><p>FutureTask实现了RunnableFuture这个接口，这个RunnableFuture继承了Runnable, Future接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722164536.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>举例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();        <span class="hljs-comment">// 这里需要借助于FutureTask类</span>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(testThread);        <span class="hljs-keyword">new</span> Thread(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            Object sum = futureTask.get(); <span class="hljs-comment">// 通过get()方法就能获取Callable实现类重写call（）方法中的执行结果</span>            System.out.println(<span class="hljs-string">"获取结果总和为:"</span>+sum);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                sum += i;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程强大？</p><ul><li>重写call（）方法后，可以有返回值。</li><li>这个方法可以抛出异常。</li><li>支持泛型的返回值。</li><li>可以借助于FutureTask类实现更多的功能，比如获取返回结果。</li></ul><h2 id="方法四：实现线程池"><a href="#方法四：实现线程池" class="headerlink" title="方法四：实现线程池"></a>方法四：实现线程池</h2><p>通过Executors工具类、线程池的工厂类，可以创建返回不同类型的线程池。</p><ul><li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池。</li><li>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池。</li><li>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池。</li><li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li></ul><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p><ol><li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行<br>Runnable</li><li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行<br>Callable</li><li>void shutdown() ：关闭连接池</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);        executorService.execute(<span class="hljs-keyword">new</span> NumberThread1()); <span class="hljs-comment">// 适用于Runnable</span>        Future&lt;Integer&gt; submit = executorService.submit(<span class="hljs-keyword">new</span> NumberThread2()); <span class="hljs-comment">// 适用于Callable</span>        Integer integer = submit.get();        System.out.println(integer);        executorService.shutdown();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;            System.out.println(i);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;            sum += i;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据类型 包装类 String之间的相互转换</title>
    <link href="/cxlittlecute/8a035673.html"/>
    <url>/cxlittlecute/8a035673.html</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型-包装类-String之间的相互转换"><a href="#基本数据类型-包装类-String之间的相互转换" class="headerlink" title="基本数据类型 包装类 String之间的相互转换"></a>基本数据类型 包装类 String之间的相互转换</h1><p>类型转换是我们经常会遇到的问题，今天通过本博客进一步总结它的用法。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200721230535.png" srcset="/img/loading.gif" alt=""></p><ul><li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征。</li><li>基本数据类型转变为了包装类，就可以调用类中的方法。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722091807.png" srcset="/img/loading.gif" alt=""></p><p>注意：除了Boolean和Character(没有父类)其他包装类的父类都是Number，我们可以根据以下的源码看出：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722091736.png" srcset="/img/loading.gif" alt=""></p><h2 id="基本数据类型-gt-包装类"><a href="#基本数据类型-gt-包装类" class="headerlink" title="基本数据类型-&gt;包装类"></a>基本数据类型-&gt;包装类</h2><ul><li>调用包装类的构造器</li><li>通过字符串参数</li><li>自动装箱</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 调用包装类的构造器</span>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    Integer integer1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);    System.out.println(integer1.toString());    <span class="hljs-comment">//  通过字符串参数</span>    Integer integer2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"123"</span>);    System.out.println(integer2.toString());&#125;</code></pre><p>但是需要注意，使用字符串转换的时候，如果是以Number为父类的包装类，使用字符串的构造器，里面的参数如果是又有数字又有字母会报错(也就是说参数想转什么类型，参数就必须符合这种结构)，但是Boolean支持这样，只会判断为false。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Integer integer3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"asb123"</span>); <span class="hljs-comment">// 报错，参数必须对应包装类的类型</span>    System.out.println(integer3.toString());    Boolean asb123 = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-string">"asb123"</span>);    System.out.println(asb123); <span class="hljs-comment">// 不会报错，结果为false</span>&#125;</code></pre><p>为什么会这样叻？<br>我们来看看Boolean的源码:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Boolean</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>(parseBoolean(var1));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parseBoolean</span><span class="hljs-params">(String var0)</span> </span>&#123;    <span class="hljs-keyword">return</span> var0 != <span class="hljs-keyword">null</span> &amp;&amp; var0.equalsIgnoreCase(<span class="hljs-string">"true"</span>);&#125;</code></pre><p>在忽略大小写的情况下如果是true那么就是true，如果不是同事不为null，那么都为false。</p><h2 id="包装类-gt-基本数据类型"><a href="#包装类-gt-基本数据类型" class="headerlink" title="包装类-&gt;基本数据类型"></a>包装类-&gt;基本数据类型</h2><p>首先，我们要知道这个操作也是必要的，因为我们的包装类属于类是不能进行加减乘除运算的。</p><ul><li>调用包装类的xxxValue（），你是哪个包装类型就调用哪个value()方法.</li><li>自动拆箱</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span>&#123;    Integer in1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">12</span>);    <span class="hljs-keyword">int</span> i = in1.intValue();    System.out.println(i);&#125;</code></pre><h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>那么说到这里就得说一下自动装箱和自动拆箱了，它属于Jdk5的新特性。我们通过下面的例子理解这个特性：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">20</span>;    test13(num);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">(Object o)</span></span>&#123;    System.out.println(o);&#125;</code></pre><p>上面的这个操作将num放入test13中发现是可以的，这里并不是说我们把Object obj = num,这样理解是不对的，因为int类型和Object类型是没有任何关系的，但为什么又行了？</p><p>因为这里就用到了自动装箱,自动装箱就是这样的,相反有的就是自动拆箱。</p><ul><li>自动装箱：基本数据类型-&gt;包装类</li><li>自动拆箱：包装类-&gt;基本数据类型</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自动装箱</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    Integer integer = i;    <span class="hljs-comment">// 自动拆箱</span>    <span class="hljs-keyword">int</span> i2 = integer;&#125;</code></pre><h2 id="基本数据类型、包装类-gt-String"><a href="#基本数据类型、包装类-gt-String" class="headerlink" title="基本数据类型、包装类-&gt;String"></a>基本数据类型、包装类-&gt;String</h2><ul><li>方式一：连接运算</li><li>方法二：调用String重载的valueOf（Xxx xx）<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test16</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 方式一：</span>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    String str1 = num1 + <span class="hljs-string">""</span>;    <span class="hljs-comment">// 方式二：</span>    <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.3f</span>;    String str2 = String.valueOf(f1);    &#125;</code></pre></li></ul><h2 id="String-gt-基本数据类型、包装类"><a href="#String-gt-基本数据类型、包装类" class="headerlink" title="String-&gt;基本数据类型、包装类"></a>String-&gt;基本数据类型、包装类</h2><ul><li>调用包装类的parseXxx（String x）</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test17</span><span class="hljs-params">()</span></span>&#123;    String str = <span class="hljs-string">"123"</span>;    <span class="hljs-keyword">int</span> i = Integer.parseInt(str);&#125;</code></pre><p>注意：<br>最后再强调一下，字符串转换的时候如果有数字和字母，那么会报错NumberFormatException，除了Boolean特殊一些，可以再看一下上面的源码解析。</p><p>同时因为基本数据类型和包装类两个之间有自动装箱和自行拆箱的特性，所以我们可以把他们两个相对string来说看成一个整体进行转换。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>== 和 equals的区别</title>
    <link href="/cxlittlecute/f30662c7.html"/>
    <url>/cxlittlecute/f30662c7.html</url>
    
    <content type="html"><![CDATA[<h1 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a>== 和 equals的区别</h1><p>那么这是一个比较常见的面试题，在这里还是通过源码的分析再次总结一下。</p><p>举例：<br>比如现在我自定义一个类，然后根据这个类生成了两个对象,这两个对象的值属性都是一样的，比如这个叫tom，那个也叫tom，同时两个的年龄也是20岁。他们使用equals比较的结果是什么？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        People tom1 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"tom"</span>, <span class="hljs-number">20</span>);        People tom2 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"tom"</span>,<span class="hljs-number">20</span>);        System.out.println(tom1.equals(tom2));    &#125;</code></pre><p>如果说你回答true,那么你就错了，说明你误认为Object类中的equals方法比较的是值了。</p><p>那么下面我们就来总结一下它们的区别是什么。</p><p>总结：</p><ul><li>==既可以比较基本类型也可以比较引用类型。对于基本类型是直接比较的值（不一定类型相等），对于引用类型就是比较的内存的地址是否相同，即两个引用是否指向同一个对象实体。</li><li>equals的话，只能适用于引用数据类型，首先它是属于Object类中的方法，如果这个方法没有被当前的类重写那么比较的就是地址，等同于==。</li><li>自定义类相不相同，具体要看有没有重写Object的equals方法来判断。</li><li>通常情况下，我们重写equals方法，会去比较类中的属性值是否相等。（注意：这里便是我们的误区，因为我们经常使用像String这样的类（内部已重写equals方法），导致我们认为我们的自定义类比较的是值）。</li></ul><p>为什么说Object类中的equals方法和==作用相同了？上源码：</p><pre><code class="hljs java"><span class="hljs-comment">// 因为在Object中的equals方法的实现是这样的</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == var1;&#125;</code></pre><p>为什么说String、Data、File、包装类等中比较的是两个对象的值相等了？</p><pre><code class="hljs java"><span class="hljs-comment">// 它们都重写了Object类的equals方法   我们以下面String类为例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == var1) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (var1 <span class="hljs-keyword">instanceof</span> String) &#123;            String var2 = (String)var1;            <span class="hljs-keyword">int</span> var3 = <span class="hljs-keyword">this</span>.value.length;            <span class="hljs-keyword">if</span> (var3 == var2.value.length) &#123;                <span class="hljs-keyword">char</span>[] var4 = <span class="hljs-keyword">this</span>.value;                <span class="hljs-keyword">char</span>[] var5 = var2.value;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var6 = <span class="hljs-number">0</span>; var3-- != <span class="hljs-number">0</span>; ++var6) &#123;                    <span class="hljs-keyword">if</span> (var4[var6] != var5[var6]) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    &#125;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对POP、OOP、AOP、FP的理解</title>
    <link href="/cxlittlecute/60f59bbd.html"/>
    <url>/cxlittlecute/60f59bbd.html</url>
    
    <content type="html"><![CDATA[<h1 id="对POP、OOP、AOP的理解"><a href="#对POP、OOP、AOP的理解" class="headerlink" title="对POP、OOP、AOP的理解"></a>对POP、OOP、AOP的理解</h1><p>记得自己刚进项目组的时候就被师傅问了这样的一个问题，当时没有深入去理解过这个东西，于是今天好好总结分析一下这个问题。</p><h2 id="POP面向过程编程"><a href="#POP面向过程编程" class="headerlink" title="POP面向过程编程"></a>POP面向过程编程</h2><p>大家肯定会问什么是面向过程编程叻？</p><p>首先面向过程编程肯定是以过程为中心，那么我们来分析什么是过程，过程就是你解决问题的步骤，也就是这一步应该怎么做，下一步又应该怎么做，好比说一条流水线，每一步都设计好了，只需要使用的时候按照顺序一步一步的调用就可以了。我认为这就是过程。</p><p>那么加上编程二字了，也就是说我们需要首先分析出解决问题需要什么步骤，然后通过一个个函数去把这些步骤给实现，以什么正在发生为主要目标进行编程，那么串联起来也就是面向过程的编程了。</p><h2 id="OOP面向对象编程"><a href="#OOP面向对象编程" class="headerlink" title="OOP面向对象编程"></a>OOP面向对象编程</h2><p>面向对象编程的中心那肯定就是对象了，那么我们需要把问题中所需要的事物抽象为一个个的实体，将实体的属性和行为统一到类中，可以通过类的实例化出具体的对象，然后这些对象就能完成一系列不同的行为。这就是面向对象编程。</p><p>同时需要注意的是我们建立对象的目的不是为了具体完成某一个步骤，而是为了描述这个对象解决问题的行为。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例如简单分析一下飞机大战的设计：<br>面向过程的设计思路就是首先分析问题的步骤：</p><ol><li>开始游戏</li><li>飞机移动</li><li>绘制画面</li><li>判断是否碰撞</li><li>飞机移动</li><li>绘制画面</li><li>判断是否碰撞</li><li>输出结果</li></ol><p>那么接着我们再用面向对象的思想简单分析一下步骤：</p><ol><li>飞机。行为就是飞行移动。</li><li>界面。绘制游戏画面</li><li>规则。判定游戏的输赢。</li></ol><p>可以明显地看出，面向对象是以具体功能对象来划分问题，而不是步骤。绘制画面，这样的步骤多次出现在面向过程的设计中，很可能出现不同的绘制版本。而面向对象的设计中，绘图只可能在界面对象中出现，从而保证了绘图的统一。而且我们使用面向对象进行编程的话，可扩展性也更好。</p><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p><p>AOP采用横向抽取的机制，能很好的解决OOP通用业务（日志记录、性能统计、安全控制、事务处理、异常处理等）的解耦问题。</p><h2 id="FP函数式编程"><a href="#FP函数式编程" class="headerlink" title="FP函数式编程"></a>FP函数式编程</h2><p>函数式编程的特点就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数，那么在Java8中的Lambda表达式就是很好的体现。</p><p>好处就是代码简洁，开发快速；并且接近自然语言，易于理解。缺点也很明显就是难以编写。</p><p>参考：<br><a href="https://www.cnblogs.com/wyljq/p/12219208.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyljq/p/12219208.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Comparable、Comparator、compareTo 、compare的区别和联系</title>
    <link href="/cxlittlecute/f368ac2a.html"/>
    <url>/cxlittlecute/f368ac2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="Comparable、Comparator、compareTo-、compare的区别和联系"><a href="#Comparable、Comparator、compareTo-、compare的区别和联系" class="headerlink" title="Comparable、Comparator、compareTo 、compare的区别和联系"></a>Comparable、Comparator、compareTo 、compare的区别和联系</h1><p>在Java中经常会涉及到对象的排序问题，对于对象正常情况下，只能比较 == 或 ！=，不能使用 &gt; 或 &lt;，但是在实际开发中，我们又需要对多个对象进行排序，那么就涉及到对象之间的比较大小的问题。那么实现方为以下两种。</p><p>Java实现对象排序的方式有两种：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><p>Comparable和Comparator都是用于比较数据的大小的接口，实现Comparable接口需要重写compareTo方法，实现Comparator接口需要重写compare方法，这两个方法的返回值都是int，用int类型的值来确定比较结果。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    Comparator comparator = <span class="hljs-keyword">new</span> Comparator() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o, Object t1)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;    Comparable comparable = <span class="hljs-keyword">new</span> Comparable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;&#125;</code></pre><h2 id="Comparable自然排序"><a href="#Comparable自然排序" class="headerlink" title="Comparable自然排序"></a>Comparable自然排序</h2><p>默认的时候一般会考虑Comparable。</p><p>Comparable接口的举例说明：</p><ul><li><p>我们一些包装类已经替我们实现了Comparable接口，重写了compareTo方法，我们就能对他们的对象进行大小比较。</p></li><li><p>包装类等重写CompareTo()方法后，默认进行的是从小到大的排列。</p></li><li><p>那么我们重写CompareTo（）的规则是什么了？</p><ol><li>如果当前对象this大于形参对象obj，则返回正整数；</li><li>如果当前对象this小于形参obj，则返回负整数；</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ol></li></ul><p>我们可以一起来看看String类的源码，首先我们可以看到String类实现了Comparable的接口,并且重写了CompareTo（）方法，给出了比较两个String对象大小的方式：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200721144039.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.value.length;    <span class="hljs-keyword">int</span> var3 = var1.value.length;    <span class="hljs-keyword">int</span> var4 = Math.min(var2, var3);    <span class="hljs-keyword">char</span>[] var5 = <span class="hljs-keyword">this</span>.value;    <span class="hljs-keyword">char</span>[] var6 = var1.value;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var7 = <span class="hljs-number">0</span>; var7 &lt; var4; ++var7) &#123;        <span class="hljs-keyword">char</span> var8 = var5[var7];        <span class="hljs-keyword">char</span> var9 = var6[var7];        <span class="hljs-keyword">if</span> (var8 != var9) &#123;            <span class="hljs-keyword">return</span> var8 - var9;        &#125;    &#125;    <span class="hljs-keyword">return</span> var2 - var3;&#125;</code></pre><ul><li>如果自定义类想要进行排序，我们可以去实现Comparable接口，重写CompareTo()方法，在CompareTo（）方法中指明如何排序。不然的话进行排序就会报错。</li></ul><p>比如下面我们创建了一个商品的类，类中包含商品的名字和价格，我们要进行这个对象的排序就需要进行Comparable接口的实现和接口中方法的重写。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparaTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        Goods test1 = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"test1"</span>, <span class="hljs-number">12</span>);        Goods test2 = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"test2"</span>, <span class="hljs-number">13</span>);        Goods[] goods = <span class="hljs-keyword">new</span> Goods[]&#123;test1,test2&#125;;        Arrays.sort(goods);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;    <span class="hljs-comment">// 指明Goods类按照什么方式进行排序：按照价格从低到高排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-comment">// 这里和重写equals方法相似</span>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;            <span class="hljs-comment">// 方式一：</span>            <span class="hljs-comment">// 顺便说一下为什么要转换，因为Object类型的引用，调用不了子类Goods的特有属性</span>            Goods goods = (Goods)o; <span class="hljs-comment">// 转换完后当前对象和我们的形参对象就是两个对象了</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.price &gt; goods.price)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.price &lt; goods.price)&#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果价格相等，还需要比较，那么就可以嵌套继续根据名字等进行排序比较</span>                <span class="hljs-comment">// return 0;</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(goods.name);            &#125;            <span class="hljs-comment">// 方式二：</span>            <span class="hljs-comment">// return Double.compare(this.price, goods.price);</span>        &#125;        <span class="hljs-comment">// 如果比较的不是一个商品对象</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"传入的数据类型不一致"</span>);    &#125;&#125;</code></pre><p>注意：实现Comparable接口等于说是在类的基础上做的修改。同时实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p><h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><h3 id="什么时候使用Comparator"><a href="#什么时候使用Comparator" class="headerlink" title="什么时候使用Comparator"></a>什么时候使用Comparator</h3><p>当元素的类型没有实现Comparable接口而又不方便修改代码，或者实现了Comparable接口的排序规则不适合当前的操作，那么我们可以考虑使用Comparator的对象来排序。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>重写compare(Object o1,Object o2)方法。</p><p>如果方法返回正整数，则表示o1大于o2；<br>如果返回0,表示相等；<br>如果返回负整数，表示o1小于02。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"aa"</span>,<span class="hljs-string">"bb"</span>,<span class="hljs-string">"cc"</span>,<span class="hljs-string">"dd"</span>&#125;;    <span class="hljs-comment">// String本身实现了Comparable接口，但是如果我们想要从大到小排序就需要使用Comparator接口重新编写排序逻辑，因为String类的源码我们是没办法修改的。</span>    Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String  o2)</span> </span>&#123;            <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> String)&#123;                String s1 = (String)o1;                String s2 = (String)o2;                <span class="hljs-keyword">return</span> -s1.compareTo(s2);            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);        &#125;    &#125;);    <span class="hljs-comment">// Lambda表达式写法</span>    Arrays.sort(arr,(o1,o2) -&gt; &#123;        <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> String)&#123;            String s1 = (String)o1;            String s2 = (String)o2;            <span class="hljs-keyword">return</span> -s1.compareTo(s2);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);    &#125;);&#125;</code></pre><p>注意：comparator是属于非侵入式的排序实现方式。</p><p>对比：Comparable接口的的方式一旦指定，能够保证Comparable接口实现类在任何位置按照默认实现的方式比较大小，而Comparator属于临时性的比较。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我认为只需要记住Comparable是让对象具有比较的属性，也就是说实现了这个接口的对象之间可以直接互相比较。那么Comparator是比较器，那么实现了这个接口的类就是一个比较器，这个比较器可以应用于对象的比较（它不属于对象的特征，只是一个工具）。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复注解和类型注解</title>
    <link href="/cxlittlecute/d1ceb33.html"/>
    <url>/cxlittlecute/d1ceb33.html</url>
    
    <content type="html"><![CDATA[<h1 id="重复注解和类型注解"><a href="#重复注解和类型注解" class="headerlink" title="重复注解和类型注解"></a>重复注解和类型注解</h1><p>Java8对注解的处理也发生了两点改变：可重复的注解和可用于类型的注解</p><p>要想定义重复注解，该注解必须使用Repeatable修饰一下，同时指定它的容器类。</p><pre><code class="hljs java"><span class="hljs-meta">@Repeatable</span>(MyAnnotations<span class="hljs-class">.<span class="hljs-keyword">class</span>) //指定容器类</span><span class="hljs-class">@<span class="hljs-title">Target</span>(</span>&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "Java 8"</span>;&#125;<span class="hljs-comment">// 定义容器</span><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotations &#123;    MyAnnotation[] value();&#125;</code></pre><p>然后配合反射去使用：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//重复注解</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"Hello"</span>)    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"World"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;        <span class="hljs-comment">// 获取bean class实例</span>        Class&lt;Test&gt; clazz = Test<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        Method test1 = clazz.getMethod(<span class="hljs-string">"test1"</span>);        MyAnnotation[] mas = test1.getAnnotationsByType(MyAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">for</span> (MyAnnotation ma : mas) &#123;            System.out.println(ma.value()); <span class="hljs-comment">// 就能把注解内容获取</span>        &#125;    &#125;&#125;</code></pre><p>类型注解：</p><pre><code class="hljs java"><span class="hljs-meta">@Repeatable</span>(MyAnnotations<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span><span class="hljs-class">@<span class="hljs-title">Target</span>(</span>&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)  <span class="hljs-comment">// 这里</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "Java 8"</span>;&#125;``` 新增ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER（在Target上）。设置之后我们就可以在参数类型前面添加注解了：``` java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//重复注解</span>    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"Hello"</span>)    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"World"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">( @MyAnnotation(<span class="hljs-string">"java"</span>)</span> String str) </span>&#123;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新时间日期API</title>
    <link href="/cxlittlecute/aed0d4.html"/>
    <url>/cxlittlecute/aed0d4.html</url>
    
    <content type="html"><![CDATA[<h1 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h1><p>之前经常使用的Data和Calendar等时间API其实并不怎么好用，麻烦而且存在线程安全问题，所以在JAVA8推出了新的API接口。</p><p>全新的API是不可变的线程安全的。</p><p>时间操作是我们写程序经常会用到的API，所以通过这篇文章进行一个总结。</p><h2 id="本地时间和时间戳"><a href="#本地时间和时间戳" class="headerlink" title="本地时间和时间戳"></a>本地时间和时间戳</h2><ul><li>LocalDate LocalTime LocalDateTime 它们的使用方式都一样  注意都是产生新的实例</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//获取当前时间日期 now</span>    LocalDateTime ldt1 = LocalDateTime.now();    System.out.println(ldt1);    <span class="hljs-comment">//指定时间日期 of</span>    LocalDateTime ldt2 = LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">05</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">24</span>, <span class="hljs-number">33</span>);    System.out.println(ldt2);    <span class="hljs-comment">//加 plus</span>    LocalDateTime ldt3 = ldt2.plusYears(<span class="hljs-number">2</span>);    System.out.println(ldt3);    <span class="hljs-comment">//减 minus</span>    LocalDateTime ldt4 = ldt2.minusMonths(<span class="hljs-number">3</span>);    System.out.println(ldt4);    <span class="hljs-comment">//获取指定的你年月日时分秒... get</span>    System.out.println(ldt2.getDayOfYear());    System.out.println(ldt2.getHour());    System.out.println(ldt2.getSecond());    System.out.println(ldt2.getYear());&#125;</code></pre><ul><li>Instant:时间戳（以 Unix 元年 1970-01-01 00:00:00 到某个时间之间的毫秒值）</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 默认获取 UTC 时区 (UTC：世界协调时间)</span>    Instant ins1 = Instant.now();    System.out.println(ins1);    <span class="hljs-comment">//带偏移量的时间日期 (如：UTC + 8)</span>    OffsetDateTime odt1 = ins1.atOffset(ZoneOffset.ofHours(<span class="hljs-number">8</span>));    System.out.println(odt1);    <span class="hljs-comment">//转换成对应的毫秒值</span>    <span class="hljs-keyword">long</span> milli1 = ins1.toEpochMilli();    System.out.println(milli1);    <span class="hljs-comment">//构建时间戳 加60秒</span>    Instant ins2 = Instant.ofEpochSecond(<span class="hljs-number">60</span>);    System.out.println(ins2);&#125;</code></pre><ul><li>Duration：计算两个时间的间隔</li><li>Period：计算两个日期之间的间隔</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Instant now1 = Instant.now();    Thread.sleep(<span class="hljs-number">1000</span>);    Instant now2 = Instant.now();    Duration between = Duration.between(now1, now2);    <span class="hljs-comment">// 毫秒这里是toXXXX()，秒是getXXX（）</span>    System.out.println(between.toMillis());    System.out.println(<span class="hljs-string">"------------------------------"</span>);    LocalTime lt1 = LocalTime.now();    Thread.sleep(<span class="hljs-number">3000</span>);    LocalTime lt2 = LocalTime.now();    Duration between2 = Duration.between(lt1, lt2);    System.out.println(between.toMillis());    System.out.println(<span class="hljs-string">"-------------注意：上面都是获取时间的间隔-------------"</span>);    System.out.println(<span class="hljs-string">"-------------注意：下面都是获取日期的间隔-------------"</span>);    LocalDate ld1 = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);    LocalDate ld2 = LocalDate.now();    Period period = Period.between(ld2, ld2);    System.out.println(period); <span class="hljs-comment">// 输出的是ISO标准的格式</span>    <span class="hljs-comment">// 可以进一步获取详细信息</span>    System.out.println(period.getYears());    System.out.println(period.getMonths());&#125;</code></pre><h2 id="时间校正器"><a href="#时间校正器" class="headerlink" title="时间校正器"></a>时间校正器</h2><ul><li>TemporalAdjuster：时间校正器。有时我们需要调整日期为想要的时间。这个类是一个接口。</li><li>TemporalAdjusters：该类提供了很多静态方法进行实现。</li></ul><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TemporalAdjuster</span> </span>&#123;    <span class="hljs-function">Temporal <span class="hljs-title">adjustInto</span><span class="hljs-params">(Temporal var1)</span></span>;&#125;</code></pre><p>这里提一下Temporal接口，大家可以看一下LocalDate这些本地时间操作的源码，它是实现了这个Temporal这个接口的，所以Temporal可以根据实际需求表示为日期、时间或两者组合。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    LocalDateTime now = LocalDateTime.now();    <span class="hljs-comment">// 将月中的天数指定为想要的天数</span>    <span class="hljs-comment">// 改为本月十号</span>    LocalDateTime localDateTime = now.withDayOfMonth(<span class="hljs-number">10</span>);    <span class="hljs-comment">// with（）传递一个时间校正器</span>    <span class="hljs-comment">// 下一个周五是什么时候</span>    LocalDateTime with = now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));    System.out.println(with);&#125;</code></pre><p>我们可以根据源码看出TemporalAdjuster是一个函数式接口，那么我们可以通过自定义时间来判断多久是下一个工作日：</p><pre><code class="hljs java">LocalDateTime with1 = now2.with((t) -&gt; &#123;    LocalDateTime ldt4 = (LocalDateTime) t;    DayOfWeek dow1 = ldt4.getDayOfWeek();    <span class="hljs-keyword">if</span> (dow1.equals(DayOfWeek.FRIDAY)) &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dow1.equals(DayOfWeek.SATURDAY)) &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">2</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">1</span>);    &#125;&#125;);System.out.println(with1);</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>-DateTimeFormatter：格式化时间 / 日期</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// DateTimeFormatter后能选择很多种格式化的方式</span>    DateTimeFormatter dtf1 = DateTimeFormatter.ISO_DATE_TIME;    LocalDateTime ldt1 = LocalDateTime.now();    String str1 = ldt1.format(dtf1);    System.out.println(str1);    <span class="hljs-comment">//自定义格式化 ofPattern</span>    DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);    LocalDateTime ldt2 = LocalDateTime.now();    String str2 = ldt2.format(dtf2);    System.out.println(str2);    <span class="hljs-comment">//解析回去 </span>    LocalDateTime newDate = ldt1.parse(str1, dtf1);    System.out.println(newDate);&#125;</code></pre><h2 id="时区操作"><a href="#时区操作" class="headerlink" title="时区操作"></a>时区操作</h2><ul><li>ZonedDate</li><li>ZonedTime</li><li>ZonedDateTime<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//查看支持的所有时区</span>    Set&lt;String&gt; set = ZoneId.getAvailableZoneIds();    set.forEach(System.out::println);    <span class="hljs-comment">//指定时区 构建时间</span>    LocalDateTime ldt1 = LocalDateTime.now(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    System.out.println(ldt1);    <span class="hljs-comment">//在已构建好的日期时间上指定时区</span>    LocalDateTime ldt2 = LocalDateTime.now(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    ZonedDateTime zdt1 = ldt2.atZone(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    System.out.println(ldt2);    System.out.println(zdt1);&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口中的默认方法与静态方法</title>
    <link href="/cxlittlecute/bf52b93a.html"/>
    <url>/cxlittlecute/bf52b93a.html</url>
    
    <content type="html"><![CDATA[<h1 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h1><p>大家查看Java8中源码经常会看到接口中被default或static修饰的方法。<br>在之前接口中只能存在全局静态常量和抽象方法。<br>而现在Java8中可以有被default和static修饰的方法。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><h3 id="为什么要使用default修饰接口中的方法"><a href="#为什么要使用default修饰接口中的方法" class="headerlink" title="为什么要使用default修饰接口中的方法"></a>为什么要使用default修饰接口中的方法</h3><p>引入default主要目的是为了实现接口的升级。因为在原有的Java代码框架中，如果要对接口进行升级就会导致所有接口的实现类都要被<br>修改，这就很麻烦了。</p><p>那么我们在接口内部包含了一些默认的方法实现，为了解决接口的修改与现有的实现不兼容的问题。</p><p>默认方法能够向库的接口添加新功能，并确保与为这些接口的旧版本编写的代码兼容。并且不用在其子类进行逐个实现。</p><p>默认方法的另一个优势是该方法是可选的，子类可以根据不同的需求Override默认实现。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建接口Interface,并且在接口Interface1中定义默认方法helloWorld()。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"test"</span>);    &#125;&#125;</code></pre><p>编写一个类实现接口Interface1,并调用接口中定义的默认方法helloWorld()：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        <span class="hljs-comment">//直接调用helloWorld()方法</span>        myImplement.helloWorld();    &#125;    <span class="hljs-comment">// 执行结果直接输出HelloWorld中的内容。</span>&#125;</code></pre><h3 id="类优先原则"><a href="#类优先原则" class="headerlink" title="类优先原则"></a>类优先原则</h3><p>若一个接口中定义了一个默认方法，而另一个接口或父类中又定义了一个同名的方法时。</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法。（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。（也就是在实现类中重写该方法）</p></li></ul><p>类优先于接口:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"hi i'm from Interface2"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement2 myImplement2 = <span class="hljs-keyword">new</span> MyImplement2();        myImplement2.helloWorld();    &#125;    <span class="hljs-comment">// 结果是MyImplement执行的结果，因为类优先于接口</span>&#125;</code></pre><p>同时实现两个接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>,<span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        <span class="hljs-comment">//直接调用helloWorld()方法</span>        myImplement.helloWorld();    &#125;&#125;</code></pre><p>上面这样同时实现两个接口，恰好两个接口定义的默认方法相同，所以编译器不知道应该执行哪一个就会报错，解决办法就是在实现类中重写该方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>,<span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"testtest"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        myImplement.helloWorld();    &#125;&#125;</code></pre><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>java8中为接口新增了一项功能：定义一个或者更多个静态方法。类似于类中的静态方法，接口定义的静态方法可以独立于任何对象调用。</p><p>所以，在调用静态方法时，不需要实现接口，也不需要接口的实例，也就是说和调用类的静态方法的方式类似。</p><p>语法如：接口名字.静态方法名。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"接口中的静态方法"</span>);    &#125;&#125;<span class="hljs-comment">// 调用</span>MyInterface.show();</code></pre><p>注意，实现接口的类或者子接口不会继承接口中的静态方法。static不能和default同时使用。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optional类</title>
    <link href="/cxlittlecute/2df787ac.html"/>
    <url>/cxlittlecute/2df787ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><h2 id="什么是Optional类"><a href="#什么是Optional类" class="headerlink" title="什么是Optional类"></a>什么是Optional类</h2><p>Optional<T> 类 (java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在用 Optional 可以更好的表达这个概念；并且可以避免空指针异常的发生，还有就是快速定位空指针异常的位置。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>Optional.of(T t)：创建一个 Optional 实例</li><li>Optional.empty(T t)：创建一个空的 Optional 实例</li><li>Optional.ofNullable(T t)：若 t 不为 null，创建 Optional 实例，否则空实例</li><li>isPresent()：判断是否包含某值</li><li>orElse(T t)：如果调用对象包含值，返回该值，否则返回 t</li><li>orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回 s 获取的值</li><li>map(Function f)：如果有值对其处理，并返回处理后的 - Optional，否则返回 Optional.empty()</li><li>flatmap(Function mapper)：与 map 相似，要求返回值必须是 Optional</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Optional.of(T t):</span>    Optional&lt;Employee&gt; op = Optional.of(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 能快速锁定空指针异常的位置</span>    Employee employee = op.get();    System.out.println(employee);    <span class="hljs-comment">// Optional.empty(T t)</span>    Optional&lt;Employee&gt; op = Optional.empty(); <span class="hljs-comment">// 构建空的Optional</span>    Employee employee = op.get();    <span class="hljs-comment">// Optional.ofNullable(T t):</span>    <span class="hljs-comment">/* 源码：</span><span class="hljs-comment">     *     public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T var0) &#123;</span><span class="hljs-comment">     *        return var0 == null ? empty() : of(var0);</span><span class="hljs-comment">     *     &#125;</span><span class="hljs-comment">     * */</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    Employee employee = op.get();    <span class="hljs-comment">// isPresent():</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    <span class="hljs-keyword">if</span> (op.isPresent()) &#123; <span class="hljs-comment">// 是否有值</span>        Employee employee = op.get();    &#125;    <span class="hljs-comment">// orElse(T t)等于说设置默认值，有值就使用对象的值，没有就使用设置的默认值:</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    Employee test = op.orElse(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"test"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22.33</span>)); <span class="hljs-comment">// 避免出现空指针异常</span>    System.out.println(test);    <span class="hljs-comment">// orElseGet(Supplier s):</span>    <span class="hljs-comment">// 函数式接口就意味着你能写任意的功能</span>    op.orElseGet(() -&gt; <span class="hljs-keyword">new</span> Employee());    <span class="hljs-comment">// map(Function f)：</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"test"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22.33</span>));    Optional&lt;Object&gt; o = op.map((e) -&gt; e.getName()); <span class="hljs-comment">// 把容器中的对象应用到函数上</span>    System.out.println(o.get());    <span class="hljs-comment">// flatmap(Function mapper)：</span>    <span class="hljs-comment">// 和map的区别就是返回的值必须被Optional包装起来</span>    Optional&lt;String&gt; str = op.flatMap((e) -&gt; Optional.of(e.getName())); <span class="hljs-comment">// 进一步防止空指针异常</span>    System.out.println(str.get());&#125;</code></pre><p>总结：<br>Optional类给我进行空指针异常的判断提供了很大的便利，之前我们判断空指针异常大多数情况下都是使用if(xxx != null)进行判断，然后根据不同的情况，返回不同的值。</p><p>但是这种使用if的情况，如果需要判断的属性很多，那么if就会出现嵌套很冗余的情况，大量的if反而影响可读性。</p><p>现在有了Java8以后我们就可以选择Optional类，所以我们可以对我们的类属性进行Optional包装。</p><p>下面我们看一个实例，获取男人女神的名字，我通过两种方式避免空指针异常：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewMan</span> </span>&#123;    <span class="hljs-comment">// Optional也属于对象，所以我们不能赋值为null，这样就没有意义了（它自己调用自己的方法也是null），所以我们可以创建一个空的Optional实例</span>    <span class="hljs-keyword">private</span> Optional&lt;Godness&gt; godness = Optional.empty();&#125;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Godness</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Optional&lt;NewMan&gt; newMan)</span></span>&#123;    <span class="hljs-keyword">return</span> newMan.orElse(<span class="hljs-keyword">new</span> NewMan())            .getGodness()            .orElse(<span class="hljs-keyword">new</span> Godness(<span class="hljs-string">"波多野菊衣"</span>));            .getName();&#125;<span class="hljs-comment">// 这里的man中的属性是没有被Optional修饰的</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(Man man)</span></span>&#123;    <span class="hljs-keyword">if</span> (man != <span class="hljs-keyword">null</span>)&#123;        Godness gn = man.getGodness;        <span class="hljs-keyword">if</span> (gn != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> gn.getName;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"波多野菊衣"</span>;&#125;</code></pre><p>通过以上两种方式都可以在对象为null的时候设置默认值避免空指针异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法引用和构造器引用</title>
    <link href="/cxlittlecute/caf276df.html"/>
    <url>/cxlittlecute/caf276df.html</url>
    
    <content type="html"><![CDATA[<h1 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h1><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>若Lambda体中的内容有方法已经实现了，我们可以使用方法引用。（可以说方法引用是Lambda表达式的另一种表现形式）</p><p>主要有三种语法格式：</p><ul><li>对象 :: 实例方法</li><li>类 :: 静态方法</li><li>类 :: 实例方法</li></ul><p>注意：Lambda 表达体中调用方法的参数列表、返回类型必须和函数式接口中抽象方法保持一致。</p><pre><code class="hljs java"><span class="hljs-comment">// 对象：：实例方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    PrintStream ps = System.out; <span class="hljs-comment">// 已经有方法实现，并且参数和返回值一致</span>    Consumer&lt;String&gt; con1 = (s) -&gt; ps.println(s);        <span class="hljs-comment">// 在Lambda体的内容中如果已经有方法完成这个功能的时候，我们就可以使用方法引用的方式代替表达式</span>    <span class="hljs-comment">// 注意：这个函数接口中的抽象方法的参数列表与返回值类型，要与我们当前调用方法的参数和返回值类型保持一致。</span>    PrintStream out = System.out;    Consumer&lt;String&gt; consumer2 = out::print;        Consumer&lt;String&gt; consumer3 = System.out::println;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 类：：静态方法名</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);    System.out.println(com1.compare(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//类：：实例方法名</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y); <span class="hljs-comment">// 其他接口</span>    System.out.println(bp1.test(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>));    BiPredicate&lt;String, String&gt; bp2 = String::equals;    System.out.println(bp2.test(<span class="hljs-string">"c"</span>,<span class="hljs-string">"c"</span>));&#125;</code></pre><p>使用类：：实例方法名调用的条件：</p><p>注意：Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method。<br>如上面x是调用者，y是方法的参数。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><ul><li>ClassName::new</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;    Supplier&lt;List&gt; sup1 = () -&gt; <span class="hljs-keyword">new</span> ArrayList();    Supplier&lt;List&gt; sup2 = ArrayList::<span class="hljs-keyword">new</span>;&#125;</code></pre><p>注意：需要调用的构造器的参数列表要与函数时接口中抽象方法的参数列表保持一致。</p><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><ul><li>Type::new</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    Function&lt;Integer, String[]&gt; function = (x) -&gt; <span class="hljs-keyword">new</span> String[x];    String[] apply = function.apply(<span class="hljs-number">10</span>);    System.out.println(apply.length);    Function&lt;Integer, String[]&gt; function2 = String[]::<span class="hljs-keyword">new</span>;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了类：：实例方法名调用的条件是Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method外。</p><p>其他的都需要Lambda 表达体中调用方法或构造器的参数列表、返回类型必须和函数式接口中抽象方法保持一致。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四大内置核心函数式接口</title>
    <link href="/cxlittlecute/860e391d.html"/>
    <url>/cxlittlecute/860e391d.html</url>
    
    <content type="html"><![CDATA[<h1 id="四大内置核心函数式接口"><a href="#四大内置核心函数式接口" class="headerlink" title="四大内置核心函数式接口"></a>四大内置核心函数式接口</h1><p>写lambda表达式需要有函数式接口支持，并不是说每次用lambda表达式时都要自定义一个函数式接口，实际上，Java8已经为我们准备了java.util.function包，其中有许多非常实用的函数式接口。大致可以分为4种，下面介绍4种核心的接口的典型代表：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719204458.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Comsumer&lt;T&gt;：消费型接口</span><span class="hljs-comment">      *   void accept(T t）;</span><span class="hljs-comment">      * */</span>      Consumer&lt;Integer&gt; consumer = (x) -&gt; System.out.println(x);      consumer.accept(<span class="hljs-number">50</span>);      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Supplier&lt;T&gt;：供给型接口</span><span class="hljs-comment">      *   T get();</span><span class="hljs-comment">      * */</span>      Supplier&lt;Integer&gt; supplier = () -&gt;(<span class="hljs-keyword">int</span>)Math.random()*<span class="hljs-number">10</span>;      supplier.get();      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Function&lt;T,R&gt;：函数型接口</span><span class="hljs-comment">      *   R apply(T t);</span><span class="hljs-comment">      * */</span>      String oldStr = <span class="hljs-string">"123456"</span>;      Function&lt;String, String&gt; function = (s) -&gt; s.substring(<span class="hljs-number">1</span>, s.length()-<span class="hljs-number">1</span>);      System.out.println(function.apply(oldStr));      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Predicate&lt;T&gt;：断言型接口</span><span class="hljs-comment">      *   boolean test(T t)</span><span class="hljs-comment">      * */</span>      <span class="hljs-comment">//Predicate&lt;T&gt;</span>      Integer money = <span class="hljs-number">100</span>;      Predicate&lt;Integer&gt; predicate = (i) -&gt; i &gt;= <span class="hljs-number">100</span>;      <span class="hljs-keyword">if</span> (predicate.test(money))&#123;          System.out.println(<span class="hljs-string">"太贵了"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;          System.out.println(<span class="hljs-string">"还好"</span>);      &#125;  &#125;</code></pre><ul><li>消费型接口典型的代表为Consumer，其抽象方法为accept(), 该方法仅接受一个参数，并且没有返回值。</li><li>供给型接口的典型代表为Supplier，其抽象方法为get(), 该方法不接受参数，但有返回值。</li><li>函数型接口中的代表为Function，其抽象方法位apply(), 接受有一个参数，并且有返回值。</li><li>断言型接口的典型接口为Predicate，其抽象方法为test(), 接受一个参数，并返回一个布尔值。</li></ul><p>通过这些内置函数式接口可以进行一些自定义实现操作，类似于后面的Stream流。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"test1"</span>, <span class="hljs-string">"test2"</span>, <span class="hljs-string">"test3"</span>);    List&lt;String&gt; filter = filter(list, (s) -&gt; s.length() &gt; <span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (String s : filter) &#123;        System.out.println(s);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span> </span>&#123;    List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : list1) &#123;        <span class="hljs-keyword">if</span> (pre.test(s)) &#123;            list1.add(s);        &#125;    &#125;    <span class="hljs-keyword">return</span> list1;&#125;</code></pre><h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719215547.png" srcset="/img/loading.gif" alt=""></p><p>最后我们看一看四大内置函数式接口的源码实现，和我们自己定义的接口只是多了一些default默认方法的实现：</p><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">this</span>.accept(var2);            var1.accept(var2);        &#125;;    &#125;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.apply(var1.apply(var2));        &#125;;    &#125;    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> var1.apply(<span class="hljs-keyword">this</span>.apply(var2));        &#125;;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (var0) -&gt; &#123;            <span class="hljs-keyword">return</span> var0;        &#125;;    &#125;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test(var2) &amp;&amp; var1.test(var2);        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (var1) -&gt; &#123;            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.test(var1);        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test(var2) || var1.test(var2);        &#125;;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object var0)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == var0 ? Objects::isNull : (var1) -&gt; &#123;            <span class="hljs-keyword">return</span> var0.equals(var1);        &#125;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/cxlittlecute/bbcf5ff7.html"/>
    <url>/cxlittlecute/bbcf5ff7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>继续今天愉快的Java8之旅，Lambda表达式和Stream流是Java8中对Java影响最大的两个改变。</p><h2 id="为什么要使用Lambda"><a href="#为什么要使用Lambda" class="headerlink" title="为什么要使用Lambda"></a>为什么要使用Lambda</h2><p>首先Lambda是种匿名函数，它的表达式可以被当做方法传递的代码。然后它能使我们的编程风格更加简洁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 原来的写法</span>    Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> Integer.compare(o1,o2);        &#125;    &#125;;    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(comparator);    <span class="hljs-comment">// Lambda 表达式</span>    Comparator&lt;Integer&gt; comparator2 = (a, b) -&gt; Integer.compare(a, b);    TreeSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(comparator2);&#125;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一、 Lambda表达式引入了一个新的操作符”-&gt;”，该操作符被称为箭头操作符或Lambda操作符。将表达式分为两个部分：</p><p>左侧：表达式参数列表<br>右侧：表达式所要执行的功能，Lambda体</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 语法格式一：无参数，无返回值：() -&gt; sout</span>    Runnable r = ()-&gt; System.out.println(<span class="hljs-string">"hello Lambda"</span>); <span class="hljs-comment">// 同级别如果有变量仍然无法改变它的值</span>    r.run();    <span class="hljs-comment">// 语法格式二：有一个参数，无返回值</span>    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);    con.accept(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 语法格式三：有一个参数，无返回值 （小括号可以省略不写）</span>    Consumer&lt;String&gt; con2 = x -&gt; System.out.println(x);    con2.accept(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 语法格式四：有两个及以上的参数，有返回值，并且 Lambda 体中有多条语句（用&#123;&#125;括起来）</span>    Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123;        System.out.println(<span class="hljs-string">"多个参数并且有多条语句"</span>);        <span class="hljs-keyword">return</span> Integer.compare(x, y);    &#125;;    <span class="hljs-comment">// 语法格式五：有两个及以上的参数，有返回值，并且 Lambda 体中只有1条语句 （大括号 与 return 都可以省略不写）</span>    Comparator&lt;Integer&gt; com2 = (x,y) -&gt; Integer.compare(x, y);    <span class="hljs-comment">// 语法格式六：Lambda 表达式参数的数据类型可以省略不写，因为 Jvm编译器可以通过上下文推断出数据类型- “类型推断”（要写类型全部参数都必须要写）</span>    Comparator&lt;Integer&gt; com3 = (Integer x,Integer y) -&gt; Integer.compare(x, y);&#125;</code></pre><p>口诀：<br>左右遇一括号省<br>左侧推断类型省</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda表达式需要函数式接口的支持。</p><h3 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h3><p>若接口中只有一个抽象方法的接口，称为函数式接口。可以使用注解@FunctionalInterface修饰,可以检查是否是函数式接口。</p><pre><code class="hljs java"><span class="hljs-comment">// 定义一个函数式接口</span><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFun</span> </span>&#123;    <span class="hljs-function">Integer <span class="hljs-title">count</span><span class="hljs-params">(Integer a, Integer b)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">operation</span><span class="hljs-params">(Integer a, Integer b, MyFun myFun)</span></span>&#123;    <span class="hljs-keyword">return</span> myFun.count(a, b); <span class="hljs-comment">// 这样可以定义两个起始值</span>&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span>&#123;    Integer result = operation(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, (x, y) -&gt; x + y);    System.out.println(result);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap理解总结</title>
    <link href="/cxlittlecute/56a14e38.html"/>
    <url>/cxlittlecute/56a14e38.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap理解总结"><a href="#HashMap理解总结" class="headerlink" title="HashMap理解总结"></a>HashMap理解总结</h1><p>最近重新回顾一下Java8的一些改动。HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。于是通过这篇文章记录我对它的一些理解。</p><p>在进入HashMap之前我们先来了解几个常见的概念。</p><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>哈希表也称为散列表，是根据关键码值而直接访问的数据结构，也就是说可以通过关键码值映射到哈希表中的一个位置进行数据操作，</p><p>这个映射函数称为散列函数，存放记录的数组称为散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719092813.png" srcset="/img/loading.gif" alt=""></p><h2 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h2><p>由于我们的哈希表主体是数组，那么它的数组容量就是确定的固定的，不可避免的会出现，两个元素通过哈希函数求出的实际存储地址值相同的情况。</p><p>也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p><p>所以从这里我们可以知道，我们哈希函数的设计就显得尤为重要了，因此我们要尽可能保证我们的计算简单和散列地址分布均匀。</p><p>解决办法：</p><ul><li>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</li><li>再散列函数法</li><li>链表法</li></ul><h2 id="1-7和1-8中HashMap的变化"><a href="#1-7和1-8中HashMap的变化" class="headerlink" title="1.7和1.8中HashMap的变化"></a>1.7和1.8中HashMap的变化</h2><h3 id="头插法和尾插法以及为什么会导致死环？"><a href="#头插法和尾插法以及为什么会导致死环？" class="headerlink" title="头插法和尾插法以及为什么会导致死环？"></a>头插法和尾插法以及为什么会导致死环？</h3><ul><li>JDK1.7用的是头插法，JDK1.8用的是尾插法，为什么要这样做？<br>头插法就是说新来的值会取代原有的值，原有的值就顺推到链表中去。改为尾插法的目的主要就是为了防止多线程扩容后出现死环的情况。</li></ul><p>我们先来看一下JDK1.7扩容的核心代码：</p><pre><code class="hljs java"><span class="hljs-comment">//将老的表中的数据拷贝到新的结构中  </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;          <span class="hljs-keyword">int</span> newCapacity = newTable.length;<span class="hljs-comment">//容量  </span>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="hljs-comment">//遍历所有桶</span>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123;  <span class="hljs-comment">//遍历桶中所有元素（是一个链表）</span>                Entry&lt;K,V&gt; next = e.next;                  <span class="hljs-keyword">if</span> (rehash) &#123;<span class="hljs-comment">//如果是重新Hash，则需要重新计算hash值  </span>                    e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);                  &#125;                  <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="hljs-comment">//定位Hash桶  </span>                e.next = newTable[i];<span class="hljs-comment">//元素连接到桶中,这里相当于单链表的插入，总是插入在最前面</span>                newTable[i] = e;<span class="hljs-comment">//newTable[i]的值总是最新插入的值</span>                e = next;<span class="hljs-comment">//继续下一个元素  </span>            &#125;          &#125;      &#125;</code></pre><p>HashMap扩容导致死循环的主要原因在于扩容后链表中的节点在新的hash桶使用头插法插入。</p><p>新的hash桶会倒置原hash桶中的单链表，那么在多个线程同时扩容的情况下就可能导致产生一个存在闭环的单链表，从而导致死循环。</p><p>JDK1.8由于使用的是尾插法，不会导致单链表的倒置，所以扩容的时候不会导致死循环。</p><h3 id="为什么扩容后数据存储位置的计算方式不同？"><a href="#为什么扩容后数据存储位置的计算方式不同？" class="headerlink" title="为什么扩容后数据存储位置的计算方式不同？"></a>为什么扩容后数据存储位置的计算方式不同？</h3><p>源码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 分析1：hash(key)</span><span class="hljs-comment">  * 作用：计算传入数据的哈希码（哈希值、Hash值）</span><span class="hljs-comment">  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样  扰动函数  使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span><span class="hljs-comment">  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span><span class="hljs-comment">  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span><span class="hljs-comment">  */</span>    <span class="hljs-comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;     h ^= k.hashCode();      h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);     <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);  &#125;    <span class="hljs-comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span>   <span class="hljs-comment">// 1. 取hashCode值： h = key.hashCode() </span>   <span class="hljs-comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;         <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 计算存储位置的函数分析：indexFor(hash, table.length)</span><span class="hljs-comment">  * 注：该函数仅存在于JDK 1.7</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;         <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);        <span class="hljs-comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span> &#125;</code></pre><p>在JDK1.7的时候是直接用键的hashcode值与新数组的长度进行&amp;运算得到新数组的位置。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200726113745.png" srcset="/img/loading.gif" alt=""></p><p>而在jdk1.8中虽然扩容之后的数组和1.7是一样的，但是在计算元素位置的方式上不太一样，jdk1.7需要与新的数组长度进行重新hash运算，这个方式是相对耗性能的，而在1.8中对这一步进行了优化。</p><p>在1.8中我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><h3 id="为什么HashMap的数组长度一定是2的次幂？"><a href="#为什么HashMap的数组长度一定是2的次幂？" class="headerlink" title="为什么HashMap的数组长度一定是2的次幂？"></a>为什么HashMap的数组长度一定是2的次幂？</h3><pre><code class="hljs java"><span class="hljs-comment">// Java8中计算数组索引下标的位置</span>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]</code></pre><p>因为hashMap 的数组长度都是2的n次幂 ，那么对于这个数再减去1，转换成二进制的话，就肯定是最高位为0，其他位全是1 的数。</p><p>以Java8为例当数组长度不为2的n次幂 的时候，hashCode 值与数组长度减一做与运算的时候，会出现重复的数据，</p><p>因为不为2的n次幂 的话，对应的二进制数肯定有一位为0 , 这样不管你的hashCode 值对应的该位，是0还是1 ,</p><p>最终得到的该位上的数肯定是0，这带来的问题就是HashMap上的数组元素分布不均匀，而数组上的某些位置，永远也用不到。</p><p>这将带来的问题就是你的HashMap 数组的利用率太低，并且链表可能因为上边的(n - 1) &amp; hash 运算结果碰撞率过高，导致链表太深。(当然jdk 1.8已经在链表数据超过8个以后转换成了红黑树的操作，但那样也很容易造成它们之间的转换时机的提前到来)，所以说HashMap的长度一定是2的次幂，否则会出现性能问题。</p><p>总之，当数组长度为2的n次幂是，不同的key通过位运算获取的数组下标冲突的几率会小很多。冲突少了，添加元素的效率自然就会更高，数据在数组上的分布也会更加均匀，相应的链表长度也会更短。</p><p>这样我们在查询的时候，由于数据的分布均匀、链表长度不是很长而且均匀，使我们的查询效率也会变高很多。</p><h3 id="扩容因子为什么是0-75？"><a href="#扩容因子为什么是0-75？" class="headerlink" title="扩容因子为什么是0.75？"></a>扩容因子为什么是0.75？</h3><p>假设hash函数是理想的，数据会通过hash函数均匀的映射到数组上。一个数据映射到每一个桶（bucket）的概率是相等的。那么在任意的数组容量下，put一个数据发生碰撞的概率=数组元素个数/数组容量。</p><p>设置为0.75是做好了时间和空间的权衡的，因为扩容因子越大，碰撞的概率也就越大，发生碰撞后的代价也更大，结果导致效率也大打折扣。所以设置为0.75空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p><h3 id="底层实现原理的区别"><a href="#底层实现原理的区别" class="headerlink" title="底层实现原理的区别"></a>底层实现原理的区别</h3><h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>HashMap map = new HashMap();<br>在实例化以后，底层创建一个长度是16的一维数组Entry[] table。<br>…put很多次后…</p><p>map.put(key1,value1);</p><p>首先，调用key1所在类的hashcode计算key1哈希值，此哈希值经过某种算法后，得到在Entry数组中的存放位置。</p><p>如果该位置上数据为空，此时key和value直接添加成功。<br>如果该位置上数据不为空，说明该位置上存在一个或多个数据(以链表存储)，那么接着就会比较我们的key和已存在的数据的哈希值：</p><pre><code>如果key的哈希值与已存在数据的哈希值不同，添加成功。如果key的哈希值与已存在数据的哈希值相同，继续使用equals方法比较：    如果equals返回false，此时key添加成功。    如果equals返回true，此时value1替换value2。</code></pre><p>扩容的方式是将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><ol><li>new HashMap刚开始时底层没有创建一个长度为16的数组</li><li>底层数组不是Entry[]，变为了Node[]</li><li>首次调用put（）方法时，底层创建长度为16的数组</li><li>jdk7底层结构：数组+链表，jdk8底层结构：数组+链表+红黑树<br>当数组的某一个索引位置上的以链表形式存在的个数&gt;8且当前数组的长度&gt;64，此时此索引位置上的所有数据改为使用红黑树存储。</li></ol><p>参考：<br><a href="https://blog.csdn.net/qq32933432/article/details/86668385" target="_blank" rel="noopener">https://blog.csdn.net/qq32933432/article/details/86668385</a><br><a href="https://blog.csdn.net/liyantianmin/article/details/79401854" target="_blank" rel="noopener">https://blog.csdn.net/liyantianmin/article/details/79401854</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a><br><a href="https://blog.csdn.net/Tane_1018/article/details/103392267" target="_blank" rel="noopener">https://blog.csdn.net/Tane_1018/article/details/103392267</a><br><a href="https://www.jianshu.com/p/ee0de4c99f87" target="_blank" rel="noopener">https://www.jianshu.com/p/ee0de4c99f87</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream知识用法总结</title>
    <link href="/cxlittlecute/8a5cc6c1.html"/>
    <url>/cxlittlecute/8a5cc6c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-8-Stream"><a href="#JAVA-8-Stream" class="headerlink" title="JAVA 8 Stream"></a>JAVA 8 Stream</h1><p>最近写项目经常用到Java8新API stream流，当我们的项目数据量比较大的时候，很少会使用外键约束，因为这样产生的笛卡尔集，数量巨大，会造成我们的系统性能低下。</p><p>我们为了能避免这样的情况发生，一般会去除外键，那么通过一个一个表查询出来的数据，如何才能更好的进行VO或者TO的封装了，使用StreamAPI就是一个不错的处理方式。</p><p>于是，通过本篇文章对此进行一个知识点和用法的总结，帮助你了解和学习它的使用。</p><h2 id="Stream是什么"><a href="#Stream是什么" class="headerlink" title="Stream是什么"></a>Stream是什么</h2><p>数据渠道，用于操作数据源所生产的元素序列。</p><p>集合讲的是数据，流讲的是计算。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它的主要作用就是，使用一种管道流的思想处理我们的集合对象，对集合对象进行如同SQL语句一样的查找、过滤、排序等操作。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>Stream自己不会存储数据。</li><li>Stream不会改变源对象。</li><li>数据源来源：集合、数组、IO channel、生成器函数等.</li><li>借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。</li><li>中间操作返回新流，它们总是惰性的（延时执行），除非流水线触发终止操作，否则中间操作不会执行任何处理。由于是在终止操作时一次性全部处理，也称为惰性求值。</li><li>内部迭代：迭代操作是stream API完成的。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一、创建Stream</p><p>从一个数据源，如集合、数组中获取流。</p><p>二、中间操作</p><p>一个操作的中间链，对数据源的数据进行操作。</p><p>三、终止操作</p><p>一个终止操作，执行中间操作链，并产生结果。</p><h2 id="创建Stream流"><a href="#创建Stream流" class="headerlink" title="创建Stream流"></a>创建Stream流</h2><ul><li><p>stream() − 创建顺序流。</p></li><li><p>parallelStream() − 创建并行流。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 集合流</span><span class="hljs-comment"> *  - Collection.stream() 穿行流</span><span class="hljs-comment"> *  - Collection.parallelStream() 并行流</span><span class="hljs-comment"> */</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream();<span class="hljs-comment">/*</span><span class="hljs-comment">* 数组流</span><span class="hljs-comment">*   Arrays.stream(array)</span><span class="hljs-comment">* */</span>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];Stream&lt;String&gt; stream2 = Arrays.stream(strings);<span class="hljs-comment">/*</span><span class="hljs-comment">* 3.Stream 静态方法</span><span class="hljs-comment">*   Stream.of(...)</span><span class="hljs-comment">* */</span>Stream&lt;Integer&gt; stream3 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">* 4.无限流（一直停不下来）</span><span class="hljs-comment">*  (1)迭代</span><span class="hljs-comment">*  (2)生成</span><span class="hljs-comment">* */</span><span class="hljs-comment">// 迭代</span>Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>);<span class="hljs-comment">// 生成(可无限制造对象)</span>Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());<span class="hljs-comment">/*</span><span class="hljs-comment">* 5.BufferedReader.lines()将每行内容转成流</span><span class="hljs-comment"> * */</span>BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"stream.txt"</span>));Stream&lt;String&gt; lineStream = reader.lines();<span class="hljs-comment">/*</span><span class="hljs-comment">*6.Pattern.splitAsStream() 将字符串分隔成流</span><span class="hljs-comment">* */</span>Pattern pattern = Pattern.compile(<span class="hljs-string">","</span>);Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="hljs-string">"a,b,c,d"</span>);</code></pre><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="筛选-切片"><a href="#筛选-切片" class="headerlink" title="筛选/切片"></a>筛选/切片</h3><ul><li>filter：接收 Lambda ，从流中排除某些元素</li><li>limit：截断流，使其元素不超过给定数量</li><li>skip(n)：跳过元素，返回一个舍弃了前n个元素的流；若流中元素不足n个，则返回一个空流；与 limit(n) 互补</li><li>distinct：筛选，通过流所生成的 hashCode() 与 equals() 取除重复元素</li></ul><pre><code class="hljs java">List&lt;Employee&gt; emps = Arrays.asList(        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">101</span>, <span class="hljs-string">"Z3"</span>, <span class="hljs-number">19</span>, <span class="hljs-number">9999.99</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">102</span>, <span class="hljs-string">"L4"</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7777.77</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">103</span>, <span class="hljs-string">"W5"</span>, <span class="hljs-number">35</span>, <span class="hljs-number">6666.66</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">104</span>, <span class="hljs-string">"Tom"</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1111.11</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">105</span>, <span class="hljs-string">"Jerry"</span>, <span class="hljs-number">60</span>, <span class="hljs-number">4444.44</span>));<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 中间操作：不执行任何操作</span>    <span class="hljs-comment">// 此API属于内部迭代</span>    <span class="hljs-comment">// 外部迭代是我们自己编写的for 和 foreach方法</span>    Stream&lt;Employee&gt; stream = emps.stream()            .filter((x) -&gt; x.getAge() &gt; <span class="hljs-number">35</span>)            .limit(<span class="hljs-number">3</span>) <span class="hljs-comment">// 注意：短路 达到满足不再内部迭代</span>            .distinct() <span class="hljs-comment">// 注意：重写hashcode和equals方法</span>            .skip(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 终止操作：一次性执行全部内容，惰性求值</span>    stream.forEach(System.out::println);&#125;</code></pre><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ul><li>map：接收 Lambda ，将元素转换为其他形式或提取信息；接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li><li>flatMap：接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 大小写转换，该函数会被应用到每个元素上，并将其映射成一个新的元素</span>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);    list.stream()            .map((str) -&gt; str.toUpperCase())            .forEach(System.out::println);    <span class="hljs-comment">// 提取集合对象中信息</span>    emps.stream()            .map(Employee::getAge)            .forEach(System.out::println);&#125;</code></pre><p>在使用flatmap之前我们先看这样一个案例，将集合中字符串中的所有字符提取出来。在我们不使用flatmap之前我们需要进行嵌套的两次foreach，因为我们的filterCharacter方法也是返回的stream流对象：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">filterCharacter</span><span class="hljs-params">(String str)</span> </span>&#123;    List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;        list.add(c);    &#125;    <span class="hljs-keyword">return</span> list.stream();&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"bc"</span>, <span class="hljs-string">"ca"</span>);    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream()            .map(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数上的效果&#123;&#123;a,b,c&#125;,&#123;b,c&#125;,&#123;c,a&#125;&#125;，最终在一个大流中</span>    streamStream.forEach((sm) -&gt; &#123;        sm.forEach(System.out::println);    &#125;);&#125;</code></pre><p>那么我们可以再看看flatMap的作用，接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流。重点：flatMap得到的是一个流！</p><pre><code class="hljs java">Stream&lt;Character&gt; characterStream = list.stream()        .flatMap(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数的效果，去掉大流整合成一个流&#123;a,b,c,b,c,c,a&#125;</span>characterStream.forEach(System.out::println);</code></pre><p>此处总结一下这里，等于说Map是把一个个的流放入一个新的流中，导致流的嵌套；而flatMap是将一个个流中的元素放入新的流中。（这样会好理解一些）</p><p>类比于：集合中的add(Object obj)  addAll(Collection coll)方法。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>sorted()：自然排序(Comparable)</li><li>sorted(Comparator c)：定制排序(Comparator)</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自然排序</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);    list.stream()            .sorted() <span class="hljs-comment">//comparaTo()</span>            .forEach(System.out::println);        <span class="hljs-comment">// 定制排序</span>    emps.stream()            .sorted((e1, e2) -&gt; &#123; <span class="hljs-comment">//compara()</span>                <span class="hljs-keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123;                    <span class="hljs-keyword">return</span> e1.getName().compareTo(e2.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> e1.getAge().compareTo(e2.getAge());                &#125;            &#125;)            .forEach(System.out::println);&#125;</code></pre><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"aa"</span>, <span class="hljs-number">10</span>);    Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"bb"</span>, <span class="hljs-number">20</span>);    List&lt;Student&gt; studentList = Arrays.asList(s1, s2);    studentList.stream()            .peek(o -&gt; o.setAge(<span class="hljs-number">100</span>))            .forEach(System.out::println);    <span class="hljs-comment">//结果：</span>    Student&#123;name=<span class="hljs-string">'aa'</span>, age=<span class="hljs-number">100</span>&#125;    Student&#123;name=<span class="hljs-string">'bb'</span>, age=<span class="hljs-number">100</span>&#125;&#125;</code></pre><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><ul><li>allMatch：检查是否匹配所有元素</li><li>anyMatch：检查是否至少匹配一个元素</li><li>noneMatch：检查是否没有匹配所有元素</li><li>findFirst：返回第一个元素</li><li>findAny：返回当前流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中最大值</li><li>min：返回流中最小值</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    List&lt;Status&gt; list = Arrays.asList(Status.FREE, Status.BUSY, Status.VOCATION);    <span class="hljs-keyword">boolean</span> flag1 = list.stream()            .allMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag1);    <span class="hljs-keyword">boolean</span> flag2 = list.stream()            .anyMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag2);    <span class="hljs-keyword">boolean</span> flag3 = list.stream()            .noneMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag3);    <span class="hljs-comment">// 避免空指针异常</span>    Optional&lt;Status&gt; op1 = list.stream()            .findFirst();    <span class="hljs-comment">// 如果Optional为空 找一个替代的对象</span>    Status s1 = op1.orElse(Status.BUSY);    System.out.println(s1);    Optional&lt;Status&gt; op2 = list.stream()            .findAny();    System.out.println(op2);    <span class="hljs-keyword">long</span> count = list.stream()            .count();    System.out.println(count);    <span class="hljs-comment">// 获取最大工资的员工信息</span>    Optional&lt;Employee&gt; max = emps.stream()            .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));    System.out.println(max.get());    <span class="hljs-comment">// 获取最小工资</span>    Optional&lt;Double&gt; min = emps.stream()            .map(Employee::getSalary)            .min(Double::compare);    System.out.println(min.get());&#125;</code></pre><h2 id="归约-收集"><a href="#归约-收集" class="headerlink" title="归约/收集"></a>归约/收集</h2><ul><li>归约：reduce(T identity, BinaryOperator) / reduce(BinaryOperator) 可以将流中的数据反复结合起来，得到一个值</li><li>收集：collect 将流转换成其他形式；接收一个 Collector 接口的实现，用于给流中元素做汇总的方法</li></ul><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 归约</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);    Integer sum = list.stream()            .reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x + y); <span class="hljs-comment">// identity起始值 binaryOperator二元运算 现将起始值作为x，从流中取出元素作为y</span>    System.out.println(sum);    System.out.println(<span class="hljs-string">"-----------------------------------------"</span>);        <span class="hljs-comment">// 获取当前所有员工工资总和</span>    Optional&lt;Double&gt; reduce = emps.stream()            .map(Employee::getSalary)            .reduce(Double::sum); <span class="hljs-comment">// 为什么这里返回Optional？因为这里没有设置起始值</span>&#125;</code></pre><p>map和reduce的连接通常称为map-reduce模式，现在大数据经常应用这种模式。</p><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><p>collect-将流转换为其他形式。接收一个Collection接口的实现，用于给stream中元素汇总的方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 把公司员工所有名字提取出来，放入集合中</span>        List&lt;String&gt; list = emps.stream()                .map(Employee::getName)                .collect(Collectors.toList());<span class="hljs-comment">// Collectors实现类提供了很多静态方法，创建常见的收集器实例</span>        list.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        Set&lt;String&gt; set = emps.stream()                .map(Employee::getName)                .collect(Collectors.toSet());        set.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        HashSet&lt;String&gt; hs = emps.stream()                .map(Employee::getName)                .collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));        hs.forEach(System.out::println);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 收集总数</span>        Long collect = emps.stream()                .collect(Collectors.counting());        <span class="hljs-comment">// 平均值</span>        Double avg = emps.stream()                .collect(Collectors.averagingDouble(Employee::getSalary)); <span class="hljs-comment">// 指定了map</span>        System.out.println(avg);        <span class="hljs-comment">// 总和</span>        Double collect1 = emps.stream()                .collect(Collectors.summingDouble(Employee::getSalary));        System.out.println(collect1);        <span class="hljs-comment">// 最大值</span>        Optional&lt;Employee&gt; max = emps.stream()                .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));        System.out.println(max.get());        <span class="hljs-comment">// 最小值</span>        Optional&lt;Double&gt; min = emps.stream()                .map(Employee::getSalary)                .collect(Collectors.minBy(Double::compare));        System.out.println(min.get());        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 根据状态分组</span>        Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus));        System.out.println(map);        <span class="hljs-comment">// 多级分组</span>        Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; collect2 = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123;                    <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">35</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"青年"</span>;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">50</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"中年"</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"老年"</span>;                    &#125;                &#125;)));        <span class="hljs-comment">//分区</span>        Map&lt;Boolean, List&lt;Employee&gt;&gt; listMap = emps.stream()                .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; <span class="hljs-number">5000</span>)); <span class="hljs-comment">// 满足条件的一个区，不满足条件的在另一个区</span>        System.out.println(listMap);&#125;</code></pre><p>最后还有收集获取运算结果的其他方式和连接操作：</p><pre><code class="hljs java">DoubleSummaryStatistics dss = emps.stream()       .collect(Collectors.summarizingDouble(Employee::getSalary));   System.out.println(dss.getMax());   System.out.println(dss.getMin());   System.out.println(dss.getSum());   System.out.println(dss.getCount());   System.out.println(dss.getAverage());      <span class="hljs-comment">// 将参数连接起来</span>   String str = emps.stream()       .map(Employee::getName)       .collect(Collectors.joining(<span class="hljs-string">"-"</span>));  <span class="hljs-comment">// 可传入分隔符，首尾需要接着添加两个参数</span>   System.out.println(str);</code></pre><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><ul><li>并行流：就是把一个内容分成几个数据块，并用不同的线程分别处理每个数据块的流。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行操作；Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与串行流之间切换。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//串行流(单线程)：切换为并行流 parallel()</span>    <span class="hljs-comment">//并行流：切换为串行流 sequential()</span>    LongStream.rangeClosed(<span class="hljs-number">0</span>, <span class="hljs-number">100000000L</span>)            .parallel() <span class="hljs-comment">//底层：Fork Join</span>            .reduce(<span class="hljs-number">0</span>, Long::sum);&#125;</code></pre><p>fork join类似于归并排序，比较重要的思想就是工作窃取模式，它会将要执行的新任务，拆分为更小的任务执行，将小任务放入线程队列中，如果自己的线程空闲了，就会去别的线程偷取一个小任务放入自己的线程执行。这种方式减少了线程等待的时间，提高了性能。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075629.png" srcset="/img/loading.gif" alt=""></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>最后根据一个图更好的了解Stream 中间操作和结束操作的分类：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075903.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>无状态：指元素的处理不受之前元素的影响。</p></li><li><p>有状态：指该操作只有拿到所有元素之后才能继续下去。<br>（判断流操作是否有状态的判断标准，就是看是否需要知道先前的数据历史。前后数据是否有依赖关系来判断）</p></li><li><p>非短路操作：指必须处理所有元素才能得到最终结果。</p></li><li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p></li></ul><p>参考：<br><a href="https://blog.csdn.net/y_k_y/article/details/84633001" target="_blank" rel="noopener">https://blog.csdn.net/y_k_y/article/details/84633001</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GateWay网关访问服务出现503的问题解决</title>
    <link href="/cxlittlecute/674d8191.html"/>
    <url>/cxlittlecute/674d8191.html</url>
    
    <content type="html"><![CDATA[<h1 id="GateWay网关访问服务出现503的问题解决"><a href="#GateWay网关访问服务出现503的问题解决" class="headerlink" title="GateWay网关访问服务出现503的问题解决"></a>GateWay网关访问服务出现503的问题解决</h1><p>对于这个问题也是困扰了自己很久，今天下定决定要把它干掉。这个问题很坑，建议使用IDEA的朋友都可以看一看。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在分布式服务中，使用GateWay网关进行服务请求路由的统一管理，它是系统对外的唯一入口。为了让网关能正常发送调用其他服务，我使用到了Nacos服务注册中心。</p><p>正是这样出现了，我通过服务端口，能正常访问接口返回数据，通过网关访问有时可以有时不行的情况（也就是出现503的状态码反馈）。</p><p>HTTP状态码503指的是web服务器不能处理HTTP请求。原因大致如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716131929.png" srcset="/img/loading.gif" alt="avator"></p><p>那么根据上面这四个原因我还是没有分析出为什么会出现这个问题。于是我开始一步步排查问题。</p><ol><li><p>我首先认为是我GateWay网关，拦截配置的问题，可是我的情况是有时出现503，有时又能通过网关正常访问，所以暂时排除了这种情况。</p></li><li><p>是否本身的单体服务有问题，但是通过postman的测试，通过服务的端口访问接口，都能正常返回数据。所以也暂时排除这种情况。</p></li><li><p>Nacos注册中心的问题。</p></li></ol><p>那基本能确定是Nacos注册中心的问题了，但也不完全是Nacos的锅。</p><p>再次分析：</p><p>F12查看Network，请求的发送情况，发现OPTIONS预检请求是正常发送的，但发送真正的请求的时候出现了503的错误。如下图:</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133417.png" srcset="/img/loading.gif" alt="avator"></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133338.png" srcset="/img/loading.gif" alt="avator"></p><p>接着我点开了Preview（预览功能），看到了错误提示：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133611.png" srcset="/img/loading.gif" alt="avator"></p><p>我们可以通过错误提示很清晰的看到message的反馈，就是发现不了我的product服务。</p><p>和我们判断的没错是nacos的问题，于是我进入nacos查看服务是否注册成功。</p><p>这里就发现了一个很奇怪的现象，正常的我们刷新nacos的界面服务是不会掉的，但是我的product商品服务，一会有一会儿又没有，刚开始我发现了这个问题，但没有引起注意，也就导致这个问题之前一直没有得到解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是，我抱着再试一试的心态，将该服务的端口号从10000改为了8100，也就是改为了其他的数（或者修改一下服务名），这个服务就在nacos注册中心稳定了。（前提是确保你的服务Nacos配置没有问题）</p><p>这其实是一个很容易解决的bug，但是之前网上找过都没有得到好的解决。</p><p>让我想到了idea在使用过程中确实存在一些bug，常见的就是</p><ol><li><p>创建继承maven项目数量多了之后，项目结构就会不一样，需要手动修改，或者更换项目名才能解决。</p></li><li><p>使用springboot的过程中有些端口无法使用，这种无法使用是由于idea和系统的问题，你能正常跑通你的项目，但是这个项目你无法通过客户端访问，只要访问就是500服务器错误。</p></li></ol><hr><p>同时这里强调，不是因为什么端口被占用的问题，端口如果被占用，连服务都是无法启动的，所以这就是一些简单又很坑人的地方。</p><p>如果您有幸看到了这篇文章，希望对您有帮助，解决到您的问题。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
      <category>GateWay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>GateWay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</title>
    <link href="/cxlittlecute/4e6c6273.html"/>
    <url>/cxlittlecute/4e6c6273.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题"><a href="#Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题" class="headerlink" title="Springboot出现Possibly consider using a shorter maxLifetime value警告问题"></a>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>这是我经常遇到的一个问题，当我们使用Springboot连接数据库的时候（Springboot默认使用的是HikariCP），如果长时间的静默没有请求连接池，那么就会出现如下warn：</p><pre><code class="hljs routeros">[http-nio-7003-exec-10] WARN  com.zaxxer.hikari.pool.PoolBase - HikariPool-1 - Failed <span class="hljs-keyword">to</span> validate<span class="hljs-built_in"> connection </span>com.mysql.cj.jdbc.ConnectionImpl@3987b59f (<span class="hljs-literal">No</span> operations allowed after<span class="hljs-built_in"> connection </span>closed.). Possibly consider using a shorter maxLifetime value.</code></pre><p>我们可以看到这个warn的最后一句话， Possibly consider using a shorter maxLifetime value（让我们考虑使用一个更小的maxLifetime值）。</p><p>看到这里大家肯定会疑惑maxLifeTime是什么？</p><p>我们先来看看官方文档对参数的说明：<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716085042.png" srcset="/img/loading.gif" alt="avator"></p><p>此属性控制池中连接的最长生存期。一个正在使用的连接永远不会失效，只有当它关闭时，它才会被移除。在逐个连接的基础上，应用较小的负衰减以避免池中的大规模灭绝。我们强烈建议设置此值，并且它应该比任何数据库或基础设施施加的连接时间限制短几秒。值为0表示没有最长生存期（无限生存期），当然取决于idleTimeout设置。默认值：1800000（30分钟）。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>其实这个问题很好解决，就是在配置文件中添加HikariCP的参数设置，也就是将maxLifeTime的值变小。</p><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.hikari</span><span class="hljs-selector-class">.max-lifetime</span> =<span class="hljs-number">120000</span></code></pre><p>同时这里需要注意的是，如果这样设置后出现另外的报错：</p><pre><code class="hljs applescript">idleTimeout <span class="hljs-keyword">is</span> close <span class="hljs-keyword">to</span> <span class="hljs-keyword">or</span> more than maxLifetime, disabling <span class="hljs-keyword">it</span>.</code></pre><p>说明你设置的maxLifeTime的值低于了idleTimeout。</p><p>ideaTimeOut是连接允许在池中闲置的最长时间，它有个规则：如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒。</p><p>所以最好是将maxLifeTime和idleTimeOut的值一起按照要求修改。</p><p>文档里面的参数都可以在配置文件中修改默认值，可以根据自己的需要来。</p><p>当然说到这里其实自己也是有疑问的，为什么降低了maxLifeTime就可以避免发生这个问题？现在只是找到方法解决掉了这个问题，但是原理不是很明白，查阅到了相关资料我会进行补充。有想法的朋友可以评论或私信我，互相交流。</p><hr><p>以上的理解如果有偏差，可以通过关于页的联系方式第一时间联系我，我将做好修改更正工作。期待您的回复和反馈。</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>HikariCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>HikariCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云oss上传报错Invalid according to Policy Policy expired</title>
    <link href="/cxlittlecute/1d5383b1.html"/>
    <url>/cxlittlecute/1d5383b1.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"><a href="#阿里云oss上传报错Invalid-according-to-Policy-Policy-expired" class="headerlink" title="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"></a>阿里云oss上传报错Invalid-according-to-Policy-Policy-expired</h1><p>阿里云oss上传使用的是服务端签名后直传；通过服务端生成上传签名，前端使用服务端生成的签名上传文件。</p><p>同时，在这里先说一下为什么要使用服务端签名后直传。</p><p>之前使用OSS时，是让文件过自己的服务器，然后通过自己的服务器传到OSS的服务器，也就是这样：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175217.png" srcset="/img/loading.gif" alt="avator"></p><p>通过上面的这种直传的方式，导致我们的服务端压力很大。虽然我们可以使用JS直接前端传递，但是这样会暴露我们的AccessKeyID和AcessKeySecret，会有安全隐患。</p><p>所以选择了，接下来的这种服务端签名的方式上传：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175427.png" srcset="/img/loading.gif" alt="avator"></p><p>正是使用了这种方式出现了以下这个问题：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174130.png" srcset="/img/loading.gif" alt="avator"></p><p>查询阿里云文档可知错误原因：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174653.png" srcset="/img/loading.gif" alt="avator"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p> 生成签名时，官方代码中的参数expireTime默认是30秒，改为更大的时间。</p><h3 id="代码演示-解决办法"><a href="#代码演示-解决办法" class="headerlink" title="代码演示 解决办法"></a>代码演示 解决办法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Osscontroller</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.endpoint&#125;"</span>)    <span class="hljs-keyword">private</span> String endpoint;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.bucket&#125;"</span>)    <span class="hljs-keyword">private</span> String bucket;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.access-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessId;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.secret-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessKey;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/oss/policy"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">policy</span><span class="hljs-params">()</span> </span>&#123;        String host = <span class="hljs-string">"https://"</span> + bucket + <span class="hljs-string">"."</span> + endpoint; <span class="hljs-comment">// host的格式为 bucketname.endpoint</span>        <span class="hljs-comment">// callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。</span>        <span class="hljs-comment">//String callbackUrl = "http://88.88.88.88:8888";</span>        String format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(<span class="hljs-keyword">new</span> Date());        String dir = format+<span class="hljs-string">"/"</span>; <span class="hljs-comment">// 用户上传文件时指定的前缀。</span>        <span class="hljs-comment">// 创建OSSClient实例。</span>        OSS ossClient = <span class="hljs-keyword">new</span> OSSClientBuilder().build(endpoint, accessId, accessKey);        Map&lt;String, String&gt; respMap = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">long</span> expireTime = <span class="hljs-number">60</span>; <span class="hljs-comment">//增大这里的时间</span>            <span class="hljs-keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="hljs-number">1000</span>;            Date expiration = <span class="hljs-keyword">new</span> Date(expireEndTime);            <span class="hljs-comment">// PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span>            PolicyConditions policyConds = <span class="hljs-keyword">new</span> PolicyConditions();            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="hljs-number">0</span>, <span class="hljs-number">1048576000</span>);            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);            <span class="hljs-keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="hljs-string">"utf-8"</span>);            String encodedPolicy = BinaryUtil.toBase64String(binaryData);            String postSignature = ossClient.calculatePostSignature(postPolicy);            respMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();            respMap.put(<span class="hljs-string">"accessid"</span>, accessId);            respMap.put(<span class="hljs-string">"policy"</span>, encodedPolicy);            respMap.put(<span class="hljs-string">"signature"</span>, postSignature);            respMap.put(<span class="hljs-string">"dir"</span>, dir);            respMap.put(<span class="hljs-string">"host"</span>, host);            respMap.put(<span class="hljs-string">"expire"</span>, String.valueOf(expireEndTime / <span class="hljs-number">1000</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// Assert.fail(e.getMessage());</span>            System.out.println(e.getMessage());        &#125; <span class="hljs-keyword">finally</span> &#123;            ossClient.shutdown();        &#125;        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"data"</span>,respMap);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo消除中文路径</title>
    <link href="/cxlittlecute/8ce042f1.html"/>
    <url>/cxlittlecute/8ce042f1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo消除中文路径"><a href="#Hexo消除中文路径" class="headerlink" title="Hexo消除中文路径"></a>Hexo消除中文路径</h1><p>我们博客中的文章标题，一般都会有中文出现，同时Hexo默认也是会把你的title放在路径访问的最后，也就是xxx.html。</p><p>由于路径中有中文的存在，如果你想根据URL进行操作的时候就会被浏览器编码，也就是URL code字符编码。</p><pre><code class="hljs llvm">https://ccctop.cn/<span class="hljs-number">2020</span>/<span class="hljs-number">07</span>/<span class="hljs-number">13</span>/Jenkins<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%89</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A1</span><span class="hljs-symbol">%8</span>Cshell<span class="hljs-symbol">%E5</span><span class="hljs-symbol">%91</span><span class="hljs-symbol">%BD</span><span class="hljs-symbol">%E4</span><span class="hljs-symbol">%BB</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%EF</span><span class="hljs-symbol">%BC</span><span class="hljs-symbol">%8</span>C<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%8</span>F<span class="hljs-symbol">%90</span><span class="hljs-symbol">%E7</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%BAcommand-not-found</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%A3</span><span class="hljs-symbol">%E5</span><span class="hljs-symbol">%86</span><span class="hljs-symbol">%B3</span>/</code></pre><h2 id="这种中文URL的不缺点："><a href="#这种中文URL的不缺点：" class="headerlink" title="这种中文URL的不缺点："></a>这种中文URL的不缺点：</h2><ol><li><p>关键词被编译后，URL会变得很长，这是搜索引擎不建议的，但并非不能使用;也就是不利于SEO。</p></li><li><p>使用被引用，中文URL在转码后会变成形如：%E5%A9%9A%E7%BA%B1 的结构，一些编辑器支持的问题会造成错误链接地址或错误的URL识别、分割 ，甚至有些网站会产生状态为404的引用指向。</p></li></ol><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>一种是把中文路径变为拼音，另一种就是进行转换编码。在 Hexo 根目录下的 _config.yml 文件中，修改或新增配置项：</p><p>拼音：</p><pre><code class="hljs ada">npm i hexo-permalink-pinyin <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-symbol">permalink_pinyin:</span><span class="hljs-symbol">  enable:</span> true<span class="hljs-symbol">  separator:</span> <span class="hljs-string">'-'</span> <span class="hljs-meta"># default: <span class="hljs-string">'-'</span></span></code></pre><p>编码：</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-meta"># permalink: :title/</span><span class="hljs-symbol">permalink:</span> archives/:abbrlink.html<span class="hljs-symbol">abbrlink:</span><span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta"># 算法：crc16(default) and crc32</span><span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta"># 进制：dec(default) and hex</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins执行shell命令，提示command not found解决</title>
    <link href="/cxlittlecute/61702.html"/>
    <url>/cxlittlecute/61702.html</url>
    
    <content type="html"><![CDATA[<h1 id="Command-not-found"><a href="#Command-not-found" class="headerlink" title="Command not found"></a>Command not found</h1><p>jenkins执行shell命令，有时会提示“Command not found”—-处理方案。</p><p>1.首先，分析是linux环境的问题还是Jenkins的问题。</p><p>如果登录linux，shell命令不可以执行，同样提示“Command not found”，则是环境变量设置失败，需要配置环境变量、/etc/profile。</p><p>如果登录linux，shell命令可以执行，则是jenkins没有加载/etc/profile导致。</p><p>我就是第二种情况。那就是得让jenkins执行我们实际的shell命令之前，执行识别环境变量的shell命令。让Jenkins先读取/etc/profile等的内容。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">source</span> ~/.bash_profile<span class="hljs-built_in">source</span> /etc/profile<span class="hljs-built_in">cd</span>..等其他shell命令</code></pre>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云全站加速HTTPS证书无法开启问题解决</title>
    <link href="/cxlittlecute/10754.html"/>
    <url>/cxlittlecute/10754.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云全站加速HTTPS证书无法开启问题解决"><a href="#阿里云全站加速HTTPS证书无法开启问题解决" class="headerlink" title="阿里云全站加速HTTPS证书无法开启问题解决"></a>阿里云全站加速HTTPS证书无法开启问题解决</h1><p>全站加速（Dynamic Route for Content Delivery Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p><p>1.选择添加域名</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160216.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.添加域名 类型IP（IP就是你服务器IP）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160556.png" srcset="/img/loading.gif" alt="avatar"></p><p>3.HTTPS设置</p><p>我就是在这个地方出现问题的。</p><p>之前没有领取HTTPS证书，所以在这里想一起申请了，也就是选择</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162446.png" srcset="/img/loading.gif" alt="avatar"></p><p>免费证书，点击确定后，弹窗显示了设置成功，但是HTTPS的设置一直都是未开启的状态。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162917.png" srcset="/img/loading.gif" alt="avatar"></p><p>由于不知道问题出现在什么地方，所以找了一下客服。客服的回复如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162759.png" srcset="/img/loading.gif" alt="avatar"></p><p>之后发现出现这个问题的原因是，我自己添加的域名为泛域名，也就是域名前我带了*，这样可能会导致无法颁发证书。</p><p>随后我将*去掉，配置为www或者直接解析域名@,再次去申请证书就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云域名配置</title>
    <link href="/cxlittlecute/202.html"/>
    <url>/cxlittlecute/202.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云域名配置"><a href="#阿里云域名配置" class="headerlink" title="阿里云域名配置"></a>阿里云域名配置</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>登录阿里云，选择域名服务，选择你要购买的域名类型进行购买。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152655.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p><a href="https://beian.aliyun.com/" target="_blank" rel="noopener">https://beian.aliyun.com/</a></p><p>必要进行域名备案才能真正使用上你的域名，备案需要填写你购买域名的用途和你个人信息等，然后进行申请，审批时长大概二十天左右。</p><p>期间保持电话畅通，因为阿里云的客服小姐姐小哥哥可能会给你打电话，如果你有什么信息需要修改的可以第一时间得到反馈。然后就是耐心的等待。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152836.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>当你把以上的步骤完成后，就可以进入域名的管理控制台。<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153119.png" srcset="/img/loading.gif" alt="avatar"></p><p>点击解析 配置你的解析设置：<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153540.png" srcset="/img/loading.gif" alt="avatar"></p><p>这样只需要对应你的IP进行配置就可以实现使用你自己的域名解析到IP上了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建与部署</title>
    <link href="/cxlittlecute/19858.html"/>
    <url>/cxlittlecute/19858.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客搭建与部署"><a href="#Hexo博客搭建与部署" class="headerlink" title="Hexo博客搭建与部署"></a>Hexo博客搭建与部署</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。</p><p>文档地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="如何搭建（参照Hexo文档）"><a href="#如何搭建（参照Hexo文档）" class="headerlink" title="如何搭建（参照Hexo文档）"></a>如何搭建（参照Hexo文档）</h2><p>安装前提：node.js和Git</p><p>node: <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>Git: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre><pre><code class="hljs cmd">$ hexo init &lt;folder&gt;$ <span class="hljs-built_in">cd</span> &lt;folder&gt;$ npm install</code></pre><p>Hexo的安装过程比较简单，主要参照文档就行了。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>hexo项目结构安装好后，就可以选择一个合适的主题，官网有主题的选项，同时也可以去百度上看一下别人选择的主题做出来的效果，有看到喜欢的就用相同的主题。</p><p>我用的主题为：Fluid&emsp;&emsp;  <a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">https://hexo.fluid-dev.com/docs/</a></p><p>这个主题支持的插件基本还可以，界面还是简介大方。</p><p>那么我们只需要下载好相应的主题，按照Hexo官方文档（注意不是主题文档）修改_config.yml这个文件中的内容就可以了。</p><p>很多细小的配置在Fluid主题文档中都有，基本可以把文档看一遍，修改好你想要的设置。</p><h2 id="主题设置细节说明"><a href="#主题设置细节说明" class="headerlink" title="主题设置细节说明"></a>主题设置细节说明</h2><p>我的博客中使用了评论和统计插件。</p><p>评论-Valine <a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></p><p>统计-leancloud <a href="https://www.leancloud.cn/" target="_blank" rel="noopener">https://www.leancloud.cn/</a></p><p>评论和计数的后台都可以通过lencloud的后台系统管理，而且比较稳定。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>重点说一下部署，因为Hexo部署上去的其实就是Public下面的html静态文件，所以可以把public下的文件放置在任何地方。</p><p>文档推荐的是放github下，但是你会发现如果你不翻墙的话，图片很难加载出来，gitee也可以，但是如果你想配置自定义域名的话，就必须要购买gitee自定义域名的产品。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>我使用的是PicGo+Gitee(码云)搭建自己的图床。</p><p>1.将PicGO下载下来，然后安装插件</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713133658.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.配置Gitee<br>点击自己gitee头像-&gt;设置，左边有一个私人令牌，点击右上角生成新令牌，只选择projects,如下图：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150257.png" srcset="/img/loading.gif" alt="avatar"></p><p>注意：私人令牌token只会显示一次，如果没有复制成功只能删除后重新获取。</p><p>3.设置插件githubPlus</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150827.png" srcset="/img/loading.gif" alt="avatar"></p><p>测试：记得修改PicGO中上传区中的图片上传改为:图片上床-githubLPlus这样就可以根据路径来访问你的图片了。</p><pre><code class="hljs stata">最后，感谢Yazzz带我入坑，友链里有<span class="hljs-keyword">ta</span>哦~</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
