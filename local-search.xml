<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HashMap理解总结</title>
    <link href="/cxlittlecute/56a14e38.html"/>
    <url>/cxlittlecute/56a14e38.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap理解总结"><a href="#HashMap理解总结" class="headerlink" title="HashMap理解总结"></a>HashMap理解总结</h1><p>最近重新回顾一下Java8的一些改动。HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。于是通过这篇文章记录我对它的一些理解。</p><p>在进入HashMap之前我们先来了解几个常见的概念。</p><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>哈希表也称为散列表，是根据关键码值而直接访问的数据结构，也就是说可以通过关键码值映射到哈希表中的一个位置进行数据操作，</p><p>这个映射函数称为散列函数，存放记录的数组称为散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719092813.png" srcset="/img/loading.gif" alt=""></p><h2 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h2><p>由于我们的哈希表主体是数组，那么它的数组容量就是确定的固定的，不可避免的会出现，两个元素通过哈希函数求出的实际存储地址值相同的情况。</p><p>也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p><p>所以从这里我们可以知道，我们哈希函数的设计就显得尤为重要了，因此我们要尽可能保证我们的计算简单和散列地址分布均匀。</p><p>解决办法：</p><ul><li>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</li><li>再散列函数法</li><li>链表法</li></ul><h2 id="1-7和1-8中HashMap的变化"><a href="#1-7和1-8中HashMap的变化" class="headerlink" title="1.7和1.8中HashMap的变化"></a>1.7和1.8中HashMap的变化</h2><h3 id="头插法和尾插法以及为什么会导致死环？"><a href="#头插法和尾插法以及为什么会导致死环？" class="headerlink" title="头插法和尾插法以及为什么会导致死环？"></a>头插法和尾插法以及为什么会导致死环？</h3><ul><li>JDK1.7用的是头插法，JDK1.8用的是尾插法，为什么要这样做？<br>头插法就是说新来的值会取代原有的值，原有的值就顺推到链表中去。改为尾插法的目的主要就是为了防止多线程扩容后出现死环的情况。</li></ul><p>我们先来看一下JDK1.7扩容的核心代码：</p><pre><code class="hljs java"><span class="hljs-comment">//将老的表中的数据拷贝到新的结构中  </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;          <span class="hljs-keyword">int</span> newCapacity = newTable.length;<span class="hljs-comment">//容量  </span>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="hljs-comment">//遍历所有桶</span>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123;  <span class="hljs-comment">//遍历桶中所有元素（是一个链表）</span>                Entry&lt;K,V&gt; next = e.next;                  <span class="hljs-keyword">if</span> (rehash) &#123;<span class="hljs-comment">//如果是重新Hash，则需要重新计算hash值  </span>                    e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);                  &#125;                  <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="hljs-comment">//定位Hash桶  </span>                e.next = newTable[i];<span class="hljs-comment">//元素连接到桶中,这里相当于单链表的插入，总是插入在最前面</span>                newTable[i] = e;<span class="hljs-comment">//newTable[i]的值总是最新插入的值</span>                e = next;<span class="hljs-comment">//继续下一个元素  </span>            &#125;          &#125;      &#125;</code></pre><p>HashMap扩容导致死循环的主要原因在于扩容后链表中的节点在新的hash桶使用头插法插入。</p><p>新的hash桶会倒置原hash桶中的单链表，那么在多个线程同时扩容的情况下就可能导致产生一个存在闭环的单链表，从而导致死循环。</p><p>JDK1.8由于使用的是尾插法，不会导致单链表的倒置，所以扩容的时候不会导致死循环。</p><h3 id="为什么扩容后数据存储位置的计算方式不同？"><a href="#为什么扩容后数据存储位置的计算方式不同？" class="headerlink" title="为什么扩容后数据存储位置的计算方式不同？"></a>为什么扩容后数据存储位置的计算方式不同？</h3><p>源码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 分析1：hash(key)</span><span class="hljs-comment">  * 作用：计算传入数据的哈希码（哈希值、Hash值）</span><span class="hljs-comment">  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样  扰动函数  使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span><span class="hljs-comment">  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span><span class="hljs-comment">  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span><span class="hljs-comment">  */</span>    <span class="hljs-comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;     h ^= k.hashCode();      h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);     <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);  &#125;    <span class="hljs-comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span>   <span class="hljs-comment">// 1. 取hashCode值： h = key.hashCode() </span>   <span class="hljs-comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;         <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 计算存储位置的函数分析：indexFor(hash, table.length)</span><span class="hljs-comment">  * 注：该函数仅存在于JDK 1.7</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;         <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);        <span class="hljs-comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span> &#125;</code></pre><p>在JDK1.7的时候是直接用键的hashcode值与新数组的长度进行&amp;运算得到新数组的位置。</p><p>而在jdk1.8中虽然扩容之后的数组和1.7是一样的，但是在计算元素位置的方式上不太一样，jdk1.7需要与新的数组长度进行重新hash运算，这个方式是相对耗性能的，而在1.8中对这一步进行了优化。</p><p>在1.8中我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><h3 id="为什么HashMap的数组长度一定是2的次幂？"><a href="#为什么HashMap的数组长度一定是2的次幂？" class="headerlink" title="为什么HashMap的数组长度一定是2的次幂？"></a>为什么HashMap的数组长度一定是2的次幂？</h3><pre><code class="hljs java"><span class="hljs-comment">// Java8中计算数组索引下标的位置</span>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]</code></pre><p>因为hashMap 的数组长度都是2的n次幂 ，那么对于这个数再减去1，转换成二进制的话，就肯定是最高位为0，其他位全是1 的数。</p><p>以Java8为例当数组长度不为2的n次幂 的时候，hashCode 值与数组长度减一做与运算的时候，会出现重复的数据，</p><p>因为不为2的n次幂 的话，对应的二进制数肯定有一位为0 , 这样不管你的hashCode 值对应的该位，是0还是1 ,</p><p>最终得到的该位上的数肯定是0，这带来的问题就是HashMap上的数组元素分布不均匀，而数组上的某些位置，永远也用不到。</p><p>这将带来的问题就是你的HashMap 数组的利用率太低，并且链表可能因为上边的(n - 1) &amp; hash 运算结果碰撞率过高，导致链表太深。(当然jdk 1.8已经在链表数据超过8个以后转换成了红黑树的操作，但那样也很容易造成它们之间的转换时机的提前到来)，所以说HashMap的长度一定是2的次幂，否则会出现性能问题。</p><h3 id="扩容因子为什么是0-75？"><a href="#扩容因子为什么是0-75？" class="headerlink" title="扩容因子为什么是0.75？"></a>扩容因子为什么是0.75？</h3><p>假设hash函数是理想的，数据会通过hash函数均匀的映射到数组上。一个数据映射到每一个桶（bucket）的概率是相等的。那么在任意的数组容量下，put一个数据发生碰撞的概率=数组元素个数/数组容量。</p><p>设置为0.75是做好了时间和空间的权衡的，因为扩容因子越大，碰撞的概率也就越大，发生碰撞后的代价也更大，结果导致效率也大打折扣。所以设置为0.75空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p><h3 id="底层实现原理的区别"><a href="#底层实现原理的区别" class="headerlink" title="底层实现原理的区别"></a>底层实现原理的区别</h3><h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>HashMap map = new HashMap();<br>在实例化以后，底层创建一个长度是16的一维数组Entry[] table。<br>…put很多次后…</p><p>map.put(key1,value1);</p><p>首先，调用key1所在类的hashcode计算key1哈希值，此哈希值经过某种算法后，得到在Entry数组中的存放位置。</p><p>如果该位置上数据为空，此时key和value直接添加成功。<br>如果该位置上数据不为空，说明该位置上存在一个或多个数据(以链表存储)，那么接着就会比较我们的key和已存在的数据的哈希值：</p><pre><code>如果key的哈希值与已存在数据的哈希值不同，添加成功。如果key的哈希值与已存在数据的哈希值相同，继续使用equals方法比较：    如果equals返回false，此时key添加成功。    如果equals返回true，此时value1替换value2。</code></pre><p>扩容的方式是将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><ol><li>new HashMap刚开始时底层没有创建一个长度为16的数组</li><li>底层数组不是Entry[]，变为了Node[]</li><li>首次调用put（）方法时，底层创建长度为16的数组</li><li>jdk7底层结构：数组+链表，jdk8底层结构：数组+链表+红黑树<br>当数组的某一个索引位置上的以链表形式存在的个数&gt;8且当前数组的长度&gt;64，此时此索引位置上的所有数据改为使用红黑树存储。</li></ol><p>参考：<br><a href="https://blog.csdn.net/qq32933432/article/details/86668385" target="_blank" rel="noopener">https://blog.csdn.net/qq32933432/article/details/86668385</a><br><a href="https://blog.csdn.net/liyantianmin/article/details/79401854" target="_blank" rel="noopener">https://blog.csdn.net/liyantianmin/article/details/79401854</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a><br><a href="https://blog.csdn.net/Tane_1018/article/details/103392267" target="_blank" rel="noopener">https://blog.csdn.net/Tane_1018/article/details/103392267</a><br><a href="https://www.jianshu.com/p/ee0de4c99f87" target="_blank" rel="noopener">https://www.jianshu.com/p/ee0de4c99f87</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream知识用法总结</title>
    <link href="/cxlittlecute/8a5cc6c1.html"/>
    <url>/cxlittlecute/8a5cc6c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-8-Stream"><a href="#JAVA-8-Stream" class="headerlink" title="JAVA 8 Stream"></a>JAVA 8 Stream</h1><p>最近写项目经常用到Java8新API stream流，当我们的项目数据量比较大的时候，很少会使用外键约束，因为这样产生的笛卡尔集，数量巨大，会造成我们的系统性能低下。</p><p>我们为了能避免这样的情况发生，一般会去除外键，那么通过一个一个表查询出来的数据，如何才能更好的进行VO或者TO的封装了，使用StreamAPI就是一个不错的处理方式。</p><p>于是，通过本篇文章对此进行一个知识点和用法的总结，帮助你了解和学习它的使用。</p><h2 id="Stream是什么"><a href="#Stream是什么" class="headerlink" title="Stream是什么"></a>Stream是什么</h2><p>数据渠道，用于操作数据源所生产的元素序列。</p><p>集合讲的是数据，流讲的是计算。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它的主要作用就是，使用一种管道流的思想处理我们的集合对象，对集合对象进行如同SQL语句一样的查找、过滤、排序等操作。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>Stream自己不会存储数据。</li><li>Stream不会改变源对象。</li><li>数据源来源：集合、数组、IO channel、生成器函数等.</li><li>借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。</li><li>中间操作返回新流，它们总是惰性的（延时执行），除非流水线触发终止操作，否则中间操作不会执行任何处理。由于是在终止操作时一次性全部处理，也称为惰性求值。</li><li>内部迭代：迭代操作是stream API完成的。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一、创建Stream</p><p>从一个数据源，如集合、数组中获取流。</p><p>二、中间操作</p><p>一个操作的中间链，对数据源的数据进行操作。</p><p>三、终止操作</p><p>一个终止操作，执行中间操作链，并产生结果。</p><h2 id="创建Stream流"><a href="#创建Stream流" class="headerlink" title="创建Stream流"></a>创建Stream流</h2><ul><li><p>stream() − 创建顺序流。</p></li><li><p>parallelStream() − 创建并行流。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 集合流</span><span class="hljs-comment"> *  - Collection.stream() 穿行流</span><span class="hljs-comment"> *  - Collection.parallelStream() 并行流</span><span class="hljs-comment"> */</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream();<span class="hljs-comment">/*</span><span class="hljs-comment">* 数组流</span><span class="hljs-comment">*   Arrays.stream(array)</span><span class="hljs-comment">* */</span>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];Stream&lt;String&gt; stream2 = Arrays.stream(strings);<span class="hljs-comment">/*</span><span class="hljs-comment">* 3.Stream 静态方法</span><span class="hljs-comment">*   Stream.of(...)</span><span class="hljs-comment">* */</span>Stream&lt;Integer&gt; stream3 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">* 4.无限流（一直停不下来）</span><span class="hljs-comment">*  (1)迭代</span><span class="hljs-comment">*  (2)生成</span><span class="hljs-comment">* */</span><span class="hljs-comment">// 迭代</span>Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>);<span class="hljs-comment">// 生成(可无限制造对象)</span>Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());<span class="hljs-comment">/*</span><span class="hljs-comment">* 5.BufferedReader.lines()将每行内容转成流</span><span class="hljs-comment"> * */</span>BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"stream.txt"</span>));Stream&lt;String&gt; lineStream = reader.lines();<span class="hljs-comment">/*</span><span class="hljs-comment">*6.Pattern.splitAsStream() 将字符串分隔成流</span><span class="hljs-comment">* */</span>Pattern pattern = Pattern.compile(<span class="hljs-string">","</span>);Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="hljs-string">"a,b,c,d"</span>);</code></pre><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="筛选-切片"><a href="#筛选-切片" class="headerlink" title="筛选/切片"></a>筛选/切片</h3><ul><li>filter：接收 Lambda ，从流中排除某些元素</li><li>limit：截断流，使其元素不超过给定数量</li><li>skip(n)：跳过元素，返回一个舍弃了前n个元素的流；若流中元素不足n个，则返回一个空流；与 limit(n) 互补</li><li>distinct：筛选，通过流所生成的 hashCode() 与 equals() 取除重复元素</li></ul><pre><code class="hljs java">List&lt;Employee&gt; emps = Arrays.asList(        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">101</span>, <span class="hljs-string">"Z3"</span>, <span class="hljs-number">19</span>, <span class="hljs-number">9999.99</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">102</span>, <span class="hljs-string">"L4"</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7777.77</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">103</span>, <span class="hljs-string">"W5"</span>, <span class="hljs-number">35</span>, <span class="hljs-number">6666.66</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">104</span>, <span class="hljs-string">"Tom"</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1111.11</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">105</span>, <span class="hljs-string">"Jerry"</span>, <span class="hljs-number">60</span>, <span class="hljs-number">4444.44</span>));<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 中间操作：不执行任何操作</span>    <span class="hljs-comment">// 此API属于内部迭代</span>    <span class="hljs-comment">// 外部迭代是我们自己编写的for 和 foreach方法</span>    Stream&lt;Employee&gt; stream = emps.stream()            .filter((x) -&gt; x.getAge() &gt; <span class="hljs-number">35</span>)            .limit(<span class="hljs-number">3</span>) <span class="hljs-comment">// 注意：短路 达到满足不再内部迭代</span>            .distinct() <span class="hljs-comment">// 注意：重写hashcode和equals方法</span>            .skip(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 终止操作：一次性执行全部内容，惰性求值</span>    stream.forEach(System.out::println);&#125;</code></pre><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ul><li>map：接收 Lambda ，将元素转换为其他形式或提取信息；接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li><li>flatMap：接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 大小写转换，该函数会被应用到每个元素上，并将其映射成一个新的元素</span>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);    list.stream()            .map((str) -&gt; str.toUpperCase())            .forEach(System.out::println);    <span class="hljs-comment">// 提取集合对象中信息</span>    emps.stream()            .map(Employee::getAge)            .forEach(System.out::println);&#125;</code></pre><p>在使用flatmap之前我们先看这样一个案例，将集合中字符串中的所有字符提取出来。在我们不使用flatmap之前我们需要进行嵌套的两次foreach，因为我们的filterCharacter方法也是返回的stream流对象：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">filterCharacter</span><span class="hljs-params">(String str)</span> </span>&#123;    List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;        list.add(c);    &#125;    <span class="hljs-keyword">return</span> list.stream();&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"bc"</span>, <span class="hljs-string">"ca"</span>);    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream()            .map(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数上的效果&#123;&#123;a,b,c&#125;,&#123;b,c&#125;,&#123;c,a&#125;&#125;，最终在一个大流中</span>    streamStream.forEach((sm) -&gt; &#123;        sm.forEach(System.out::println);    &#125;);&#125;</code></pre><p>那么我们可以再看看flatMap的作用，接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流。重点：flatMap得到的是一个流！</p><pre><code class="hljs java">Stream&lt;Character&gt; characterStream = list.stream()        .flatMap(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数的效果，去掉大流整合成一个流&#123;a,b,c,b,c,c,a&#125;</span>characterStream.forEach(System.out::println);</code></pre><p>此处总结一下这里，等于说Map是把一个个的流放入一个新的流中，导致流的嵌套；而flatMap是将一个个流中的元素放入新的流中。（这样会好理解一些）</p><p>类比于：集合中的add(Object obj)  addAll(Collection coll)方法。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>sorted()：自然排序(Comparable)</li><li>sorted(Comparator c)：定制排序(Comparator)</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自然排序</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);    list.stream()            .sorted() <span class="hljs-comment">//comparaTo()</span>            .forEach(System.out::println);        <span class="hljs-comment">// 定制排序</span>    emps.stream()            .sorted((e1, e2) -&gt; &#123; <span class="hljs-comment">//compara()</span>                <span class="hljs-keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123;                    <span class="hljs-keyword">return</span> e1.getName().compareTo(e2.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> e1.getAge().compareTo(e2.getAge());                &#125;            &#125;)            .forEach(System.out::println);&#125;</code></pre><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"aa"</span>, <span class="hljs-number">10</span>);    Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"bb"</span>, <span class="hljs-number">20</span>);    List&lt;Student&gt; studentList = Arrays.asList(s1, s2);    studentList.stream()            .peek(o -&gt; o.setAge(<span class="hljs-number">100</span>))            .forEach(System.out::println);    <span class="hljs-comment">//结果：</span>    Student&#123;name=<span class="hljs-string">'aa'</span>, age=<span class="hljs-number">100</span>&#125;    Student&#123;name=<span class="hljs-string">'bb'</span>, age=<span class="hljs-number">100</span>&#125;&#125;</code></pre><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><ul><li>allMatch：检查是否匹配所有元素</li><li>anyMatch：检查是否至少匹配一个元素</li><li>noneMatch：检查是否没有匹配所有元素</li><li>findFirst：返回第一个元素</li><li>findAny：返回当前流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中最大值</li><li>min：返回流中最小值</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    List&lt;Status&gt; list = Arrays.asList(Status.FREE, Status.BUSY, Status.VOCATION);    <span class="hljs-keyword">boolean</span> flag1 = list.stream()            .allMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag1);    <span class="hljs-keyword">boolean</span> flag2 = list.stream()            .anyMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag2);    <span class="hljs-keyword">boolean</span> flag3 = list.stream()            .noneMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag3);    <span class="hljs-comment">// 避免空指针异常</span>    Optional&lt;Status&gt; op1 = list.stream()            .findFirst();    <span class="hljs-comment">// 如果Optional为空 找一个替代的对象</span>    Status s1 = op1.orElse(Status.BUSY);    System.out.println(s1);    Optional&lt;Status&gt; op2 = list.stream()            .findAny();    System.out.println(op2);    <span class="hljs-keyword">long</span> count = list.stream()            .count();    System.out.println(count);    <span class="hljs-comment">// 获取最大工资的员工信息</span>    Optional&lt;Employee&gt; max = emps.stream()            .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));    System.out.println(max.get());    <span class="hljs-comment">// 获取最小工资</span>    Optional&lt;Double&gt; min = emps.stream()            .map(Employee::getSalary)            .min(Double::compare);    System.out.println(min.get());&#125;</code></pre><h2 id="归约-收集"><a href="#归约-收集" class="headerlink" title="归约/收集"></a>归约/收集</h2><ul><li>归约：reduce(T identity, BinaryOperator) / reduce(BinaryOperator) 可以将流中的数据反复结合起来，得到一个值</li><li>收集：collect 将流转换成其他形式；接收一个 Collector 接口的实现，用于给流中元素做汇总的方法</li></ul><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 归约</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);    Integer sum = list.stream()            .reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x + y); <span class="hljs-comment">// identity起始值 binaryOperator二元运算 现将起始值作为x，从流中取出元素作为y</span>    System.out.println(sum);    System.out.println(<span class="hljs-string">"-----------------------------------------"</span>);        <span class="hljs-comment">// 获取当前所有员工工资总和</span>    Optional&lt;Double&gt; reduce = emps.stream()            .map(Employee::getSalary)            .reduce(Double::sum); <span class="hljs-comment">// 为什么这里返回Optional？因为这里没有设置起始值</span>&#125;</code></pre><p>map和reduce的连接通常称为map-reduce模式，现在大数据经常应用这种模式。</p><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><p>collect-将流转换为其他形式。接收一个Collection接口的实现，用于给stream中元素汇总的方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 把公司员工所有名字提取出来，放入集合中</span>        List&lt;String&gt; list = emps.stream()                .map(Employee::getName)                .collect(Collectors.toList());<span class="hljs-comment">// Collectors实现类提供了很多静态方法，创建常见的收集器实例</span>        list.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        Set&lt;String&gt; set = emps.stream()                .map(Employee::getName)                .collect(Collectors.toSet());        set.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        HashSet&lt;String&gt; hs = emps.stream()                .map(Employee::getName)                .collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));        hs.forEach(System.out::println);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 收集总数</span>        Long collect = emps.stream()                .collect(Collectors.counting());        <span class="hljs-comment">// 平均值</span>        Double avg = emps.stream()                .collect(Collectors.averagingDouble(Employee::getSalary)); <span class="hljs-comment">// 指定了map</span>        System.out.println(avg);        <span class="hljs-comment">// 总和</span>        Double collect1 = emps.stream()                .collect(Collectors.summingDouble(Employee::getSalary));        System.out.println(collect1);        <span class="hljs-comment">// 最大值</span>        Optional&lt;Employee&gt; max = emps.stream()                .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));        System.out.println(max.get());        <span class="hljs-comment">// 最小值</span>        Optional&lt;Double&gt; min = emps.stream()                .map(Employee::getSalary)                .collect(Collectors.minBy(Double::compare));        System.out.println(min.get());        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 根据状态分组</span>        Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus));        System.out.println(map);        <span class="hljs-comment">// 多级分组</span>        Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; collect2 = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123;                    <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">35</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"青年"</span>;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">50</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"中年"</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"老年"</span>;                    &#125;                &#125;)));        <span class="hljs-comment">//分区</span>        Map&lt;Boolean, List&lt;Employee&gt;&gt; listMap = emps.stream()                .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; <span class="hljs-number">5000</span>)); <span class="hljs-comment">// 满足条件的一个区，不满足条件的在另一个区</span>        System.out.println(listMap);&#125;</code></pre><p>最后还有收集获取运算结果的其他方式和连接操作：</p><pre><code class="hljs java">DoubleSummaryStatistics dss = emps.stream()       .collect(Collectors.summarizingDouble(Employee::getSalary));   System.out.println(dss.getMax());   System.out.println(dss.getMin());   System.out.println(dss.getSum());   System.out.println(dss.getCount());   System.out.println(dss.getAverage());      <span class="hljs-comment">// 将参数连接起来</span>   String str = emps.stream()       .map(Employee::getName)       .collect(Collectors.joining(<span class="hljs-string">"-"</span>));  <span class="hljs-comment">// 可传入分隔符，首尾需要接着添加两个参数</span>   System.out.println(str);</code></pre><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><ul><li>并行流：就是把一个内容分成几个数据块，并用不同的线程分别处理每个数据块的流。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行操作；Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与串行流之间切换。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//串行流(单线程)：切换为并行流 parallel()</span>    <span class="hljs-comment">//并行流：切换为串行流 sequential()</span>    LongStream.rangeClosed(<span class="hljs-number">0</span>, <span class="hljs-number">100000000L</span>)            .parallel() <span class="hljs-comment">//底层：Fork Join</span>            .reduce(<span class="hljs-number">0</span>, Long::sum);&#125;</code></pre><p>fork join类似于归并排序，比较重要的思想就是工作窃取模式，它会将要执行的新任务，拆分为更小的任务执行，将小任务放入线程队列中，如果自己的线程空闲了，就会去别的线程偷取一个小任务放入自己的线程执行。这种方式减少了线程等待的时间，提高了性能。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075629.png" srcset="/img/loading.gif" alt=""></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>最后根据一个图更好的了解Stream 中间操作和结束操作的分类：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075903.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>无状态：指元素的处理不受之前元素的影响。</p></li><li><p>有状态：指该操作只有拿到所有元素之后才能继续下去。<br>（判断流操作是否有状态的判断标准，就是看是否需要知道先前的数据历史。前后数据是否有依赖关系来判断）</p></li><li><p>非短路操作：指必须处理所有元素才能得到最终结果。</p></li><li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p></li></ul><p>参考：<br><a href="https://blog.csdn.net/y_k_y/article/details/84633001" target="_blank" rel="noopener">https://blog.csdn.net/y_k_y/article/details/84633001</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GateWay网关访问服务出现503的问题解决</title>
    <link href="/cxlittlecute/674d8191.html"/>
    <url>/cxlittlecute/674d8191.html</url>
    
    <content type="html"><![CDATA[<h1 id="GateWay网关访问服务出现503的问题解决"><a href="#GateWay网关访问服务出现503的问题解决" class="headerlink" title="GateWay网关访问服务出现503的问题解决"></a>GateWay网关访问服务出现503的问题解决</h1><p>对于这个问题也是困扰了自己很久，今天下定决定要把它干掉。这个问题很坑，建议使用IDEA的朋友都可以看一看。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在分布式服务中，使用GateWay网关进行服务请求路由的统一管理，它是系统对外的唯一入口。为了让网关能正常发送调用其他服务，我使用到了Nacos服务注册中心。</p><p>正是这样出现了，我通过服务端口，能正常访问接口返回数据，通过网关访问有时可以有时不行的情况（也就是出现503的状态码反馈）。</p><p>HTTP状态码503指的是web服务器不能处理HTTP请求。原因大致如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716131929.png" srcset="/img/loading.gif" alt="avator"></p><p>那么根据上面这四个原因我还是没有分析出为什么会出现这个问题。于是我开始一步步排查问题。</p><ol><li><p>我首先认为是我GateWay网关，拦截配置的问题，可是我的情况是有时出现503，有时又能通过网关正常访问，所以暂时排除了这种情况。</p></li><li><p>是否本身的单体服务有问题，但是通过postman的测试，通过服务的端口访问接口，都能正常返回数据。所以也暂时排除这种情况。</p></li><li><p>Nacos注册中心的问题。</p></li></ol><p>那基本能确定是Nacos注册中心的问题了，但也不完全是Nacos的锅。</p><p>再次分析：</p><p>F12查看Network，请求的发送情况，发现OPTIONS预检请求是正常发送的，但发送真正的请求的时候出现了503的错误。如下图:</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133417.png" srcset="/img/loading.gif" alt="avator"></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133338.png" srcset="/img/loading.gif" alt="avator"></p><p>接着我点开了Preview（预览功能），看到了错误提示：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133611.png" srcset="/img/loading.gif" alt="avator"></p><p>我们可以通过错误提示很清晰的看到message的反馈，就是发现不了我的product服务。</p><p>和我们判断的没错是nacos的问题，于是我进入nacos查看服务是否注册成功。</p><p>这里就发现了一个很奇怪的现象，正常的我们刷新nacos的界面服务是不会掉的，但是我的product商品服务，一会有一会儿又没有，刚开始我发现了这个问题，但没有引起注意，也就导致这个问题之前一直没有得到解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是，我抱着再试一试的心态，将该服务的端口号从10000改为了8100，也就是改为了其他的数（或者修改一下服务名），这个服务就在nacos注册中心稳定了。（前提是确保你的服务Nacos配置没有问题）</p><p>这其实是一个很容易解决的bug，但是之前网上找过都没有得到好的解决。</p><p>让我想到了idea在使用过程中确实存在一些bug，常见的就是</p><ol><li><p>创建继承maven项目数量多了之后，项目结构就会不一样，需要手动修改，或者更换项目名才能解决。</p></li><li><p>使用springboot的过程中有些端口无法使用，这种无法使用是由于idea和系统的问题，你能正常跑通你的项目，但是这个项目你无法通过客户端访问，只要访问就是500服务器错误。</p></li></ol><hr><p>同时这里强调，不是因为什么端口被占用的问题，端口如果被占用，连服务都是无法启动的，所以这就是一些简单又很坑人的地方。</p><p>如果您有幸看到了这篇文章，希望对您有帮助，解决到您的问题。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
      <category>GateWay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>GateWay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</title>
    <link href="/cxlittlecute/4e6c6273.html"/>
    <url>/cxlittlecute/4e6c6273.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题"><a href="#Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题" class="headerlink" title="Springboot出现Possibly consider using a shorter maxLifetime value警告问题"></a>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>这是我经常遇到的一个问题，当我们使用Springboot连接数据库的时候（Springboot默认使用的是HikariCP），如果长时间的静默没有请求连接池，那么就会出现如下warn：</p><pre><code class="hljs routeros">[http-nio-7003-exec-10] WARN  com.zaxxer.hikari.pool.PoolBase - HikariPool-1 - Failed <span class="hljs-keyword">to</span> validate<span class="hljs-built_in"> connection </span>com.mysql.cj.jdbc.ConnectionImpl@3987b59f (<span class="hljs-literal">No</span> operations allowed after<span class="hljs-built_in"> connection </span>closed.). Possibly consider using a shorter maxLifetime value.</code></pre><p>我们可以看到这个warn的最后一句话， Possibly consider using a shorter maxLifetime value（让我们考虑使用一个更小的maxLifetime值）。</p><p>看到这里大家肯定会疑惑maxLifeTime是什么？</p><p>我们先来看看官方文档对参数的说明：<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716085042.png" srcset="/img/loading.gif" alt="avator"></p><p>此属性控制池中连接的最长生存期。一个正在使用的连接永远不会失效，只有当它关闭时，它才会被移除。在逐个连接的基础上，应用较小的负衰减以避免池中的大规模灭绝。我们强烈建议设置此值，并且它应该比任何数据库或基础设施施加的连接时间限制短几秒。值为0表示没有最长生存期（无限生存期），当然取决于idleTimeout设置。默认值：1800000（30分钟）。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>其实这个问题很好解决，就是在配置文件中添加HikariCP的参数设置，也就是将maxLifeTime的值变小。</p><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.hikari</span><span class="hljs-selector-class">.max-lifetime</span> =<span class="hljs-number">120000</span></code></pre><p>同时这里需要注意的是，如果这样设置后出现另外的报错：</p><pre><code class="hljs applescript">idleTimeout <span class="hljs-keyword">is</span> close <span class="hljs-keyword">to</span> <span class="hljs-keyword">or</span> more than maxLifetime, disabling <span class="hljs-keyword">it</span>.</code></pre><p>说明你设置的maxLifeTime的值低于了idleTimeout。</p><p>ideaTimeOut是连接允许在池中闲置的最长时间，它有个规则：如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒。</p><p>所以最好是将maxLifeTime和idleTimeOut的值一起按照要求修改。</p><p>文档里面的参数都可以在配置文件中修改默认值，可以根据自己的需要来。</p><p>当然说到这里其实自己也是有疑问的，为什么降低了maxLifeTime就可以避免发生这个问题？现在只是找到方法解决掉了这个问题，但是原理不是很明白，查阅到了相关资料我会进行补充。有想法的朋友可以评论或私信我，互相交流。</p><hr><p>以上的理解如果有偏差，可以通过关于页的联系方式第一时间联系我，我将做好修改更正工作。期待您的回复和反馈。</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>HikariCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>HikariCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云oss上传报错Invalid according to Policy Policy expired</title>
    <link href="/cxlittlecute/1d5383b1.html"/>
    <url>/cxlittlecute/1d5383b1.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"><a href="#阿里云oss上传报错Invalid-according-to-Policy-Policy-expired" class="headerlink" title="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"></a>阿里云oss上传报错Invalid-according-to-Policy-Policy-expired</h1><p>阿里云oss上传使用的是服务端签名后直传；通过服务端生成上传签名，前端使用服务端生成的签名上传文件。</p><p>同时，在这里先说一下为什么要使用服务端签名后直传。</p><p>之前使用OSS时，是让文件过自己的服务器，然后通过自己的服务器传到OSS的服务器，也就是这样：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175217.png" srcset="/img/loading.gif" alt="avator"></p><p>通过上面的这种直传的方式，导致我们的服务端压力很大。虽然我们可以使用JS直接前端传递，但是这样会暴露我们的AccessKeyID和AcessKeySecret，会有安全隐患。</p><p>所以选择了，接下来的这种服务端签名的方式上传：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175427.png" srcset="/img/loading.gif" alt="avator"></p><p>正是使用了这种方式出现了以下这个问题：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174130.png" srcset="/img/loading.gif" alt="avator"></p><p>查询阿里云文档可知错误原因：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174653.png" srcset="/img/loading.gif" alt="avator"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p> 生成签名时，官方代码中的参数expireTime默认是30秒，改为更大的时间。</p><h3 id="代码演示-解决办法"><a href="#代码演示-解决办法" class="headerlink" title="代码演示 解决办法"></a>代码演示 解决办法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Osscontroller</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.endpoint&#125;"</span>)    <span class="hljs-keyword">private</span> String endpoint;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.bucket&#125;"</span>)    <span class="hljs-keyword">private</span> String bucket;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.access-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessId;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.secret-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessKey;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/oss/policy"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">policy</span><span class="hljs-params">()</span> </span>&#123;        String host = <span class="hljs-string">"https://"</span> + bucket + <span class="hljs-string">"."</span> + endpoint; <span class="hljs-comment">// host的格式为 bucketname.endpoint</span>        <span class="hljs-comment">// callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。</span>        <span class="hljs-comment">//String callbackUrl = "http://88.88.88.88:8888";</span>        String format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(<span class="hljs-keyword">new</span> Date());        String dir = format+<span class="hljs-string">"/"</span>; <span class="hljs-comment">// 用户上传文件时指定的前缀。</span>        <span class="hljs-comment">// 创建OSSClient实例。</span>        OSS ossClient = <span class="hljs-keyword">new</span> OSSClientBuilder().build(endpoint, accessId, accessKey);        Map&lt;String, String&gt; respMap = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">long</span> expireTime = <span class="hljs-number">60</span>; <span class="hljs-comment">//增大这里的时间</span>            <span class="hljs-keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="hljs-number">1000</span>;            Date expiration = <span class="hljs-keyword">new</span> Date(expireEndTime);            <span class="hljs-comment">// PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span>            PolicyConditions policyConds = <span class="hljs-keyword">new</span> PolicyConditions();            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="hljs-number">0</span>, <span class="hljs-number">1048576000</span>);            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);            <span class="hljs-keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="hljs-string">"utf-8"</span>);            String encodedPolicy = BinaryUtil.toBase64String(binaryData);            String postSignature = ossClient.calculatePostSignature(postPolicy);            respMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();            respMap.put(<span class="hljs-string">"accessid"</span>, accessId);            respMap.put(<span class="hljs-string">"policy"</span>, encodedPolicy);            respMap.put(<span class="hljs-string">"signature"</span>, postSignature);            respMap.put(<span class="hljs-string">"dir"</span>, dir);            respMap.put(<span class="hljs-string">"host"</span>, host);            respMap.put(<span class="hljs-string">"expire"</span>, String.valueOf(expireEndTime / <span class="hljs-number">1000</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// Assert.fail(e.getMessage());</span>            System.out.println(e.getMessage());        &#125; <span class="hljs-keyword">finally</span> &#123;            ossClient.shutdown();        &#125;        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"data"</span>,respMap);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo消除中文路径</title>
    <link href="/cxlittlecute/8ce042f1.html"/>
    <url>/cxlittlecute/8ce042f1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo消除中文路径"><a href="#Hexo消除中文路径" class="headerlink" title="Hexo消除中文路径"></a>Hexo消除中文路径</h1><p>我们博客中的文章标题，一般都会有中文出现，同时Hexo默认也是会把你的title放在路径访问的最后，也就是xxx.html。</p><p>由于路径中有中文的存在，如果你想根据URL进行操作的时候就会被浏览器编码，也就是URL code字符编码。</p><pre><code class="hljs llvm">https://ccctop.cn/<span class="hljs-number">2020</span>/<span class="hljs-number">07</span>/<span class="hljs-number">13</span>/Jenkins<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%89</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A1</span><span class="hljs-symbol">%8</span>Cshell<span class="hljs-symbol">%E5</span><span class="hljs-symbol">%91</span><span class="hljs-symbol">%BD</span><span class="hljs-symbol">%E4</span><span class="hljs-symbol">%BB</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%EF</span><span class="hljs-symbol">%BC</span><span class="hljs-symbol">%8</span>C<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%8</span>F<span class="hljs-symbol">%90</span><span class="hljs-symbol">%E7</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%BAcommand-not-found</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%A3</span><span class="hljs-symbol">%E5</span><span class="hljs-symbol">%86</span><span class="hljs-symbol">%B3</span>/</code></pre><h2 id="这种中文URL的不缺点："><a href="#这种中文URL的不缺点：" class="headerlink" title="这种中文URL的不缺点："></a>这种中文URL的不缺点：</h2><ol><li><p>关键词被编译后，URL会变得很长，这是搜索引擎不建议的，但并非不能使用;也就是不利于SEO。</p></li><li><p>使用被引用，中文URL在转码后会变成形如：%E5%A9%9A%E7%BA%B1 的结构，一些编辑器支持的问题会造成错误链接地址或错误的URL识别、分割 ，甚至有些网站会产生状态为404的引用指向。</p></li></ol><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>一种是把中文路径变为拼音，另一种就是进行转换编码。在 Hexo 根目录下的 _config.yml 文件中，修改或新增配置项：</p><p>拼音：</p><pre><code class="hljs ada">npm i hexo-permalink-pinyin <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-symbol">permalink_pinyin:</span><span class="hljs-symbol">  enable:</span> true<span class="hljs-symbol">  separator:</span> <span class="hljs-string">'-'</span> <span class="hljs-meta"># default: <span class="hljs-string">'-'</span></span></code></pre><p>编码：</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-meta"># permalink: :title/</span><span class="hljs-symbol">permalink:</span> archives/:abbrlink.html<span class="hljs-symbol">abbrlink:</span><span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta"># 算法：crc16(default) and crc32</span><span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta"># 进制：dec(default) and hex</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins执行shell命令，提示command not found解决</title>
    <link href="/cxlittlecute/61702.html"/>
    <url>/cxlittlecute/61702.html</url>
    
    <content type="html"><![CDATA[<h1 id="Command-not-found"><a href="#Command-not-found" class="headerlink" title="Command not found"></a>Command not found</h1><p>jenkins执行shell命令，有时会提示“Command not found”—-处理方案。</p><p>1.首先，分析是linux环境的问题还是Jenkins的问题。</p><p>如果登录linux，shell命令不可以执行，同样提示“Command not found”，则是环境变量设置失败，需要配置环境变量、/etc/profile。</p><p>如果登录linux，shell命令可以执行，则是jenkins没有加载/etc/profile导致。</p><p>我就是第二种情况。那就是得让jenkins执行我们实际的shell命令之前，执行识别环境变量的shell命令。让Jenkins先读取/etc/profile等的内容。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">source</span> ~/.bash_profile<span class="hljs-built_in">source</span> /etc/profile<span class="hljs-built_in">cd</span>..等其他shell命令</code></pre>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云全站加速HTTPS证书无法开启问题解决</title>
    <link href="/cxlittlecute/10754.html"/>
    <url>/cxlittlecute/10754.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云全站加速HTTPS证书无法开启问题解决"><a href="#阿里云全站加速HTTPS证书无法开启问题解决" class="headerlink" title="阿里云全站加速HTTPS证书无法开启问题解决"></a>阿里云全站加速HTTPS证书无法开启问题解决</h1><p>全站加速（Dynamic Route for Content Delivery Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p><p>1.选择添加域名</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160216.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.添加域名 类型IP（IP就是你服务器IP）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160556.png" srcset="/img/loading.gif" alt="avatar"></p><p>3.HTTPS设置</p><p>我就是在这个地方出现问题的。</p><p>之前没有领取HTTPS证书，所以在这里想一起申请了，也就是选择</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162446.png" srcset="/img/loading.gif" alt="avatar"></p><p>免费证书，点击确定后，弹窗显示了设置成功，但是HTTPS的设置一直都是未开启的状态。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162917.png" srcset="/img/loading.gif" alt="avatar"></p><p>由于不知道问题出现在什么地方，所以找了一下客服。客服的回复如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162759.png" srcset="/img/loading.gif" alt="avatar"></p><p>之后发现出现这个问题的原因是，我自己添加的域名为泛域名，也就是域名前我带了*，这样可能会导致无法颁发证书。</p><p>随后我将*去掉，配置为www或者直接解析域名@,再次去申请证书就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云域名配置</title>
    <link href="/cxlittlecute/202.html"/>
    <url>/cxlittlecute/202.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云域名配置"><a href="#阿里云域名配置" class="headerlink" title="阿里云域名配置"></a>阿里云域名配置</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>登录阿里云，选择域名服务，选择你要购买的域名类型进行购买。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152655.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p><a href="https://beian.aliyun.com/" target="_blank" rel="noopener">https://beian.aliyun.com/</a></p><p>必要进行域名备案才能真正使用上你的域名，备案需要填写你购买域名的用途和你个人信息等，然后进行申请，审批时长大概二十天左右。</p><p>期间保持电话畅通，因为阿里云的客服小姐姐小哥哥可能会给你打电话，如果你有什么信息需要修改的可以第一时间得到反馈。然后就是耐心的等待。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152836.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>当你把以上的步骤完成后，就可以进入域名的管理控制台。<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153119.png" srcset="/img/loading.gif" alt="avatar"></p><p>点击解析 配置你的解析设置：<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153540.png" srcset="/img/loading.gif" alt="avatar"></p><p>这样只需要对应你的IP进行配置就可以实现使用你自己的域名解析到IP上了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建与部署</title>
    <link href="/cxlittlecute/19858.html"/>
    <url>/cxlittlecute/19858.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客搭建与部署"><a href="#Hexo博客搭建与部署" class="headerlink" title="Hexo博客搭建与部署"></a>Hexo博客搭建与部署</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。</p><p>文档地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="如何搭建（参照Hexo文档）"><a href="#如何搭建（参照Hexo文档）" class="headerlink" title="如何搭建（参照Hexo文档）"></a>如何搭建（参照Hexo文档）</h2><p>安装前提：node.js和Git</p><p>node: <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>Git: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre><pre><code class="hljs cmd">$ hexo init &lt;folder&gt;$ <span class="hljs-built_in">cd</span> &lt;folder&gt;$ npm install</code></pre><p>Hexo的安装过程比较简单，主要参照文档就行了。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>hexo项目结构安装好后，就可以选择一个合适的主题，官网有主题的选项，同时也可以去百度上看一下别人选择的主题做出来的效果，有看到喜欢的就用相同的主题。</p><p>我用的主题为：Fluid&emsp;&emsp;  <a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">https://hexo.fluid-dev.com/docs/</a></p><p>这个主题支持的插件基本还可以，界面还是简介大方。</p><p>那么我们只需要下载好相应的主题，按照Hexo官方文档（注意不是主题文档）修改_config.yml这个文件中的内容就可以了。</p><p>很多细小的配置在Fluid主题文档中都有，基本可以把文档看一遍，修改好你想要的设置。</p><h2 id="主题设置细节说明"><a href="#主题设置细节说明" class="headerlink" title="主题设置细节说明"></a>主题设置细节说明</h2><p>我的博客中使用了评论和统计插件。</p><p>评论-Valine <a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></p><p>统计-leancloud <a href="https://www.leancloud.cn/" target="_blank" rel="noopener">https://www.leancloud.cn/</a></p><p>评论和计数的后台都可以通过lencloud的后台系统管理，而且比较稳定。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>重点说一下部署，因为Hexo部署上去的其实就是Public下面的html静态文件，所以可以把public下的文件放置在任何地方。</p><p>文档推荐的是放github下，但是你会发现如果你不翻墙的话，图片很难加载出来，gitee也可以，但是如果你想配置自定义域名的话，就必须要购买gitee自定义域名的产品。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>我使用的是PicGo+Gitee(码云)搭建自己的图床。</p><p>1.将PicGO下载下来，然后安装插件</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713133658.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.配置Gitee<br>点击自己gitee头像-&gt;设置，左边有一个私人令牌，点击右上角生成新令牌，只选择projects,如下图：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150257.png" srcset="/img/loading.gif" alt="avatar"></p><p>注意：私人令牌token只会显示一次，如果没有复制成功只能删除后重新获取。</p><p>3.设置插件githubPlus</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150827.png" srcset="/img/loading.gif" alt="avatar"></p><p>测试：记得修改PicGO中上传区中的图片上传改为:图片上床-githubLPlus这样就可以根据路径来访问你的图片了。</p><pre><code class="hljs stata">最后，感谢Yazzz带我入坑，友链里有<span class="hljs-keyword">ta</span>哦~</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
