<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图的DFS和BFS</title>
    <link href="/cxlittlecute/e494e2f9.html"/>
    <url>/cxlittlecute/e494e2f9.html</url>
    
    <content type="html"><![CDATA[<h1 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS BFS"></a>DFS BFS</h1><p>上一篇博客记录了自己初次学习图遍历的代码实现方法，有朋友评论讲的过于细致化，今天刚好重新参考看了一篇博客的实现，相比来说确实要简单明了很多，于是再次记录关于DFS和BFS的相关内容。</p><p>上一篇博客：<a href="http://ccctop.cn/cxlittlecute/f1a8c9e2.html" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/f1a8c9e2.html</a></p><p>如果上一篇博客没有太明白的朋友，可以参考看一看这一篇。</p><p>上一篇博客我们说了图的实现方式主要是邻接矩阵和邻接表，那么今天我们就用邻接表再次分析图的DFS和BFS过程。</p><h2 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h2><ul><li>使用一个大小为V的数组 List<Integer>[] head（通图adj[]），把索引看做是顶点</li><li>每个索引处head[v]存储了一个数组或队列，该队列中存储的是所有与该顶点相邻的其他顶点</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> Graph2</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 14:12</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph2</span> </span>&#123;    <span class="hljs-comment">// 记录顶点的个数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> V;    <span class="hljs-comment">// 保存头结点</span>    List&lt;Integer&gt;[] head;    <span class="hljs-comment">// 记录边的数量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;    Graph2(<span class="hljs-keyword">int</span> V) &#123;        <span class="hljs-keyword">this</span>.V = V;        <span class="hljs-keyword">this</span>.E = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> ArrayList[V];        <span class="hljs-comment">// 初始化邻接表中的队列</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; V ;i++)&#123;            head[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        &#125;    &#125;    <span class="hljs-comment">// 获取图中顶点的数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">V</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> V;    &#125;    <span class="hljs-comment">// 获取图中边的数量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">E</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> E;    &#125;    <span class="hljs-comment">// 向图中添加一条边</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;        head[v].add(w);        head[w].add(v);        E++;    &#125;    <span class="hljs-comment">//获取和顶点v相邻的所有顶点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">adj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span></span>&#123;        <span class="hljs-keyword">return</span> head[v];    &#125;&#125;</code></pre><h2 id="DFS的实现"><a href="#DFS的实现" class="headerlink" title="DFS的实现"></a>DFS的实现</h2><p>所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点</p><p>我们可以根据上图清楚的知道DFS的一个执行顺序。<br>主要有两点需要注意：</p><ol><li>如果已经访问过的会直接跳过。</li><li>由于是DFS是深度优先，所以我们每次遍历都会以邻接结点为下一次遍历的头。（特点）</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearch</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 17:42</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepthFirstSearch</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    DepthFirstSearch(Graph2 G,<span class="hljs-keyword">int</span> s)&#123;        <span class="hljs-keyword">this</span>.marked  = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        dfs(G,s);    &#125;    <span class="hljs-comment">// 使用深度优先搜索找出G图中v顶点的所有相通顶点</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Graph2 G, <span class="hljs-keyword">int</span> v)</span></span>&#123;        System.out.print(v+<span class="hljs-string">"-&gt;"</span>);        <span class="hljs-comment">// 把v顶点标识为以搜索</span>        marked[v] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (Integer w : G.adj(v)) &#123;            <span class="hljs-comment">// 判断有没有被搜索过，如果没有被搜索过则递归调用dfs进行深度搜索</span>            <span class="hljs-keyword">if</span> (!marked[w])&#123;                dfs(G, w);            &#125;        &#125;        count++;    &#125;    <span class="hljs-comment">// 判断w顶点与s顶点是否相通</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">marked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w)</span></span>&#123;        <span class="hljs-keyword">return</span> marked[w];    &#125;    <span class="hljs-comment">// 获取与顶点s相通的所有顶点的总数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;    &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>照着下面的图片进行建图然后测试：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200725202932.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> DepthFirstSearchTest</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Auther</span> OY</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/7/25 18:32</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepthFirstSearchTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 准备图</span>        Graph2 graph2 = <span class="hljs-keyword">new</span> Graph2(<span class="hljs-number">13</span>);        <span class="hljs-comment">// 准备结点</span>        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);        graph2.addEdge(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);        graph2.addEdge(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);        graph2.addEdge(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>);        graph2.addEdge(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">10</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        graph2.addEdge(<span class="hljs-number">9</span>,<span class="hljs-number">12</span>);        <span class="hljs-comment">// 准备要DFS搜索的对象</span>        DepthFirstSearch depthFirstSearch = <span class="hljs-keyword">new</span> DepthFirstSearch(graph2, <span class="hljs-number">0</span>);        <span class="hljs-comment">// 测试与某个顶点相同的顶点数量</span>        <span class="hljs-keyword">int</span> count = depthFirstSearch.count();        System.out.println(count);        <span class="hljs-comment">// 测试某个顶点是否与起点想通</span>        <span class="hljs-keyword">boolean</span> marked = depthFirstSearch.marked(<span class="hljs-number">5</span>);        System.out.println(marked);    &#125;&#125;</code></pre><p>这样的方式实现就会更加明了简单，如果还没有明白的朋友可以debug一下跑一跑。</p><h2 id="BFS实现"><a href="#BFS实现" class="headerlink" title="BFS实现"></a>BFS实现</h2><p>而BFS刚好相反，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的遍历</title>
    <link href="/cxlittlecute/f1a8c9e2.html"/>
    <url>/cxlittlecute/f1a8c9e2.html</url>
    
    <content type="html"><![CDATA[<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>所谓的图的遍历就是对图中结点的访问，一个图有很多的结点，我们如何去遍历它们了？</p><p>那么需要我们制定相应的访问策略：</p><ul><li>方式一：深度优先遍历（DFS）</li><li>方式二：广度优先遍历（BFS)</li></ul><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><h3 id="DFS思想"><a href="#DFS思想" class="headerlink" title="DFS思想"></a>DFS思想</h3><ul><li>深度优先遍历，从你定的初始访问结点出发，那么我们初始访问结点可能有很多邻接结点，深度优先遍历的策略就是：首先访问第一个邻接结点，然后再以这个被访问的临界点作为初始结点，访问它的第一个邻接结点。（总之，就是每次访问完当前结点后首先访问当前结点的第一个邻接结点）</li></ul><p>举例：如果说v1-&gt;v2-&gt;v3同时v1-&gt;v3,那么通过DFS仍然是通过v2才访问到v3的。</p><ul><li>我们可以通过上面的例子看到，这种访问策略是优先向纵向挖掘深度，而不是对一个结点的所有邻接结点进行横向访问。</li><li>DFS是一个递归过程。</li></ul><h3 id="DFS算法步骤"><a href="#DFS算法步骤" class="headerlink" title="DFS算法步骤"></a>DFS算法步骤</h3><ol><li>访问初始结点v,并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当成一个另一个v，进行123操作）</li><li>若w已经被访问了，查找结点v的邻接结点w的下一个邻接结点，进入步骤3</li></ol><h3 id="DFS举例分析"><a href="#DFS举例分析" class="headerlink" title="DFS举例分析"></a>DFS举例分析</h3><p>那么我们举例来分析一下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724144623.png" srcset="/img/loading.gif" alt=""></p><p>我们在集合中存放结点的顺序是ABCDE。<br>那么我们通过DFS遍历的步骤是：</p><ol><li>A的邻接结点为B，B存在同时未被访问，这样就遍历到了B</li><li>接着对B进行DFS递归，把B当成初始结点同上访问到了C</li><li>这个时候我们已经把C当做了初始结点了，C的下一个邻接结点应该是D，但是它们并不是连通的</li><li>于是D就不能马上输出，则执行DFS算法步骤的第3步，从v的下一个结点继续，也就是从B继续</li><li>这个时候发现C已经被访问了，则会查找B的邻接结点C的下一个邻接结点也就是D，这样就能完成我们的DFS遍历。</li></ol><h3 id="DFS代码实现"><a href="#DFS代码实现" class="headerlink" title="DFS代码实现"></a>DFS代码实现</h3><ol><li>定义给数组boolean[],记录某个结点是否被访问过:<pre><code class="hljs java"><span class="hljs-comment">//定义给数组boolean[],记录某个结点是否被访问过</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isVisited;</code></pre></li><li>得到第一个邻接结点的下标w<pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 得到第一个邻接结点的下标w</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 当前结点的下标</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 如果存在就返回对应下标，否则返回-1</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFirstNeighbor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; vertexList.size(); j++) &#123;        <span class="hljs-keyword">if</span> (edges[index][j] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 根据矩阵中的值大于0说明当前结点的下一个邻接结点是存在的</span>            <span class="hljs-keyword">return</span> j;        &#125;    &#125;    <span class="hljs-comment">//如果存在就返回对应的下0标否则返回-1</span>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></li><li>根据前一个邻接结点的下标来获取下一个邻接结点 等同于第五步<pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据前一个邻接结点的下标来获取下一个邻接结点 等同于第五步</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v1 结点v</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> v2 结点v的邻接结点w</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNeighhor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = v2 + <span class="hljs-number">1</span>; j &lt; vertexList.size(); j++) &#123;        <span class="hljs-keyword">if</span> (edges[v1][j] &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> j;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></li><li>深度优先遍历算法实现(部分方法衔接 博客：图-<a href="http://ccctop.cn/cxlittlecute/ee040603.html" target="_blank" rel="noopener">http://ccctop.cn/cxlittlecute/ee040603.html</a>)</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *深度优先遍历算法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isVisited</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i 第一次就是0,等于说进入步骤第一步</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-comment">//首先我们访问该结点，输出</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">"-&gt;"</span>); <span class="hljs-comment">//返回结点i（下标）对应的数据0-&gt;"A"  1-&gt;"B"  2-&gt;"c"</span>    <span class="hljs-comment">//将已经访问的结点设置为已经访问过</span>    isVisited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//查找结点i的第一个邻接结点w  等于步骤第二步</span>    <span class="hljs-keyword">int</span> w = getFirstNeighbor(i);    <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//说明有邻接结点 使用while循环的原因是如果存在就会继续往下递归</span>        <span class="hljs-keyword">if</span> (!isVisited[w]) &#123; <span class="hljs-comment">// 说明没有被访问</span>            dfs(isVisited, w);        &#125;        <span class="hljs-comment">//如果w这个结点已经被访问过,我们就应该访问邻接结点的下一个结点</span>        w = getNextNeighhor(i, w);    &#125;&#125;</code></pre><p>但是写到这里并没有结束，因为我们第3步中-回到第1步，将从v的下一个结点继续，这一步骤还未完成,不然会出现中间有一个结点走不下去程序就结束了。</p><pre><code class="hljs java"><span class="hljs-comment">// 对dfs进行重载</span><span class="hljs-comment">// 因为我们第3步中-回到第1步，将从v的下一个结点继续，这一步骤还未完成,不然会出现中间有一个结点走不下去程序就结束了</span><span class="hljs-comment">// 遍历我们所有的结点，并进行dfs</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 遍历所有的结点，进行dfs【回溯】</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            dfs(isVisited, i);        &#125;    &#125;&#125;</code></pre><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><h3 id="BFS思想"><a href="#BFS思想" class="headerlink" title="BFS思想"></a>BFS思想</h3><p>BFS需要使用一个队列，用来保存访问过的结点的顺序，类似于一个分层搜索的过程，我们使用这个顺序来访问这些结点的邻接结点。</p><h3 id="BFS算法步骤"><a href="#BFS算法步骤" class="headerlink" title="BFS算法步骤"></a>BFS算法步骤</h3><ol><li>访问初始结点v并标记结点v为已访问</li><li>将结点v加入队列</li><li>当队列非空时，继续执行，否则算法结束（这里的算法结束指的是对v这个结点的算法结束）。</li><li>出队列，取得头结点u。</li><li>查找结点u的第一个邻接结点w。</li><li>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行下面三个步骤：<br> 6.1 若结点w未被访问，则访问w并标记为已访问。<br> 6.2 结点w入队列。(w的访问顺序同样也被记录在队列中)<br> 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</li></ol><h3 id="BFS举例分析"><a href="#BFS举例分析" class="headerlink" title="BFS举例分析"></a>BFS举例分析</h3><p>我们同样来举例分析一下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724180549.png" srcset="/img/loading.gif" alt=""></p><ol><li>我们还是从A开始，先访问自己，A就输出了</li><li>接着看A的下一个邻接结点B，判断B能访问于是B也就被输出了</li><li>接着就和DFS不一样的地方出现了，我们DFS中时根据B作为新的初始结点去访问C，而我们的BFS中仍是以A为初始结点，去找B结点的邻接结点也就是C，发现C同样也能访问，于是就访问到了C。</li><li>然后再去通过c找它的后继结点，发现找不到了。</li><li>这个时候我们的B已经在队列中，A访问过后已经被弹出了队列，然后就从队列中弹出B（它现在位于队列头）。</li><li>然后根据B去找，发现访问过的就跳过，跳过AC后发现能访问到D，然后又能访问到E。</li><li>最后把剩下的CDE都作为队列头走一圈，发现都访问过了，就退出了。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs java"><span class="hljs-comment">//对一个节点进行广度优先遍历的方法</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[] isVisited, <span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//表示队列头结点对应下标</span>    <span class="hljs-keyword">int</span> w;<span class="hljs-comment">//邻接结点w</span>    <span class="hljs-comment">//队列,记录结点访问的顺序</span>    LinkedList queue = <span class="hljs-keyword">new</span> LinkedList();    <span class="hljs-comment">//访问结点,输出结点信息</span>    System.out.print(getValueByIndex(i) + <span class="hljs-string">"-&gt;"</span>);    <span class="hljs-comment">//标记为已访问</span>    isVisited[i] = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">//将结点加入队列</span>    queue.addLast(i);    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;        <span class="hljs-comment">//取出队列的头结点下标</span>        u = (Integer) queue.removeFirst();        <span class="hljs-comment">//得到第一个邻接点的下标 w</span>        w = getFirstNeighbor(u);        <span class="hljs-keyword">while</span> (w != -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//找到</span>            <span class="hljs-comment">//是否访问过</span>            <span class="hljs-keyword">if</span> (!isVisited[w]) &#123;                System.out.println(getValueByIndex(w) + <span class="hljs-string">"=&gt;"</span>);                <span class="hljs-comment">//标记已经访问</span>                isVisited[w] = <span class="hljs-keyword">true</span>;                <span class="hljs-comment">//入队列</span>                queue.addLast(w);            &#125;            <span class="hljs-comment">//如果访问过了，以U为前驱结点，找w后面的下一个结点</span>            w = getNextNeighhor(u, w);<span class="hljs-comment">//体现了广度优先</span>        &#125;    &#125;&#125;<span class="hljs-comment">//遍历所有的结点，都进行广度优先搜索</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; getNumOfVertex(); i++) &#123;        <span class="hljs-keyword">if</span> (!isVisited[i]) &#123;            bfs(isVisited, i);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/cxlittlecute/ee040603.html"/>
    <url>/cxlittlecute/ee040603.html</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>最近复习数据结构和算法，对一些基础知识进行总结和深化。</p><h2 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h2><p>图是一种数据结构，它不同于我们学习的线性表和树，我们的线性表局限于一个直接前驱和一个直接后继的关系，树也只有一个直接前驱的父节点。</p><p>当我们要表示多对多关系的时候我们就需要用到树。</p><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li>顶点（结点）：可以有零个或多个相邻元素。</li><li>边 ：两个结点的连接称为边。</li><li>路径 ： 一个结点到另一个结点的边和。</li></ul><p>无向图：顶点之间的连接没有方向。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112212.png" srcset="/img/loading.gif" alt=""></p><p>有向图：顶点之间有连接方向。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112244.png" srcset="/img/loading.gif" alt=""></p><p>带权图：带有权值的图也称为网。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724112325.png" srcset="/img/loading.gif" alt=""></p><h2 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h2><ul><li>方式一：邻接矩阵（二维数组表示）<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724113306.png" srcset="/img/loading.gif" alt=""></li></ul><p>矩阵外的编号代表，图中的编号，0和0也就是自己和自己连，一般用0或者∞表示。1就代表可以直接连接。</p><p>邻接矩阵需要为每个顶点都分配n个边的空间，我们可以发现很多边是没有必要存在的，这样就会造成空间上的浪费。</p><ul><li>方式二：邻接表（链表表示）<br>邻接表的实现只关心存在的边，因此没有空间上的浪费，由数组+链表组成。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724113938.png" srcset="/img/loading.gif" alt=""></p><h2 id="举例创建图"><a href="#举例创建图" class="headerlink" title="举例创建图"></a>举例创建图</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200724115625.png" srcset="/img/loading.gif" alt=""></p><p>思路分析：</p><ol><li>创建存储顶点的集合、存储图对应的邻接矩阵、表示该结点有多少条边。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="hljs-comment">//存储顶点集合</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;<span class="hljs-comment">//存储图对应的，邻结矩阵</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;<span class="hljs-comment">//表示边的数目</span></code></pre><p>初始化矩阵：</p><pre><code class="hljs java"><span class="hljs-comment">//构造器</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//初始化矩阵和ArrayList</span>    edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];    vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(n);    numOfEdges = <span class="hljs-number">0</span>;&#125;</code></pre><p>编写方法：</p><pre><code class="hljs java"><span class="hljs-comment">//插入顶点</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;    vertexList.add(vertex);&#125;<span class="hljs-comment">//添加边</span><span class="hljs-comment">//v1表示点的下标表示第几个顶点</span><span class="hljs-comment">//v2表示第二个顶点的下标</span><span class="hljs-comment">//weight表示他们之间的关联关系</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;    edges[v1][v2] = weight;    edges[v2][v1] = weight;    numOfEdges++; <span class="hljs-comment">// 每添加一个关系就增加一条边</span>&#125;</code></pre><p>这样一个图的基本构造就出来了，接下来我们再举例几个常用方法：</p><pre><code class="hljs java"><span class="hljs-comment">//图中常用的方法：</span><span class="hljs-comment">//返回结点个数</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfVertex</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> vertexList.size();&#125;<span class="hljs-comment">//得到边的数目</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfEdges</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> numOfEdges;&#125;<span class="hljs-comment">//返回结点i（下标）对应的数据0-&gt;"A"  1-&gt;"B"  2-&gt;"c"</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValueByIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;    <span class="hljs-keyword">return</span> vertexList.get(i);&#125;<span class="hljs-comment">//返回v1和v2的权值</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;    <span class="hljs-keyword">return</span> edges[v1][v2];&#125;<span class="hljs-comment">//显示图对应的矩阵</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] link : edges) &#123;        System.out.println(Arrays.toString(link));    &#125;&#125;</code></pre><p>最后在main方法中进行真正的构建:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;<span class="hljs-comment">//结点的个数</span>    String VertexValue[] = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;    <span class="hljs-comment">//创建图对象</span>    Graph graph = <span class="hljs-keyword">new</span> Graph(n);    <span class="hljs-comment">//循环的添加顶点</span>    <span class="hljs-keyword">for</span> (String value : VertexValue) &#123;        graph.insertVertex(value);    &#125;    <span class="hljs-comment">//添加边</span>    <span class="hljs-comment">//A-B A-C B-C B-D B-E</span>    graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);    graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//显示</span>    graph.showGraph();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP实现</title>
    <link href="/cxlittlecute/3d4e4ac2.html"/>
    <url>/cxlittlecute/3d4e4ac2.html</url>
    
    <content type="html"><![CDATA[<h1 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h1><p>总结一下使用根据最大长度表实现KMP算法。</p><p>首先，KMP是一个解决模式串在文本串是否出现过，以及若是出现时，最早出现的位置的经典算法。</p><p>我们惯用的思路都是属于暴力匹配：</p><ul><li>如果当前字符匹配成功（即s1[i] == s2[j]），则i++，j++，继续匹配下一个字符；</li><li>如果失配（即s1[i] == s2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 暴力匹配</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">violenceMatch</span><span class="hljs-params">(String str1, String str2)</span> </span>&#123;    <span class="hljs-keyword">char</span>[] s1 = str1.toCharArray();    <span class="hljs-keyword">char</span>[] s2 = str2.toCharArray();    <span class="hljs-keyword">int</span> s1length = s1.length;    <span class="hljs-keyword">int</span> s2length = s2.length;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// i指向s1</span>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// j指向s2</span>    <span class="hljs-keyword">while</span> (i &lt; s1length &amp;&amp; j &lt;s2length) &#123;        <span class="hljs-keyword">if</span> (s1[i] == s2[j]) &#123;            i++;            j++;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有匹配成功</span>            i = i - j + <span class="hljs-number">1</span>;            j = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-comment">// 判断是否匹配成功</span>    <span class="hljs-keyword">if</span> (j == s2length)&#123;        <span class="hljs-keyword">return</span> i - j;    &#125;<span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>如果用暴力方法解决的话就会有大量的回溯造成，因为我们不匹配的时候会j 被置为0，i往后移动一位，但是我们通过分析可以清楚的知道，中间已经匹配过的字符是不用再次匹配的，也就是说不可能匹配上的，但是还是回溯回去做了相同的工作，这样就造成了时间上的大量浪费。</p><p>所以，kmp方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    String str1 = <span class="hljs-string">"BBC ABCDAB ABCDABCDABDE"</span>;    <span class="hljs-comment">// String str2 = "ABCDABD";</span>    String str2 = <span class="hljs-string">"ABCDABD"</span>;    <span class="hljs-keyword">int</span>[] next = kmpNext(<span class="hljs-string">"ABCDABD"</span>);    <span class="hljs-comment">//System.out.println(Arrays.toString(next));</span>    <span class="hljs-keyword">int</span> index = kmpSearch(str1, str2, next);    System.out.println(<span class="hljs-string">"index"</span> + index);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kmpSearch</span><span class="hljs-params">(String str1, String str2, <span class="hljs-keyword">int</span>[] next)</span> </span>&#123;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; str1.length(); i++) &#123;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 失配时模式串移动的位数</span>        &#125;        <span class="hljs-keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;            j++;        &#125;        <span class="hljs-keyword">if</span> (j == str2.length()) &#123;            <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 获取到一个字符串（子串）的部分匹配值表（最大长度表）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] kmpNext(String dest) &#123;    <span class="hljs-comment">// 创建一个next数组保存部分匹配值</span>    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[dest.length()];    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果字符串的长度为1 部分匹配值就是0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; dest.length(); i++) &#123;        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;            j = next[j - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;            j++;        &#125;        next[i] = j;    &#125;    <span class="hljs-keyword">return</span> next;&#125;</code></pre><p>以上方法的KMP实现只需要大家掌握两个地方：</p><ul><li>什么是最大长度表，它是如何计算的（参考下面链接）。</li><li>失配时应该怎么计算模式串移动的位数：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。</li></ul><p>本文只是对KMP进行了简单实现，如果想深入了解可以参考看一下下面的链接，感谢原作者的付出。</p><p>参考链接：<br><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈StringBuilder和StringBuffer</title>
    <link href="/cxlittlecute/b1c49b5c.html"/>
    <url>/cxlittlecute/b1c49b5c.html</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈StringBuilder和StringBuffer"><a href="#浅谈StringBuilder和StringBuffer" class="headerlink" title="浅谈StringBuilder和StringBuffer"></a>浅谈StringBuilder和StringBuffer</h1><p>一个很常见的面试题相信大家都看过，也就是询问StringBuilder和StringBuffer的区别是什么，这个问题大部分人只会考虑线程安不安全的方面。</p><p>也就说StringBuilder:线程不安全，StringBuffer：线程安全。</p><p>那么在这里我们需要多想一下：为什么安全以及不安全，同时它们的内部是如何实现扩容的，它们的toString（）方法的构建是否有区别。</p><h3 id="为什么StringBuffer线程安全？"><a href="#为什么StringBuffer线程安全？" class="headerlink" title="为什么StringBuffer线程安全？"></a>为什么StringBuffer线程安全？</h3><p>线程安全是由于StringBuffer类中的方法都被synchronized关键字所修饰。synchronized修饰在方法上也称为对象锁，多个线程调用同一个对象的同步方法会阻塞，调用不同对象的同步方法不会阻塞。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722215902.png" srcset="/img/loading.gif" alt=""></p><p>所以也就保证了它在多线程的情况下不会出现线程安全问题。</p><p>那么我们接着来分析一下：</p><h3 id="StringBuilder不安全的点又在哪里？"><a href="#StringBuilder不安全的点又在哪里？" class="headerlink" title="StringBuilder不安全的点又在哪里？"></a>StringBuilder不安全的点又在哪里？</h3><p>首先我们根据源码可知StringBuffer和StringBuilder都是继承于AbstractStringBuilder父类。</p><p>父类中有重要的两个变量:</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-keyword">char</span>[] value; <span class="hljs-comment">// 通过字符数组存储字符串的具体内容</span>    <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 记录已使用字符数组的数量</span>&#125;</code></pre><p>接着我们看一看StringBuilder方法中append是如何实现的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">super</span>.append(var1);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;</code></pre><p>它通过调用父类的append方法，那我们接着进去看一看。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.appendNull();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> var2 = var1.length();        <span class="hljs-keyword">this</span>.ensureCapacityInternal(<span class="hljs-keyword">this</span>.count + var2); <span class="hljs-comment">// 确保数组的容量足够，如果容量不够，将对value数组进行扩容</span>        var1.getChars(<span class="hljs-number">0</span>, var2, <span class="hljs-keyword">this</span>.value, <span class="hljs-keyword">this</span>.count);<span class="hljs-comment">// 将需要拼接的StringBuffer型变量str拼接到value数组中</span>        <span class="hljs-keyword">this</span>.count += var2;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;</code></pre><p>那么由于我们的方法没有被synchronized修饰，也就无法保证我们是原子操作。那么当我们多个线程进行数据修改的时候，可能不造成拿到的值，不是另一个线程已经修改的最新值，导致结果出现错误。</p><p>看到这里大家一定也看到了这个ensureCapacityInternal（）方法。</p><h3 id="ensureCapacityInternal（）方法在这里有什么作用？"><a href="#ensureCapacityInternal（）方法在这里有什么作用？" class="headerlink" title="ensureCapacityInternal（）方法在这里有什么作用？"></a>ensureCapacityInternal（）方法在这里有什么作用？</h3><p>ensureCapacityInternal（）方法是检查StringBuilder的对象的原字符数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity（）方法对字符数组进行扩容。</p><p>AbstractStringBuilder类的各个append()方法大同小异。append()方法在追加字符到value数组中之前都会调用ensureCapacityInternal()方法来确保value数组有足够的容量，然后才把字符追加到value数组中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (var1 - <span class="hljs-keyword">this</span>.value.length &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.value = Arrays.copyOf(<span class="hljs-keyword">this</span>.value, <span class="hljs-keyword">this</span>.newCapacity(var1));    &#125;&#125;</code></pre><p>通过Arrays.copyOf（）函数将原数组的内容复制到新数组，最后将新数组的指针重新指向value。</p><h3 id="StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同"><a href="#StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同" class="headerlink" title="StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同"></a>StringBuilder和StringBuffer中toString（）方法获取字符串的方式不同</h3><p>StringBuffer代码片段：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.toStringCache == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.toStringCache = Arrays.copyOfRange(<span class="hljs-keyword">this</span>.value, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.count);     &#125;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">this</span>.toStringCache, <span class="hljs-keyword">true</span>); &#125;</code></pre><p>StringBuilder代码片段：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">this</span>.value, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.count);&#125;</code></pre><p>toString()方法返回一个表示该字符序列的字符串。在StringBuffer中当toStringCache缓存不为null时（表示该StringBuffer对象未被修改），直接返回一个表示该字符序列的字符串。<br>反之，当toStringCache缓存为null时（表示该StringBuffer对象已被修改），调用Arrays类的copyOfRange()静态方法来创建一个新数组和拷贝value数组中的字符到新数组，并将toStringCache指向新数组，然后才返回一个表示该字符序列的字符串。</p><p>通过使用toStringCache缓存，当StringBuffer对象未被修改时，减少了一次创建新数组和拷贝数组的开销。</p><p>而StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p><h3 id="如何扩容？"><a href="#如何扩容？" class="headerlink" title="如何扩容？"></a>如何扩容？</h3><p>我们可以根据源码可知不管是StringBuilder还是StringBuffer都是调用父类的构造方法创建字符数组。<br>默认构造方法设置了value数组的初始容量为16。<br>其他情况概述为设置value数组的初始容量为对象的长度+16，并把String对象中的字符添加到value数组中</p><p>我们在上面提到了他们都会调用父类的ensureCapacityInternal（）方法去检测value数组的容量是否足够，如果不够就涉及到我们的数组扩容，用expandCapacity()方法进行扩容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;        value = Arrays.copyOf(value,                newCapacity(minimumCapacity));    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>; <span class="hljs-comment">// 乘2再加2</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;        newCapacity = minCapacity;    &#125;    <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)        ? hugeCapacity(minCapacity)        : newCapacity;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError(); <span class="hljs-comment">//防溢出</span>    &#125;    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? minCapacity : MAX_ARRAY_SIZE;&#125;</code></pre><p>扩容方式为先将容量乘2再加2，再与所需容量进行比较，若小于所需容量，则取所需容量，后面还有防止溢出的操作，写得非常严谨，获得更新后的容量后，新建一个新的容量的数组，并将之前的数据用Arrays.copyOf()方法复制进去，并更新为新的成员变量value。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建多线程的四种方式</title>
    <link href="/cxlittlecute/459fe412.html"/>
    <url>/cxlittlecute/459fe412.html</url>
    
    <content type="html"><![CDATA[<h1 id="创建多线程的四种方式"><a href="#创建多线程的四种方式" class="headerlink" title="创建多线程的四种方式"></a>创建多线程的四种方式</h1><p>在这里总结一下Java创建多线程的四种方式。</p><p>在Jdk1.5之前创建线程的方式主要是继承Thread类的方式和实现Runnable接口的方式。</p><h2 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h2><ol><li>定义子类继承Thread类</li><li>子类重写Thread类中的run方法。</li><li>创建Thread对象，则创建了线程的对象。</li><li>调用线程的Start方法启动线程，调用run方法。（注意：这里如果是直接用对象调用run方法是不会有新的线程创建的）</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        TestThread tt = <span class="hljs-keyword">new</span> TestThread();        tt.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">":"</span>+i);        &#125;    &#125;&#125;</code></pre><p>注意：<br>生成新的对象并且调用Start方法都是我们主线程做的，当我们调用完start后新的线程就开始执行它的run方法了。</p><h2 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h2><ol><li>定义子类实现Runnable接口。</li><li>子类中重写Runnable接口中的run方法。</li><li>通过Thread类含参构造器创建线程对象。</li><li>将Runnable接口的子类对象作为参数传递给Thread类的构造器中。</li><li>调用Thread类的start方法：开启线程，调用Runnable子类接口中的run方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-meta">@Override</span>　　<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  　　 System.out.println(<span class="hljs-string">"MyThread"</span>);  　　&#125;  &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        MyThread myThread = <span class="hljs-keyword">new</span> MyThread();          Thread thread = <span class="hljs-keyword">new</span> Thread(myThread);          thread.start();      &#125;&#125;</code></pre><p>那么已经看了两种创建线程的方式了，它们的区别也是很明显的，一个需要继承Thread类，另一个需要实现Runnable接口，那么建议使用的肯定是实现接口的方式去创建线程，原因有主要有两个：</p><ol><li>实现接口可以避免单继承的局限性。</li><li>(重点)多个线程可以共享同一个接口实现类的对象，反之继承的话只能通过static修饰后才能共享对象信息，使用接口的实现非常适合相同线程来处理同一份资源。</li></ol><h2 id="方法三：实现Callable接口"><a href="#方法三：实现Callable接口" class="headerlink" title="方法三：实现Callable接口"></a>方法三：实现Callable接口</h2><ol><li>创建一个实现Callable接口的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象。</li><li>将FutureTask对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start（）</li><li>如果想要返回值。就通过futureTask对象获取Callable中call方法的返回值。</li></ol><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre><p>说到FutureTask类我们就要看一下Future接口，FutureTask类是这个接口的唯一实现类。</p><p>可以对具体的Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等操作。</p><p>FutureTask实现了RunnableFuture这个接口，这个RunnableFuture继承了Runnable, Future接口，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722164536.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>举例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();        <span class="hljs-comment">// 这里需要借助于FutureTask类</span>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(testThread);        <span class="hljs-keyword">new</span> Thread(futureTask).start();        <span class="hljs-keyword">try</span> &#123;            Object sum = futureTask.get(); <span class="hljs-comment">// 通过get()方法就能获取Callable实现类重写call（）方法中的执行结果</span>            System.out.println(<span class="hljs-string">"获取结果总和为:"</span>+sum);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                sum += i;            &#125;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程强大？</p><ul><li>重写call（）方法后，可以有返回值。</li><li>这个方法可以抛出异常。</li><li>支持泛型的返回值。</li><li>可以借助于FutureTask类实现更多的功能，比如获取返回结果。</li></ul><h2 id="方法四：实现线程池"><a href="#方法四：实现线程池" class="headerlink" title="方法四：实现线程池"></a>方法四：实现线程池</h2><p>通过Executors工具类、线程池的工厂类，可以创建返回不同类型的线程池。</p><ul><li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池。</li><li>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池。</li><li>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池。</li><li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li></ul><p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor</p><ol><li>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行<br>Runnable</li><li><T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般又来执行<br>Callable</li><li>void shutdown() ：关闭连接池</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);        executorService.execute(<span class="hljs-keyword">new</span> NumberThread1()); <span class="hljs-comment">// 适用于Runnable</span>        Future&lt;Integer&gt; submit = executorService.submit(<span class="hljs-keyword">new</span> NumberThread2()); <span class="hljs-comment">// 适用于Callable</span>        Integer integer = submit.get();        System.out.println(integer);        executorService.shutdown();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;            System.out.println(i);        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;            sum += i;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本数据类型 包装类 String之间的相互转换</title>
    <link href="/cxlittlecute/8a035673.html"/>
    <url>/cxlittlecute/8a035673.html</url>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型-包装类-String之间的相互转换"><a href="#基本数据类型-包装类-String之间的相互转换" class="headerlink" title="基本数据类型 包装类 String之间的相互转换"></a>基本数据类型 包装类 String之间的相互转换</h1><p>类型转换是我们经常会遇到的问题，今天通过本博客进一步总结它的用法。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200721230535.png" srcset="/img/loading.gif" alt=""></p><ul><li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征。</li><li>基本数据类型转变为了包装类，就可以调用类中的方法。</li></ul><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722091807.png" srcset="/img/loading.gif" alt=""></p><p>注意：除了Boolean和Character(没有父类)其他包装类的父类都是Number，我们可以根据以下的源码看出：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200722091736.png" srcset="/img/loading.gif" alt=""></p><h2 id="基本数据类型-gt-包装类"><a href="#基本数据类型-gt-包装类" class="headerlink" title="基本数据类型-&gt;包装类"></a>基本数据类型-&gt;包装类</h2><ul><li>调用包装类的构造器</li><li>通过字符串参数</li><li>自动装箱</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 调用包装类的构造器</span>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    Integer integer1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);    System.out.println(integer1.toString());    <span class="hljs-comment">//  通过字符串参数</span>    Integer integer2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"123"</span>);    System.out.println(integer2.toString());&#125;</code></pre><p>但是需要注意，使用字符串转换的时候，如果是以Number为父类的包装类，使用字符串的构造器，里面的参数如果是又有数字又有字母会报错(也就是说参数想转什么类型，参数就必须符合这种结构)，但是Boolean支持这样，只会判断为false。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Integer integer3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">"asb123"</span>); <span class="hljs-comment">// 报错，参数必须对应包装类的类型</span>    System.out.println(integer3.toString());    Boolean asb123 = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-string">"asb123"</span>);    System.out.println(asb123); <span class="hljs-comment">// 不会报错，结果为false</span>&#125;</code></pre><p>为什么会这样叻？<br>我们来看看Boolean的源码:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Boolean</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">this</span>(parseBoolean(var1));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parseBoolean</span><span class="hljs-params">(String var0)</span> </span>&#123;    <span class="hljs-keyword">return</span> var0 != <span class="hljs-keyword">null</span> &amp;&amp; var0.equalsIgnoreCase(<span class="hljs-string">"true"</span>);&#125;</code></pre><p>在忽略大小写的情况下如果是true那么就是true，如果不是同事不为null，那么都为false。</p><h2 id="包装类-gt-基本数据类型"><a href="#包装类-gt-基本数据类型" class="headerlink" title="包装类-&gt;基本数据类型"></a>包装类-&gt;基本数据类型</h2><p>首先，我们要知道这个操作也是必要的，因为我们的包装类属于类是不能进行加减乘除运算的。</p><ul><li>调用包装类的xxxValue（），你是哪个包装类型就调用哪个value()方法.</li><li>自动拆箱</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span>&#123;    Integer in1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">12</span>);    <span class="hljs-keyword">int</span> i = in1.intValue();    System.out.println(i);&#125;</code></pre><h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>那么说到这里就得说一下自动装箱和自动拆箱了，它属于Jdk5的新特性。我们通过下面的例子理解这个特性：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">20</span>;    test13(num);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">(Object o)</span></span>&#123;    System.out.println(o);&#125;</code></pre><p>上面的这个操作将num放入test13中发现是可以的，这里并不是说我们把Object obj = num,这样理解是不对的，因为int类型和Object类型是没有任何关系的，但为什么又行了？</p><p>因为这里就用到了自动装箱,自动装箱就是这样的,相反有的就是自动拆箱。</p><ul><li>自动装箱：基本数据类型-&gt;包装类</li><li>自动拆箱：包装类-&gt;基本数据类型</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自动装箱</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;    Integer integer = i;    <span class="hljs-comment">// 自动拆箱</span>    <span class="hljs-keyword">int</span> i2 = integer;&#125;</code></pre><h2 id="基本数据类型、包装类-gt-String"><a href="#基本数据类型、包装类-gt-String" class="headerlink" title="基本数据类型、包装类-&gt;String"></a>基本数据类型、包装类-&gt;String</h2><ul><li>方式一：连接运算</li><li>方法二：调用String重载的valueOf（Xxx xx）<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test16</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 方式一：</span>    <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    String str1 = num1 + <span class="hljs-string">""</span>;    <span class="hljs-comment">// 方式二：</span>    <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">12.3f</span>;    String str2 = String.valueOf(f1);    &#125;</code></pre></li></ul><h2 id="String-gt-基本数据类型、包装类"><a href="#String-gt-基本数据类型、包装类" class="headerlink" title="String-&gt;基本数据类型、包装类"></a>String-&gt;基本数据类型、包装类</h2><ul><li>调用包装类的parseXxx（String x）</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test17</span><span class="hljs-params">()</span></span>&#123;    String str = <span class="hljs-string">"123"</span>;    <span class="hljs-keyword">int</span> i = Integer.parseInt(str);&#125;</code></pre><p>注意：<br>最后再强调一下，字符串转换的时候如果有数字和字母，那么会报错NumberFormatException，除了Boolean特殊一些，可以再看一下上面的源码解析。</p><p>同时因为基本数据类型和包装类两个之间有自动装箱和自行拆箱的特性，所以我们可以把他们两个相对string来说看成一个整体进行转换。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>== 和 equals的区别</title>
    <link href="/cxlittlecute/f30662c7.html"/>
    <url>/cxlittlecute/f30662c7.html</url>
    
    <content type="html"><![CDATA[<h1 id="和-equals的区别"><a href="#和-equals的区别" class="headerlink" title="== 和 equals的区别"></a>== 和 equals的区别</h1><p>那么这是一个比较常见的面试题，在这里还是通过源码的分析再次总结一下。</p><p>举例：<br>比如现在我自定义一个类，然后根据这个类生成了两个对象,这两个对象的值属性都是一样的，比如这个叫tom，那个也叫tom，同时两个的年龄也是20岁。他们使用equals比较的结果是什么？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        People tom1 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"tom"</span>, <span class="hljs-number">20</span>);        People tom2 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">"tom"</span>,<span class="hljs-number">20</span>);        System.out.println(tom1.equals(tom2));    &#125;</code></pre><p>如果说你回答true,那么你就错了，说明你误认为Object类中的equals方法比较的是值了。</p><p>那么下面我们就来总结一下它们的区别是什么。</p><p>总结：</p><ul><li>==既可以比较基本类型也可以比较引用类型。对于基本类型是直接比较的值（不一定类型相等），对于引用类型就是比较的内存的地址是否相同，即两个引用是否指向同一个对象实体。</li><li>equals的话，只能适用于引用数据类型，首先它是属于Object类中的方法，如果这个方法没有被当前的类重写那么比较的就是地址，等同于==。</li><li>自定义类相不相同，具体要看有没有重写Object的equals方法来判断。</li><li>通常情况下，我们重写equals方法，会去比较类中的属性值是否相等。（注意：这里便是我们的误区，因为我们经常使用像String这样的类（内部已重写equals方法），导致我们认为我们的自定义类比较的是值）。</li></ul><p>为什么说Object类中的equals方法和==作用相同了？上源码：</p><pre><code class="hljs java"><span class="hljs-comment">// 因为在Object中的equals方法的实现是这样的</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == var1;&#125;</code></pre><p>为什么说String、Data、File、包装类等中比较的是两个对象的值相等了？</p><pre><code class="hljs java"><span class="hljs-comment">// 它们都重写了Object类的equals方法   我们以下面String类为例</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == var1) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (var1 <span class="hljs-keyword">instanceof</span> String) &#123;            String var2 = (String)var1;            <span class="hljs-keyword">int</span> var3 = <span class="hljs-keyword">this</span>.value.length;            <span class="hljs-keyword">if</span> (var3 == var2.value.length) &#123;                <span class="hljs-keyword">char</span>[] var4 = <span class="hljs-keyword">this</span>.value;                <span class="hljs-keyword">char</span>[] var5 = var2.value;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var6 = <span class="hljs-number">0</span>; var3-- != <span class="hljs-number">0</span>; ++var6) &#123;                    <span class="hljs-keyword">if</span> (var4[var6] != var5[var6]) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                    &#125;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对POP、OOP、AOP、FP的理解</title>
    <link href="/cxlittlecute/60f59bbd.html"/>
    <url>/cxlittlecute/60f59bbd.html</url>
    
    <content type="html"><![CDATA[<h1 id="对POP、OOP、AOP的理解"><a href="#对POP、OOP、AOP的理解" class="headerlink" title="对POP、OOP、AOP的理解"></a>对POP、OOP、AOP的理解</h1><p>记得自己刚进项目组的时候就被师傅问了这样的一个问题，当时没有深入去理解过这个东西，于是今天好好总结分析一下这个问题。</p><h2 id="POP面向过程编程"><a href="#POP面向过程编程" class="headerlink" title="POP面向过程编程"></a>POP面向过程编程</h2><p>大家肯定会问什么是面向过程编程叻？</p><p>首先面向过程编程肯定是以过程为中心，那么我们来分析什么是过程，过程就是你解决问题的步骤，也就是这一步应该怎么做，下一步又应该怎么做，好比说一条流水线，每一步都设计好了，只需要使用的时候按照顺序一步一步的调用就可以了。我认为这就是过程。</p><p>那么加上编程二字了，也就是说我们需要首先分析出解决问题需要什么步骤，然后通过一个个函数去把这些步骤给实现，以什么正在发生为主要目标进行编程，那么串联起来也就是面向过程的编程了。</p><h2 id="OOP面向对象编程"><a href="#OOP面向对象编程" class="headerlink" title="OOP面向对象编程"></a>OOP面向对象编程</h2><p>面向对象编程的中心那肯定就是对象了，那么我们需要把问题中所需要的事物抽象为一个个的实体，将实体的属性和行为统一到类中，可以通过类的实例化出具体的对象，然后这些对象就能完成一系列不同的行为。这就是面向对象编程。</p><p>同时需要注意的是我们建立对象的目的不是为了具体完成某一个步骤，而是为了描述这个对象解决问题的行为。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例如简单分析一下飞机大战的设计：<br>面向过程的设计思路就是首先分析问题的步骤：</p><ol><li>开始游戏</li><li>飞机移动</li><li>绘制画面</li><li>判断是否碰撞</li><li>飞机移动</li><li>绘制画面</li><li>判断是否碰撞</li><li>输出结果</li></ol><p>那么接着我们再用面向对象的思想简单分析一下步骤：</p><ol><li>飞机。行为就是飞行移动。</li><li>界面。绘制游戏画面</li><li>规则。判定游戏的输赢。</li></ol><p>可以明显地看出，面向对象是以具体功能对象来划分问题，而不是步骤。绘制画面，这样的步骤多次出现在面向过程的设计中，很可能出现不同的绘制版本。而面向对象的设计中，绘图只可能在界面对象中出现，从而保证了绘图的统一。而且我们使用面向对象进行编程的话，可扩展性也更好。</p><h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p><p>AOP采用横向抽取的机制，能很好的解决OOP通用业务（日志记录、性能统计、安全控制、事务处理、异常处理等）的解耦问题。</p><h2 id="FP函数式编程"><a href="#FP函数式编程" class="headerlink" title="FP函数式编程"></a>FP函数式编程</h2><p>函数式编程的特点就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数，那么在Java8中的Lambda表达式就是很好的体现。</p><p>好处就是代码简洁，开发快速；并且接近自然语言，易于理解。缺点也很明显就是难以编写。</p><p>参考：<br><a href="https://www.cnblogs.com/wyljq/p/12219208.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyljq/p/12219208.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Comparable、Comparator、compareTo 、compare的区别和联系</title>
    <link href="/cxlittlecute/f368ac2a.html"/>
    <url>/cxlittlecute/f368ac2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="Comparable、Comparator、compareTo-、compare的区别和联系"><a href="#Comparable、Comparator、compareTo-、compare的区别和联系" class="headerlink" title="Comparable、Comparator、compareTo 、compare的区别和联系"></a>Comparable、Comparator、compareTo 、compare的区别和联系</h1><p>在Java中经常会涉及到对象的排序问题，对于对象正常情况下，只能比较 == 或 ！=，不能使用 &gt; 或 &lt;，但是在实际开发中，我们又需要对多个对象进行排序，那么就涉及到对象之间的比较大小的问题。那么实现方为以下两种。</p><p>Java实现对象排序的方式有两种：</p><ul><li>自然排序：java.lang.Comparable</li><li>定制排序：java.util.Comparator</li></ul><p>Comparable和Comparator都是用于比较数据的大小的接口，实现Comparable接口需要重写compareTo方法，实现Comparator接口需要重写compare方法，这两个方法的返回值都是int，用int类型的值来确定比较结果。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    Comparator comparator = <span class="hljs-keyword">new</span> Comparator() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o, Object t1)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;    Comparable comparable = <span class="hljs-keyword">new</span> Comparable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;;&#125;</code></pre><h2 id="Comparable自然排序"><a href="#Comparable自然排序" class="headerlink" title="Comparable自然排序"></a>Comparable自然排序</h2><p>默认的时候一般会考虑Comparable。</p><p>Comparable接口的举例说明：</p><ul><li><p>我们一些包装类已经替我们实现了Comparable接口，重写了compareTo方法，我们就能对他们的对象进行大小比较。</p></li><li><p>包装类等重写CompareTo()方法后，默认进行的是从小到大的排列。</p></li><li><p>那么我们重写CompareTo（）的规则是什么了？</p><ol><li>如果当前对象this大于形参对象obj，则返回正整数；</li><li>如果当前对象this小于形参obj，则返回负整数；</li><li>如果当前对象this等于形参对象obj，则返回零。</li></ol></li></ul><p>我们可以一起来看看String类的源码，首先我们可以看到String类实现了Comparable的接口,并且重写了CompareTo（）方法，给出了比较两个String对象大小的方式：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200721144039.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(String var1)</span> </span>&#123;    <span class="hljs-keyword">int</span> var2 = <span class="hljs-keyword">this</span>.value.length;    <span class="hljs-keyword">int</span> var3 = var1.value.length;    <span class="hljs-keyword">int</span> var4 = Math.min(var2, var3);    <span class="hljs-keyword">char</span>[] var5 = <span class="hljs-keyword">this</span>.value;    <span class="hljs-keyword">char</span>[] var6 = var1.value;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var7 = <span class="hljs-number">0</span>; var7 &lt; var4; ++var7) &#123;        <span class="hljs-keyword">char</span> var8 = var5[var7];        <span class="hljs-keyword">char</span> var9 = var6[var7];        <span class="hljs-keyword">if</span> (var8 != var9) &#123;            <span class="hljs-keyword">return</span> var8 - var9;        &#125;    &#125;    <span class="hljs-keyword">return</span> var2 - var3;&#125;</code></pre><ul><li>如果自定义类想要进行排序，我们可以去实现Comparable接口，重写CompareTo()方法，在CompareTo（）方法中指明如何排序。不然的话进行排序就会报错。</li></ul><p>比如下面我们创建了一个商品的类，类中包含商品的名字和价格，我们要进行这个对象的排序就需要进行Comparable接口的实现和接口中方法的重写。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparaTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        Goods test1 = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"test1"</span>, <span class="hljs-number">12</span>);        Goods test2 = <span class="hljs-keyword">new</span> Goods(<span class="hljs-string">"test2"</span>, <span class="hljs-number">13</span>);        Goods[] goods = <span class="hljs-keyword">new</span> Goods[]&#123;test1,test2&#125;;        Arrays.sort(goods);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;    <span class="hljs-comment">// 指明Goods类按照什么方式进行排序：按照价格从低到高排序</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;        <span class="hljs-comment">// 这里和重写equals方法相似</span>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;            <span class="hljs-comment">// 方式一：</span>            <span class="hljs-comment">// 顺便说一下为什么要转换，因为Object类型的引用，调用不了子类Goods的特有属性</span>            Goods goods = (Goods)o; <span class="hljs-comment">// 转换完后当前对象和我们的形参对象就是两个对象了</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.price &gt; goods.price)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.price &lt; goods.price)&#123;                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果价格相等，还需要比较，那么就可以嵌套继续根据名字等进行排序比较</span>                <span class="hljs-comment">// return 0;</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(goods.name);            &#125;            <span class="hljs-comment">// 方式二：</span>            <span class="hljs-comment">// return Double.compare(this.price, goods.price);</span>        &#125;        <span class="hljs-comment">// 如果比较的不是一个商品对象</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"传入的数据类型不一致"</span>);    &#125;&#125;</code></pre><p>注意：实现Comparable接口等于说是在类的基础上做的修改。同时实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。</p><h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><h3 id="什么时候使用Comparator"><a href="#什么时候使用Comparator" class="headerlink" title="什么时候使用Comparator"></a>什么时候使用Comparator</h3><p>当元素的类型没有实现Comparable接口而又不方便修改代码，或者实现了Comparable接口的排序规则不适合当前的操作，那么我们可以考虑使用Comparator的对象来排序。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>重写compare(Object o1,Object o2)方法。</p><p>如果方法返回正整数，则表示o1大于o2；<br>如果返回0,表示相等；<br>如果返回负整数，表示o1小于02。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    String[] arr = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"aa"</span>,<span class="hljs-string">"bb"</span>,<span class="hljs-string">"cc"</span>,<span class="hljs-string">"dd"</span>&#125;;    <span class="hljs-comment">// String本身实现了Comparable接口，但是如果我们想要从大到小排序就需要使用Comparator接口重新编写排序逻辑，因为String类的源码我们是没办法修改的。</span>    Arrays.sort(arr, <span class="hljs-keyword">new</span> Comparator&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(String o1, String  o2)</span> </span>&#123;            <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> String)&#123;                String s1 = (String)o1;                String s2 = (String)o2;                <span class="hljs-keyword">return</span> -s1.compareTo(s2);            &#125;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);        &#125;    &#125;);    <span class="hljs-comment">// Lambda表达式写法</span>    Arrays.sort(arr,(o1,o2) -&gt; &#123;        <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> String &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> String)&#123;            String s1 = (String)o1;            String s2 = (String)o2;            <span class="hljs-keyword">return</span> -s1.compareTo(s2);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的数据类型不一致"</span>);    &#125;);&#125;</code></pre><p>注意：comparator是属于非侵入式的排序实现方式。</p><p>对比：Comparable接口的的方式一旦指定，能够保证Comparable接口实现类在任何位置按照默认实现的方式比较大小，而Comparator属于临时性的比较。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我认为只需要记住Comparable是让对象具有比较的属性，也就是说实现了这个接口的对象之间可以直接互相比较。那么Comparator是比较器，那么实现了这个接口的类就是一个比较器，这个比较器可以应用于对象的比较（它不属于对象的特征，只是一个工具）。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复注解和类型注解</title>
    <link href="/cxlittlecute/d1ceb33.html"/>
    <url>/cxlittlecute/d1ceb33.html</url>
    
    <content type="html"><![CDATA[<h1 id="重复注解和类型注解"><a href="#重复注解和类型注解" class="headerlink" title="重复注解和类型注解"></a>重复注解和类型注解</h1><p>Java8对注解的处理也发生了两点改变：可重复的注解和可用于类型的注解</p><p>要想定义重复注解，该注解必须使用Repeatable修饰一下，同时指定它的容器类。</p><pre><code class="hljs java"><span class="hljs-meta">@Repeatable</span>(MyAnnotations<span class="hljs-class">.<span class="hljs-keyword">class</span>) //指定容器类</span><span class="hljs-class">@<span class="hljs-title">Target</span>(</span>&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "Java 8"</span>;&#125;<span class="hljs-comment">// 定义容器</span><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotations &#123;    MyAnnotation[] value();&#125;</code></pre><p>然后配合反射去使用：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//重复注解</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"Hello"</span>)    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"World"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;        <span class="hljs-comment">// 获取bean class实例</span>        Class&lt;Test&gt; clazz = Test<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;        Method test1 = clazz.getMethod(<span class="hljs-string">"test1"</span>);        MyAnnotation[] mas = test1.getAnnotationsByType(MyAnnotation<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">for</span> (MyAnnotation ma : mas) &#123;            System.out.println(ma.value()); <span class="hljs-comment">// 就能把注解内容获取</span>        &#125;    &#125;&#125;</code></pre><p>类型注解：</p><pre><code class="hljs java"><span class="hljs-meta">@Repeatable</span>(MyAnnotations<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span><span class="hljs-class">@<span class="hljs-title">Target</span>(</span>&#123;ElementType.TYPE, ElementType.METHOD,  ElementType.FIELD&#125;)  <span class="hljs-comment">// 这里</span><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "Java 8"</span>;&#125;``` 新增ElementType.TYPE_USE 和ElementType.TYPE_PARAMETER（在Target上）。设置之后我们就可以在参数类型前面添加注解了：``` java<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//重复注解</span>    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"Hello"</span>)    <span class="hljs-meta">@MyAnnotation</span>(<span class="hljs-string">"World"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">( @MyAnnotation(<span class="hljs-string">"java"</span>)</span> String str) </span>&#123;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新时间日期API</title>
    <link href="/cxlittlecute/aed0d4.html"/>
    <url>/cxlittlecute/aed0d4.html</url>
    
    <content type="html"><![CDATA[<h1 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h1><p>之前经常使用的Data和Calendar等时间API其实并不怎么好用，麻烦而且存在线程安全问题，所以在JAVA8推出了新的API接口。</p><p>全新的API是不可变的线程安全的。</p><p>时间操作是我们写程序经常会用到的API，所以通过这篇文章进行一个总结。</p><h2 id="本地时间和时间戳"><a href="#本地时间和时间戳" class="headerlink" title="本地时间和时间戳"></a>本地时间和时间戳</h2><ul><li>LocalDate LocalTime LocalDateTime 它们的使用方式都一样  注意都是产生新的实例</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//获取当前时间日期 now</span>    LocalDateTime ldt1 = LocalDateTime.now();    System.out.println(ldt1);    <span class="hljs-comment">//指定时间日期 of</span>    LocalDateTime ldt2 = LocalDateTime.of(<span class="hljs-number">2020</span>, <span class="hljs-number">05</span>, <span class="hljs-number">17</span>, <span class="hljs-number">16</span>, <span class="hljs-number">24</span>, <span class="hljs-number">33</span>);    System.out.println(ldt2);    <span class="hljs-comment">//加 plus</span>    LocalDateTime ldt3 = ldt2.plusYears(<span class="hljs-number">2</span>);    System.out.println(ldt3);    <span class="hljs-comment">//减 minus</span>    LocalDateTime ldt4 = ldt2.minusMonths(<span class="hljs-number">3</span>);    System.out.println(ldt4);    <span class="hljs-comment">//获取指定的你年月日时分秒... get</span>    System.out.println(ldt2.getDayOfYear());    System.out.println(ldt2.getHour());    System.out.println(ldt2.getSecond());    System.out.println(ldt2.getYear());&#125;</code></pre><ul><li>Instant:时间戳（以 Unix 元年 1970-01-01 00:00:00 到某个时间之间的毫秒值）</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 默认获取 UTC 时区 (UTC：世界协调时间)</span>    Instant ins1 = Instant.now();    System.out.println(ins1);    <span class="hljs-comment">//带偏移量的时间日期 (如：UTC + 8)</span>    OffsetDateTime odt1 = ins1.atOffset(ZoneOffset.ofHours(<span class="hljs-number">8</span>));    System.out.println(odt1);    <span class="hljs-comment">//转换成对应的毫秒值</span>    <span class="hljs-keyword">long</span> milli1 = ins1.toEpochMilli();    System.out.println(milli1);    <span class="hljs-comment">//构建时间戳 加60秒</span>    Instant ins2 = Instant.ofEpochSecond(<span class="hljs-number">60</span>);    System.out.println(ins2);&#125;</code></pre><ul><li>Duration：计算两个时间的间隔</li><li>Period：计算两个日期之间的间隔</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Instant now1 = Instant.now();    Thread.sleep(<span class="hljs-number">1000</span>);    Instant now2 = Instant.now();    Duration between = Duration.between(now1, now2);    <span class="hljs-comment">// 毫秒这里是toXXXX()，秒是getXXX（）</span>    System.out.println(between.toMillis());    System.out.println(<span class="hljs-string">"------------------------------"</span>);    LocalTime lt1 = LocalTime.now();    Thread.sleep(<span class="hljs-number">3000</span>);    LocalTime lt2 = LocalTime.now();    Duration between2 = Duration.between(lt1, lt2);    System.out.println(between.toMillis());    System.out.println(<span class="hljs-string">"-------------注意：上面都是获取时间的间隔-------------"</span>);    System.out.println(<span class="hljs-string">"-------------注意：下面都是获取日期的间隔-------------"</span>);    LocalDate ld1 = LocalDate.of(<span class="hljs-number">2019</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);    LocalDate ld2 = LocalDate.now();    Period period = Period.between(ld2, ld2);    System.out.println(period); <span class="hljs-comment">// 输出的是ISO标准的格式</span>    <span class="hljs-comment">// 可以进一步获取详细信息</span>    System.out.println(period.getYears());    System.out.println(period.getMonths());&#125;</code></pre><h2 id="时间校正器"><a href="#时间校正器" class="headerlink" title="时间校正器"></a>时间校正器</h2><ul><li>TemporalAdjuster：时间校正器。有时我们需要调整日期为想要的时间。这个类是一个接口。</li><li>TemporalAdjusters：该类提供了很多静态方法进行实现。</li></ul><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TemporalAdjuster</span> </span>&#123;    <span class="hljs-function">Temporal <span class="hljs-title">adjustInto</span><span class="hljs-params">(Temporal var1)</span></span>;&#125;</code></pre><p>这里提一下Temporal接口，大家可以看一下LocalDate这些本地时间操作的源码，它是实现了这个Temporal这个接口的，所以Temporal可以根据实际需求表示为日期、时间或两者组合。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    LocalDateTime now = LocalDateTime.now();    <span class="hljs-comment">// 将月中的天数指定为想要的天数</span>    <span class="hljs-comment">// 改为本月十号</span>    LocalDateTime localDateTime = now.withDayOfMonth(<span class="hljs-number">10</span>);    <span class="hljs-comment">// with（）传递一个时间校正器</span>    <span class="hljs-comment">// 下一个周五是什么时候</span>    LocalDateTime with = now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));    System.out.println(with);&#125;</code></pre><p>我们可以根据源码看出TemporalAdjuster是一个函数式接口，那么我们可以通过自定义时间来判断多久是下一个工作日：</p><pre><code class="hljs java">LocalDateTime with1 = now2.with((t) -&gt; &#123;    LocalDateTime ldt4 = (LocalDateTime) t;    DayOfWeek dow1 = ldt4.getDayOfWeek();    <span class="hljs-keyword">if</span> (dow1.equals(DayOfWeek.FRIDAY)) &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dow1.equals(DayOfWeek.SATURDAY)) &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">2</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> ldt4.plusDays(<span class="hljs-number">1</span>);    &#125;&#125;);System.out.println(with1);</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>-DateTimeFormatter：格式化时间 / 日期</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// DateTimeFormatter后能选择很多种格式化的方式</span>    DateTimeFormatter dtf1 = DateTimeFormatter.ISO_DATE_TIME;    LocalDateTime ldt1 = LocalDateTime.now();    String str1 = ldt1.format(dtf1);    System.out.println(str1);    <span class="hljs-comment">//自定义格式化 ofPattern</span>    DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);    LocalDateTime ldt2 = LocalDateTime.now();    String str2 = ldt2.format(dtf2);    System.out.println(str2);    <span class="hljs-comment">//解析回去 </span>    LocalDateTime newDate = ldt1.parse(str1, dtf1);    System.out.println(newDate);&#125;</code></pre><h2 id="时区操作"><a href="#时区操作" class="headerlink" title="时区操作"></a>时区操作</h2><ul><li>ZonedDate</li><li>ZonedTime</li><li>ZonedDateTime<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//查看支持的所有时区</span>    Set&lt;String&gt; set = ZoneId.getAvailableZoneIds();    set.forEach(System.out::println);    <span class="hljs-comment">//指定时区 构建时间</span>    LocalDateTime ldt1 = LocalDateTime.now(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    System.out.println(ldt1);    <span class="hljs-comment">//在已构建好的日期时间上指定时区</span>    LocalDateTime ldt2 = LocalDateTime.now(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    ZonedDateTime zdt1 = ldt2.atZone(ZoneId.of(<span class="hljs-string">"Europe/Tallinn"</span>));    System.out.println(ldt2);    System.out.println(zdt1);&#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口中的默认方法与静态方法</title>
    <link href="/cxlittlecute/bf52b93a.html"/>
    <url>/cxlittlecute/bf52b93a.html</url>
    
    <content type="html"><![CDATA[<h1 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h1><p>大家查看Java8中源码经常会看到接口中被default或static修饰的方法。<br>在之前接口中只能存在全局静态常量和抽象方法。<br>而现在Java8中可以有被default和static修饰的方法。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><h3 id="为什么要使用default修饰接口中的方法"><a href="#为什么要使用default修饰接口中的方法" class="headerlink" title="为什么要使用default修饰接口中的方法"></a>为什么要使用default修饰接口中的方法</h3><p>引入default主要目的是为了实现接口的升级。因为在原有的Java代码框架中，如果要对接口进行升级就会导致所有接口的实现类都要被<br>修改，这就很麻烦了。</p><p>那么我们在接口内部包含了一些默认的方法实现，为了解决接口的修改与现有的实现不兼容的问题。</p><p>默认方法能够向库的接口添加新功能，并确保与为这些接口的旧版本编写的代码兼容。并且不用在其子类进行逐个实现。</p><p>默认方法的另一个优势是该方法是可选的，子类可以根据不同的需求Override默认实现。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建接口Interface,并且在接口Interface1中定义默认方法helloWorld()。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"test"</span>);    &#125;&#125;</code></pre><p>编写一个类实现接口Interface1,并调用接口中定义的默认方法helloWorld()：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        <span class="hljs-comment">//直接调用helloWorld()方法</span>        myImplement.helloWorld();    &#125;    <span class="hljs-comment">// 执行结果直接输出HelloWorld中的内容。</span>&#125;</code></pre><h3 id="类优先原则"><a href="#类优先原则" class="headerlink" title="类优先原则"></a>类优先原则</h3><p>若一个接口中定义了一个默认方法，而另一个接口或父类中又定义了一个同名的方法时。</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法。（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。（也就是在实现类中重写该方法）</p></li></ul><p>类优先于接口:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"hi i'm from Interface2"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement2 myImplement2 = <span class="hljs-keyword">new</span> MyImplement2();        myImplement2.helloWorld();    &#125;    <span class="hljs-comment">// 结果是MyImplement执行的结果，因为类优先于接口</span>&#125;</code></pre><p>同时实现两个接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>,<span class="hljs-title">Interface2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        <span class="hljs-comment">//直接调用helloWorld()方法</span>        myImplement.helloWorld();    &#125;&#125;</code></pre><p>上面这样同时实现两个接口，恰好两个接口定义的默认方法相同，所以编译器不知道应该执行哪一个就会报错，解决办法就是在实现类中重写该方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>,<span class="hljs-title">Interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"testtest"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyImplement myImplement = <span class="hljs-keyword">new</span> MyImplement();        myImplement.helloWorld();    &#125;&#125;</code></pre><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>java8中为接口新增了一项功能：定义一个或者更多个静态方法。类似于类中的静态方法，接口定义的静态方法可以独立于任何对象调用。</p><p>所以，在调用静态方法时，不需要实现接口，也不需要接口的实例，也就是说和调用类的静态方法的方式类似。</p><p>语法如：接口名字.静态方法名。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"接口中的静态方法"</span>);    &#125;&#125;<span class="hljs-comment">// 调用</span>MyInterface.show();</code></pre><p>注意，实现接口的类或者子接口不会继承接口中的静态方法。static不能和default同时使用。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optional类</title>
    <link href="/cxlittlecute/2df787ac.html"/>
    <url>/cxlittlecute/2df787ac.html</url>
    
    <content type="html"><![CDATA[<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><h2 id="什么是Optional类"><a href="#什么是Optional类" class="headerlink" title="什么是Optional类"></a>什么是Optional类</h2><p>Optional<T> 类 (java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在用 Optional 可以更好的表达这个概念；并且可以避免空指针异常的发生，还有就是快速定位空指针异常的位置。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>Optional.of(T t)：创建一个 Optional 实例</li><li>Optional.empty(T t)：创建一个空的 Optional 实例</li><li>Optional.ofNullable(T t)：若 t 不为 null，创建 Optional 实例，否则空实例</li><li>isPresent()：判断是否包含某值</li><li>orElse(T t)：如果调用对象包含值，返回该值，否则返回 t</li><li>orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回 s 获取的值</li><li>map(Function f)：如果有值对其处理，并返回处理后的 - Optional，否则返回 Optional.empty()</li><li>flatmap(Function mapper)：与 map 相似，要求返回值必须是 Optional</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Optional.of(T t):</span>    Optional&lt;Employee&gt; op = Optional.of(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 能快速锁定空指针异常的位置</span>    Employee employee = op.get();    System.out.println(employee);    <span class="hljs-comment">// Optional.empty(T t)</span>    Optional&lt;Employee&gt; op = Optional.empty(); <span class="hljs-comment">// 构建空的Optional</span>    Employee employee = op.get();    <span class="hljs-comment">// Optional.ofNullable(T t):</span>    <span class="hljs-comment">/* 源码：</span><span class="hljs-comment">     *     public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T var0) &#123;</span><span class="hljs-comment">     *        return var0 == null ? empty() : of(var0);</span><span class="hljs-comment">     *     &#125;</span><span class="hljs-comment">     * */</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    Employee employee = op.get();    <span class="hljs-comment">// isPresent():</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    <span class="hljs-keyword">if</span> (op.isPresent()) &#123; <span class="hljs-comment">// 是否有值</span>        Employee employee = op.get();    &#125;    <span class="hljs-comment">// orElse(T t)等于说设置默认值，有值就使用对象的值，没有就使用设置的默认值:</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee()); <span class="hljs-comment">// 为null时也会报错no value present同样能快速定位</span>    Employee test = op.orElse(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"test"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22.33</span>)); <span class="hljs-comment">// 避免出现空指针异常</span>    System.out.println(test);    <span class="hljs-comment">// orElseGet(Supplier s):</span>    <span class="hljs-comment">// 函数式接口就意味着你能写任意的功能</span>    op.orElseGet(() -&gt; <span class="hljs-keyword">new</span> Employee());    <span class="hljs-comment">// map(Function f)：</span>    Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"test"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">22.33</span>));    Optional&lt;Object&gt; o = op.map((e) -&gt; e.getName()); <span class="hljs-comment">// 把容器中的对象应用到函数上</span>    System.out.println(o.get());    <span class="hljs-comment">// flatmap(Function mapper)：</span>    <span class="hljs-comment">// 和map的区别就是返回的值必须被Optional包装起来</span>    Optional&lt;String&gt; str = op.flatMap((e) -&gt; Optional.of(e.getName())); <span class="hljs-comment">// 进一步防止空指针异常</span>    System.out.println(str.get());&#125;</code></pre><p>总结：<br>Optional类给我进行空指针异常的判断提供了很大的便利，之前我们判断空指针异常大多数情况下都是使用if(xxx != null)进行判断，然后根据不同的情况，返回不同的值。</p><p>但是这种使用if的情况，如果需要判断的属性很多，那么if就会出现嵌套很冗余的情况，大量的if反而影响可读性。</p><p>现在有了Java8以后我们就可以选择Optional类，所以我们可以对我们的类属性进行Optional包装。</p><p>下面我们看一个实例，获取男人女神的名字，我通过两种方式避免空指针异常：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewMan</span> </span>&#123;    <span class="hljs-comment">// Optional也属于对象，所以我们不能赋值为null，这样就没有意义了（它自己调用自己的方法也是null），所以我们可以创建一个空的Optional实例</span>    <span class="hljs-keyword">private</span> Optional&lt;Godness&gt; godness = Optional.empty();&#125;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Godness</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Optional&lt;NewMan&gt; newMan)</span></span>&#123;    <span class="hljs-keyword">return</span> newMan.orElse(<span class="hljs-keyword">new</span> NewMan())            .getGodness()            .orElse(<span class="hljs-keyword">new</span> Godness(<span class="hljs-string">"波多野菊衣"</span>));            .getName();&#125;<span class="hljs-comment">// 这里的man中的属性是没有被Optional修饰的</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">(Man man)</span></span>&#123;    <span class="hljs-keyword">if</span> (man != <span class="hljs-keyword">null</span>)&#123;        Godness gn = man.getGodness;        <span class="hljs-keyword">if</span> (gn != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> gn.getName;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">"波多野菊衣"</span>;&#125;</code></pre><p>通过以上两种方式都可以在对象为null的时候设置默认值避免空指针异常。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法引用和构造器引用</title>
    <link href="/cxlittlecute/caf276df.html"/>
    <url>/cxlittlecute/caf276df.html</url>
    
    <content type="html"><![CDATA[<h1 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h1><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>若Lambda体中的内容有方法已经实现了，我们可以使用方法引用。（可以说方法引用是Lambda表达式的另一种表现形式）</p><p>主要有三种语法格式：</p><ul><li>对象 :: 实例方法</li><li>类 :: 静态方法</li><li>类 :: 实例方法</li></ul><p>注意：Lambda 表达体中调用方法的参数列表、返回类型必须和函数式接口中抽象方法保持一致。</p><pre><code class="hljs java"><span class="hljs-comment">// 对象：：实例方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    PrintStream ps = System.out; <span class="hljs-comment">// 已经有方法实现，并且参数和返回值一致</span>    Consumer&lt;String&gt; con1 = (s) -&gt; ps.println(s);        <span class="hljs-comment">// 在Lambda体的内容中如果已经有方法完成这个功能的时候，我们就可以使用方法引用的方式代替表达式</span>    <span class="hljs-comment">// 注意：这个函数接口中的抽象方法的参数列表与返回值类型，要与我们当前调用方法的参数和返回值类型保持一致。</span>    PrintStream out = System.out;    Consumer&lt;String&gt; consumer2 = out::print;        Consumer&lt;String&gt; consumer3 = System.out::println;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 类：：静态方法名</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    Comparator&lt;Integer&gt; com1 = (x, y) -&gt; Integer.compare(x, y);    System.out.println(com1.compare(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));    Comparator&lt;Integer&gt; com2 = Integer::compare;    System.out.println(com2.compare(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//类：：实例方法名</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;    BiPredicate&lt;String, String&gt; bp1 = (x, y) -&gt; x.equals(y); <span class="hljs-comment">// 其他接口</span>    System.out.println(bp1.test(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>));    BiPredicate&lt;String, String&gt; bp2 = String::equals;    System.out.println(bp2.test(<span class="hljs-string">"c"</span>,<span class="hljs-string">"c"</span>));&#125;</code></pre><p>使用类：：实例方法名调用的条件：</p><p>注意：Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method。<br>如上面x是调用者，y是方法的参数。</p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><ul><li>ClassName::new</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;    Supplier&lt;List&gt; sup1 = () -&gt; <span class="hljs-keyword">new</span> ArrayList();    Supplier&lt;List&gt; sup2 = ArrayList::<span class="hljs-keyword">new</span>;&#125;</code></pre><p>注意：需要调用的构造器的参数列表要与函数时接口中抽象方法的参数列表保持一致。</p><h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><ul><li>Type::new</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span>&#123;    Function&lt;Integer, String[]&gt; function = (x) -&gt; <span class="hljs-keyword">new</span> String[x];    String[] apply = function.apply(<span class="hljs-number">10</span>);    System.out.println(apply.length);    Function&lt;Integer, String[]&gt; function2 = String[]::<span class="hljs-keyword">new</span>;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了类：：实例方法名调用的条件是Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method外。</p><p>其他的都需要Lambda 表达体中调用方法或构造器的参数列表、返回类型必须和函数式接口中抽象方法保持一致。</p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四大内置核心函数式接口</title>
    <link href="/cxlittlecute/860e391d.html"/>
    <url>/cxlittlecute/860e391d.html</url>
    
    <content type="html"><![CDATA[<h1 id="四大内置核心函数式接口"><a href="#四大内置核心函数式接口" class="headerlink" title="四大内置核心函数式接口"></a>四大内置核心函数式接口</h1><p>写lambda表达式需要有函数式接口支持，并不是说每次用lambda表达式时都要自定义一个函数式接口，实际上，Java8已经为我们准备了java.util.function包，其中有许多非常实用的函数式接口。大致可以分为4种，下面介绍4种核心的接口的典型代表：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719204458.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test14</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Comsumer&lt;T&gt;：消费型接口</span><span class="hljs-comment">      *   void accept(T t）;</span><span class="hljs-comment">      * */</span>      Consumer&lt;Integer&gt; consumer = (x) -&gt; System.out.println(x);      consumer.accept(<span class="hljs-number">50</span>);      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Supplier&lt;T&gt;：供给型接口</span><span class="hljs-comment">      *   T get();</span><span class="hljs-comment">      * */</span>      Supplier&lt;Integer&gt; supplier = () -&gt;(<span class="hljs-keyword">int</span>)Math.random()*<span class="hljs-number">10</span>;      supplier.get();      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Function&lt;T,R&gt;：函数型接口</span><span class="hljs-comment">      *   R apply(T t);</span><span class="hljs-comment">      * */</span>      String oldStr = <span class="hljs-string">"123456"</span>;      Function&lt;String, String&gt; function = (s) -&gt; s.substring(<span class="hljs-number">1</span>, s.length()-<span class="hljs-number">1</span>);      System.out.println(function.apply(oldStr));      <span class="hljs-comment">/*</span><span class="hljs-comment">      * Predicate&lt;T&gt;：断言型接口</span><span class="hljs-comment">      *   boolean test(T t)</span><span class="hljs-comment">      * */</span>      <span class="hljs-comment">//Predicate&lt;T&gt;</span>      Integer money = <span class="hljs-number">100</span>;      Predicate&lt;Integer&gt; predicate = (i) -&gt; i &gt;= <span class="hljs-number">100</span>;      <span class="hljs-keyword">if</span> (predicate.test(money))&#123;          System.out.println(<span class="hljs-string">"太贵了"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;          System.out.println(<span class="hljs-string">"还好"</span>);      &#125;  &#125;</code></pre><ul><li>消费型接口典型的代表为Consumer，其抽象方法为accept(), 该方法仅接受一个参数，并且没有返回值。</li><li>供给型接口的典型代表为Supplier，其抽象方法为get(), 该方法不接受参数，但有返回值。</li><li>函数型接口中的代表为Function，其抽象方法位apply(), 接受有一个参数，并且有返回值。</li><li>断言型接口的典型接口为Predicate，其抽象方法为test(), 接受一个参数，并返回一个布尔值。</li></ul><p>通过这些内置函数式接口可以进行一些自定义实现操作，类似于后面的Stream流。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test15</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"test1"</span>, <span class="hljs-string">"test2"</span>, <span class="hljs-string">"test3"</span>);    List&lt;String&gt; filter = filter(list, (s) -&gt; s.length() &gt; <span class="hljs-number">3</span>);    <span class="hljs-keyword">for</span> (String s : filter) &#123;        System.out.println(s);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">filter</span><span class="hljs-params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span> </span>&#123;    List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (String s : list1) &#123;        <span class="hljs-keyword">if</span> (pre.test(s)) &#123;            list1.add(s);        &#125;    &#125;    <span class="hljs-keyword">return</span> list1;&#125;</code></pre><h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719215547.png" srcset="/img/loading.gif" alt=""></p><p>最后我们看一看四大内置函数式接口的源码实现，和我们自己定义的接口只是多了一些default默认方法的实现：</p><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">this</span>.accept(var2);            var1.accept(var2);        &#125;;    &#125;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Supplier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; </span>&#123;    <span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.apply(var1.apply(var2));        &#125;;    &#125;    <span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> var1.apply(<span class="hljs-keyword">this</span>.apply(var2));        &#125;;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (var0) -&gt; &#123;            <span class="hljs-keyword">return</span> var0;        &#125;;    &#125;&#125;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T var1)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test(var2) &amp;&amp; var1.test(var2);        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (var1) -&gt; &#123;            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.test(var1);        &#125;;    &#125;    <span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; var1)</span> </span>&#123;        Objects.requireNonNull(var1);        <span class="hljs-keyword">return</span> (var2) -&gt; &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.test(var2) || var1.test(var2);        &#125;;    &#125;    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object var0)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == var0 ? Objects::isNull : (var1) -&gt; &#123;            <span class="hljs-keyword">return</span> var0.equals(var1);        &#125;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/cxlittlecute/bbcf5ff7.html"/>
    <url>/cxlittlecute/bbcf5ff7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>继续今天愉快的Java8之旅，Lambda表达式和Stream流是Java8中对Java影响最大的两个改变。</p><h2 id="为什么要使用Lambda"><a href="#为什么要使用Lambda" class="headerlink" title="为什么要使用Lambda"></a>为什么要使用Lambda</h2><p>首先Lambda是种匿名函数，它的表达式可以被当做方法传递的代码。然后它能使我们的编程风格更加简洁。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 原来的写法</span>    Comparator&lt;Integer&gt; comparator = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;            <span class="hljs-keyword">return</span> Integer.compare(o1,o2);        &#125;    &#125;;    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(comparator);    <span class="hljs-comment">// Lambda 表达式</span>    Comparator&lt;Integer&gt; comparator2 = (a, b) -&gt; Integer.compare(a, b);    TreeSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(comparator2);&#125;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>一、 Lambda表达式引入了一个新的操作符”-&gt;”，该操作符被称为箭头操作符或Lambda操作符。将表达式分为两个部分：</p><p>左侧：表达式参数列表<br>右侧：表达式所要执行的功能，Lambda体</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 语法格式一：无参数，无返回值：() -&gt; sout</span>    Runnable r = ()-&gt; System.out.println(<span class="hljs-string">"hello Lambda"</span>); <span class="hljs-comment">// 同级别如果有变量仍然无法改变它的值</span>    r.run();    <span class="hljs-comment">// 语法格式二：有一个参数，无返回值</span>    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);    con.accept(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 语法格式三：有一个参数，无返回值 （小括号可以省略不写）</span>    Consumer&lt;String&gt; con2 = x -&gt; System.out.println(x);    con2.accept(<span class="hljs-string">"test"</span>);    <span class="hljs-comment">// 语法格式四：有两个及以上的参数，有返回值，并且 Lambda 体中有多条语句（用&#123;&#125;括起来）</span>    Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123;        System.out.println(<span class="hljs-string">"多个参数并且有多条语句"</span>);        <span class="hljs-keyword">return</span> Integer.compare(x, y);    &#125;;    <span class="hljs-comment">// 语法格式五：有两个及以上的参数，有返回值，并且 Lambda 体中只有1条语句 （大括号 与 return 都可以省略不写）</span>    Comparator&lt;Integer&gt; com2 = (x,y) -&gt; Integer.compare(x, y);    <span class="hljs-comment">// 语法格式六：Lambda 表达式参数的数据类型可以省略不写，因为 Jvm编译器可以通过上下文推断出数据类型- “类型推断”（要写类型全部参数都必须要写）</span>    Comparator&lt;Integer&gt; com3 = (Integer x,Integer y) -&gt; Integer.compare(x, y);&#125;</code></pre><p>口诀：<br>左右遇一括号省<br>左侧推断类型省</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda表达式需要函数式接口的支持。</p><h3 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h3><p>若接口中只有一个抽象方法的接口，称为函数式接口。可以使用注解@FunctionalInterface修饰,可以检查是否是函数式接口。</p><pre><code class="hljs java"><span class="hljs-comment">// 定义一个函数式接口</span><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyFun</span> </span>&#123;    <span class="hljs-function">Integer <span class="hljs-title">count</span><span class="hljs-params">(Integer a, Integer b)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">operation</span><span class="hljs-params">(Integer a, Integer b, MyFun myFun)</span></span>&#123;    <span class="hljs-keyword">return</span> myFun.count(a, b); <span class="hljs-comment">// 这样可以定义两个起始值</span>&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span>&#123;    Integer result = operation(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, (x, y) -&gt; x + y);    System.out.println(result);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap理解总结</title>
    <link href="/cxlittlecute/56a14e38.html"/>
    <url>/cxlittlecute/56a14e38.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap理解总结"><a href="#HashMap理解总结" class="headerlink" title="HashMap理解总结"></a>HashMap理解总结</h1><p>最近重新回顾一下Java8的一些改动。HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。于是通过这篇文章记录我对它的一些理解。</p><p>在进入HashMap之前我们先来了解几个常见的概念。</p><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>哈希表也称为散列表，是根据关键码值而直接访问的数据结构，也就是说可以通过关键码值映射到哈希表中的一个位置进行数据操作，</p><p>这个映射函数称为散列函数，存放记录的数组称为散列表。</p><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719092813.png" srcset="/img/loading.gif" alt=""></p><h2 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h2><p>由于我们的哈希表主体是数组，那么它的数组容量就是确定的固定的，不可避免的会出现，两个元素通过哈希函数求出的实际存储地址值相同的情况。</p><p>也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p><p>所以从这里我们可以知道，我们哈希函数的设计就显得尤为重要了，因此我们要尽可能保证我们的计算简单和散列地址分布均匀。</p><p>解决办法：</p><ul><li>开放定址法（发生冲突，继续寻找下一块未被占用的存储地址）</li><li>再散列函数法</li><li>链表法</li></ul><h2 id="1-7和1-8中HashMap的变化"><a href="#1-7和1-8中HashMap的变化" class="headerlink" title="1.7和1.8中HashMap的变化"></a>1.7和1.8中HashMap的变化</h2><h3 id="头插法和尾插法以及为什么会导致死环？"><a href="#头插法和尾插法以及为什么会导致死环？" class="headerlink" title="头插法和尾插法以及为什么会导致死环？"></a>头插法和尾插法以及为什么会导致死环？</h3><ul><li>JDK1.7用的是头插法，JDK1.8用的是尾插法，为什么要这样做？<br>头插法就是说新来的值会取代原有的值，原有的值就顺推到链表中去。改为尾插法的目的主要就是为了防止多线程扩容后出现死环的情况。</li></ul><p>我们先来看一下JDK1.7扩容的核心代码：</p><pre><code class="hljs java"><span class="hljs-comment">//将老的表中的数据拷贝到新的结构中  </span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-keyword">boolean</span> rehash)</span> </span>&#123;          <span class="hljs-keyword">int</span> newCapacity = newTable.length;<span class="hljs-comment">//容量  </span>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="hljs-comment">//遍历所有桶</span>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != e) &#123;  <span class="hljs-comment">//遍历桶中所有元素（是一个链表）</span>                Entry&lt;K,V&gt; next = e.next;                  <span class="hljs-keyword">if</span> (rehash) &#123;<span class="hljs-comment">//如果是重新Hash，则需要重新计算hash值  </span>                    e.hash = <span class="hljs-keyword">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);                  &#125;                  <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="hljs-comment">//定位Hash桶  </span>                e.next = newTable[i];<span class="hljs-comment">//元素连接到桶中,这里相当于单链表的插入，总是插入在最前面</span>                newTable[i] = e;<span class="hljs-comment">//newTable[i]的值总是最新插入的值</span>                e = next;<span class="hljs-comment">//继续下一个元素  </span>            &#125;          &#125;      &#125;</code></pre><p>HashMap扩容导致死循环的主要原因在于扩容后链表中的节点在新的hash桶使用头插法插入。</p><p>新的hash桶会倒置原hash桶中的单链表，那么在多个线程同时扩容的情况下就可能导致产生一个存在闭环的单链表，从而导致死循环。</p><p>JDK1.8由于使用的是尾插法，不会导致单链表的倒置，所以扩容的时候不会导致死循环。</p><h3 id="为什么扩容后数据存储位置的计算方式不同？"><a href="#为什么扩容后数据存储位置的计算方式不同？" class="headerlink" title="为什么扩容后数据存储位置的计算方式不同？"></a>为什么扩容后数据存储位置的计算方式不同？</h3><p>源码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 分析1：hash(key)</span><span class="hljs-comment">  * 作用：计算传入数据的哈希码（哈希值、Hash值）</span><span class="hljs-comment">  * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样  扰动函数  使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</span><span class="hljs-comment">  * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算</span><span class="hljs-comment">  * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算</span><span class="hljs-comment">  */</span>    <span class="hljs-comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;     h ^= k.hashCode();      h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);     <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);  &#125;    <span class="hljs-comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span>   <span class="hljs-comment">// 1. 取hashCode值： h = key.hashCode() </span>   <span class="hljs-comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;        <span class="hljs-keyword">int</span> h;         <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);  &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">  * 计算存储位置的函数分析：indexFor(hash, table.length)</span><span class="hljs-comment">  * 注：该函数仅存在于JDK 1.7</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;         <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);        <span class="hljs-comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span> &#125;</code></pre><p>在JDK1.7的时候是直接用键的hashcode值与新数组的长度进行&amp;运算得到新数组的位置。</p><p>而在jdk1.8中虽然扩容之后的数组和1.7是一样的，但是在计算元素位置的方式上不太一样，jdk1.7需要与新的数组长度进行重新hash运算，这个方式是相对耗性能的，而在1.8中对这一步进行了优化。</p><p>在1.8中我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><h3 id="为什么HashMap的数组长度一定是2的次幂？"><a href="#为什么HashMap的数组长度一定是2的次幂？" class="headerlink" title="为什么HashMap的数组长度一定是2的次幂？"></a>为什么HashMap的数组长度一定是2的次幂？</h3><pre><code class="hljs java"><span class="hljs-comment">// Java8中计算数组索引下标的位置</span>tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]</code></pre><p>因为hashMap 的数组长度都是2的n次幂 ，那么对于这个数再减去1，转换成二进制的话，就肯定是最高位为0，其他位全是1 的数。</p><p>以Java8为例当数组长度不为2的n次幂 的时候，hashCode 值与数组长度减一做与运算的时候，会出现重复的数据，</p><p>因为不为2的n次幂 的话，对应的二进制数肯定有一位为0 , 这样不管你的hashCode 值对应的该位，是0还是1 ,</p><p>最终得到的该位上的数肯定是0，这带来的问题就是HashMap上的数组元素分布不均匀，而数组上的某些位置，永远也用不到。</p><p>这将带来的问题就是你的HashMap 数组的利用率太低，并且链表可能因为上边的(n - 1) &amp; hash 运算结果碰撞率过高，导致链表太深。(当然jdk 1.8已经在链表数据超过8个以后转换成了红黑树的操作，但那样也很容易造成它们之间的转换时机的提前到来)，所以说HashMap的长度一定是2的次幂，否则会出现性能问题。</p><h3 id="扩容因子为什么是0-75？"><a href="#扩容因子为什么是0-75？" class="headerlink" title="扩容因子为什么是0.75？"></a>扩容因子为什么是0.75？</h3><p>假设hash函数是理想的，数据会通过hash函数均匀的映射到数组上。一个数据映射到每一个桶（bucket）的概率是相等的。那么在任意的数组容量下，put一个数据发生碰撞的概率=数组元素个数/数组容量。</p><p>设置为0.75是做好了时间和空间的权衡的，因为扩容因子越大，碰撞的概率也就越大，发生碰撞后的代价也更大，结果导致效率也大打折扣。所以设置为0.75空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p><h3 id="底层实现原理的区别"><a href="#底层实现原理的区别" class="headerlink" title="底层实现原理的区别"></a>底层实现原理的区别</h3><h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>HashMap map = new HashMap();<br>在实例化以后，底层创建一个长度是16的一维数组Entry[] table。<br>…put很多次后…</p><p>map.put(key1,value1);</p><p>首先，调用key1所在类的hashcode计算key1哈希值，此哈希值经过某种算法后，得到在Entry数组中的存放位置。</p><p>如果该位置上数据为空，此时key和value直接添加成功。<br>如果该位置上数据不为空，说明该位置上存在一个或多个数据(以链表存储)，那么接着就会比较我们的key和已存在的数据的哈希值：</p><pre><code>如果key的哈希值与已存在数据的哈希值不同，添加成功。如果key的哈希值与已存在数据的哈希值相同，继续使用equals方法比较：    如果equals返回false，此时key添加成功。    如果equals返回true，此时value1替换value2。</code></pre><p>扩容的方式是将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><ol><li>new HashMap刚开始时底层没有创建一个长度为16的数组</li><li>底层数组不是Entry[]，变为了Node[]</li><li>首次调用put（）方法时，底层创建长度为16的数组</li><li>jdk7底层结构：数组+链表，jdk8底层结构：数组+链表+红黑树<br>当数组的某一个索引位置上的以链表形式存在的个数&gt;8且当前数组的长度&gt;64，此时此索引位置上的所有数据改为使用红黑树存储。</li></ol><p>参考：<br><a href="https://blog.csdn.net/qq32933432/article/details/86668385" target="_blank" rel="noopener">https://blog.csdn.net/qq32933432/article/details/86668385</a><br><a href="https://blog.csdn.net/liyantianmin/article/details/79401854" target="_blank" rel="noopener">https://blog.csdn.net/liyantianmin/article/details/79401854</a><br><a href="https://blog.csdn.net/qq_36520235/article/details/82417949" target="_blank" rel="noopener">https://blog.csdn.net/qq_36520235/article/details/82417949</a><br><a href="https://blog.csdn.net/Tane_1018/article/details/103392267" target="_blank" rel="noopener">https://blog.csdn.net/Tane_1018/article/details/103392267</a><br><a href="https://www.jianshu.com/p/ee0de4c99f87" target="_blank" rel="noopener">https://www.jianshu.com/p/ee0de4c99f87</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream知识用法总结</title>
    <link href="/cxlittlecute/8a5cc6c1.html"/>
    <url>/cxlittlecute/8a5cc6c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA-8-Stream"><a href="#JAVA-8-Stream" class="headerlink" title="JAVA 8 Stream"></a>JAVA 8 Stream</h1><p>最近写项目经常用到Java8新API stream流，当我们的项目数据量比较大的时候，很少会使用外键约束，因为这样产生的笛卡尔集，数量巨大，会造成我们的系统性能低下。</p><p>我们为了能避免这样的情况发生，一般会去除外键，那么通过一个一个表查询出来的数据，如何才能更好的进行VO或者TO的封装了，使用StreamAPI就是一个不错的处理方式。</p><p>于是，通过本篇文章对此进行一个知识点和用法的总结，帮助你了解和学习它的使用。</p><h2 id="Stream是什么"><a href="#Stream是什么" class="headerlink" title="Stream是什么"></a>Stream是什么</h2><p>数据渠道，用于操作数据源所生产的元素序列。</p><p>集合讲的是数据，流讲的是计算。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>它的主要作用就是，使用一种管道流的思想处理我们的集合对象，对集合对象进行如同SQL语句一样的查找、过滤、排序等操作。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>Stream自己不会存储数据。</li><li>Stream不会改变源对象。</li><li>数据源来源：集合、数组、IO channel、生成器函数等.</li><li>借助于同样新出现的Lambda表达式，极大的提高编程效率和程序可读性。</li><li>中间操作返回新流，它们总是惰性的（延时执行），除非流水线触发终止操作，否则中间操作不会执行任何处理。由于是在终止操作时一次性全部处理，也称为惰性求值。</li><li>内部迭代：迭代操作是stream API完成的。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>一、创建Stream</p><p>从一个数据源，如集合、数组中获取流。</p><p>二、中间操作</p><p>一个操作的中间链，对数据源的数据进行操作。</p><p>三、终止操作</p><p>一个终止操作，执行中间操作链，并产生结果。</p><h2 id="创建Stream流"><a href="#创建Stream流" class="headerlink" title="创建Stream流"></a>创建Stream流</h2><ul><li><p>stream() − 创建顺序流。</p></li><li><p>parallelStream() − 创建并行流。</p></li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 集合流</span><span class="hljs-comment"> *  - Collection.stream() 穿行流</span><span class="hljs-comment"> *  - Collection.parallelStream() 并行流</span><span class="hljs-comment"> */</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list.stream();<span class="hljs-comment">/*</span><span class="hljs-comment">* 数组流</span><span class="hljs-comment">*   Arrays.stream(array)</span><span class="hljs-comment">* */</span>String[] strings = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];Stream&lt;String&gt; stream2 = Arrays.stream(strings);<span class="hljs-comment">/*</span><span class="hljs-comment">* 3.Stream 静态方法</span><span class="hljs-comment">*   Stream.of(...)</span><span class="hljs-comment">* */</span>Stream&lt;Integer&gt; stream3 = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">* 4.无限流（一直停不下来）</span><span class="hljs-comment">*  (1)迭代</span><span class="hljs-comment">*  (2)生成</span><span class="hljs-comment">* */</span><span class="hljs-comment">// 迭代</span>Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>);<span class="hljs-comment">// 生成(可无限制造对象)</span>Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random());<span class="hljs-comment">/*</span><span class="hljs-comment">* 5.BufferedReader.lines()将每行内容转成流</span><span class="hljs-comment"> * */</span>BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"stream.txt"</span>));Stream&lt;String&gt; lineStream = reader.lines();<span class="hljs-comment">/*</span><span class="hljs-comment">*6.Pattern.splitAsStream() 将字符串分隔成流</span><span class="hljs-comment">* */</span>Pattern pattern = Pattern.compile(<span class="hljs-string">","</span>);Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="hljs-string">"a,b,c,d"</span>);</code></pre><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="筛选-切片"><a href="#筛选-切片" class="headerlink" title="筛选/切片"></a>筛选/切片</h3><ul><li>filter：接收 Lambda ，从流中排除某些元素</li><li>limit：截断流，使其元素不超过给定数量</li><li>skip(n)：跳过元素，返回一个舍弃了前n个元素的流；若流中元素不足n个，则返回一个空流；与 limit(n) 互补</li><li>distinct：筛选，通过流所生成的 hashCode() 与 equals() 取除重复元素</li></ul><pre><code class="hljs java">List&lt;Employee&gt; emps = Arrays.asList(        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">101</span>, <span class="hljs-string">"Z3"</span>, <span class="hljs-number">19</span>, <span class="hljs-number">9999.99</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">102</span>, <span class="hljs-string">"L4"</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7777.77</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">103</span>, <span class="hljs-string">"W5"</span>, <span class="hljs-number">35</span>, <span class="hljs-number">6666.66</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">104</span>, <span class="hljs-string">"Tom"</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1111.11</span>),        <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">105</span>, <span class="hljs-string">"Jerry"</span>, <span class="hljs-number">60</span>, <span class="hljs-number">4444.44</span>));<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 中间操作：不执行任何操作</span>    <span class="hljs-comment">// 此API属于内部迭代</span>    <span class="hljs-comment">// 外部迭代是我们自己编写的for 和 foreach方法</span>    Stream&lt;Employee&gt; stream = emps.stream()            .filter((x) -&gt; x.getAge() &gt; <span class="hljs-number">35</span>)            .limit(<span class="hljs-number">3</span>) <span class="hljs-comment">// 注意：短路 达到满足不再内部迭代</span>            .distinct() <span class="hljs-comment">// 注意：重写hashcode和equals方法</span>            .skip(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 终止操作：一次性执行全部内容，惰性求值</span>    stream.forEach(System.out::println);&#125;</code></pre><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><ul><li>map：接收 Lambda ，将元素转换为其他形式或提取信息；接受一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</li><li>flatMap：接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 大小写转换，该函数会被应用到每个元素上，并将其映射成一个新的元素</span>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);    list.stream()            .map((str) -&gt; str.toUpperCase())            .forEach(System.out::println);    <span class="hljs-comment">// 提取集合对象中信息</span>    emps.stream()            .map(Employee::getAge)            .forEach(System.out::println);&#125;</code></pre><p>在使用flatmap之前我们先看这样一个案例，将集合中字符串中的所有字符提取出来。在我们不使用flatmap之前我们需要进行嵌套的两次foreach，因为我们的filterCharacter方法也是返回的stream流对象：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Stream&lt;Character&gt; <span class="hljs-title">filterCharacter</span><span class="hljs-params">(String str)</span> </span>&#123;    List&lt;Character&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str.toCharArray()) &#123;        list.add(c);    &#125;    <span class="hljs-keyword">return</span> list.stream();&#125;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"bc"</span>, <span class="hljs-string">"ca"</span>);    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream()            .map(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数上的效果&#123;&#123;a,b,c&#125;,&#123;b,c&#125;,&#123;c,a&#125;&#125;，最终在一个大流中</span>    streamStream.forEach((sm) -&gt; &#123;        sm.forEach(System.out::println);    &#125;);&#125;</code></pre><p>那么我们可以再看看flatMap的作用，接收一个函数作为参数，将流中每一个值都换成另一个流，然后把所有流重新连接成一个流。重点：flatMap得到的是一个流！</p><pre><code class="hljs java">Stream&lt;Character&gt; characterStream = list.stream()        .flatMap(GulimallProductApplicationTests::filterCharacter); <span class="hljs-comment">// 应用函数的效果，去掉大流整合成一个流&#123;a,b,c,b,c,c,a&#125;</span>characterStream.forEach(System.out::println);</code></pre><p>此处总结一下这里，等于说Map是把一个个的流放入一个新的流中，导致流的嵌套；而flatMap是将一个个流中的元素放入新的流中。（这样会好理解一些）</p><p>类比于：集合中的add(Object obj)  addAll(Collection coll)方法。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>sorted()：自然排序(Comparable)</li><li>sorted(Comparator c)：定制排序(Comparator)</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test7</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 自然排序</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);    list.stream()            .sorted() <span class="hljs-comment">//comparaTo()</span>            .forEach(System.out::println);        <span class="hljs-comment">// 定制排序</span>    emps.stream()            .sorted((e1, e2) -&gt; &#123; <span class="hljs-comment">//compara()</span>                <span class="hljs-keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123;                    <span class="hljs-keyword">return</span> e1.getName().compareTo(e2.getName());                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> e1.getAge().compareTo(e2.getAge());                &#125;            &#125;)            .forEach(System.out::println);&#125;</code></pre><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    Student s1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"aa"</span>, <span class="hljs-number">10</span>);    Student s2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"bb"</span>, <span class="hljs-number">20</span>);    List&lt;Student&gt; studentList = Arrays.asList(s1, s2);    studentList.stream()            .peek(o -&gt; o.setAge(<span class="hljs-number">100</span>))            .forEach(System.out::println);    <span class="hljs-comment">//结果：</span>    Student&#123;name=<span class="hljs-string">'aa'</span>, age=<span class="hljs-number">100</span>&#125;    Student&#123;name=<span class="hljs-string">'bb'</span>, age=<span class="hljs-number">100</span>&#125;&#125;</code></pre><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><ul><li>allMatch：检查是否匹配所有元素</li><li>anyMatch：检查是否至少匹配一个元素</li><li>noneMatch：检查是否没有匹配所有元素</li><li>findFirst：返回第一个元素</li><li>findAny：返回当前流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中最大值</li><li>min：返回流中最小值</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test8</span><span class="hljs-params">()</span></span>&#123;    List&lt;Status&gt; list = Arrays.asList(Status.FREE, Status.BUSY, Status.VOCATION);    <span class="hljs-keyword">boolean</span> flag1 = list.stream()            .allMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag1);    <span class="hljs-keyword">boolean</span> flag2 = list.stream()            .anyMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag2);    <span class="hljs-keyword">boolean</span> flag3 = list.stream()            .noneMatch((s) -&gt; s.equals(Status.BUSY));    System.out.println(flag3);    <span class="hljs-comment">// 避免空指针异常</span>    Optional&lt;Status&gt; op1 = list.stream()            .findFirst();    <span class="hljs-comment">// 如果Optional为空 找一个替代的对象</span>    Status s1 = op1.orElse(Status.BUSY);    System.out.println(s1);    Optional&lt;Status&gt; op2 = list.stream()            .findAny();    System.out.println(op2);    <span class="hljs-keyword">long</span> count = list.stream()            .count();    System.out.println(count);    <span class="hljs-comment">// 获取最大工资的员工信息</span>    Optional&lt;Employee&gt; max = emps.stream()            .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));    System.out.println(max.get());    <span class="hljs-comment">// 获取最小工资</span>    Optional&lt;Double&gt; min = emps.stream()            .map(Employee::getSalary)            .min(Double::compare);    System.out.println(min.get());&#125;</code></pre><h2 id="归约-收集"><a href="#归约-收集" class="headerlink" title="归约/收集"></a>归约/收集</h2><ul><li>归约：reduce(T identity, BinaryOperator) / reduce(BinaryOperator) 可以将流中的数据反复结合起来，得到一个值</li><li>收集：collect 将流转换成其他形式；接收一个 Collector 接口的实现，用于给流中元素做汇总的方法</li></ul><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 归约</span>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);    Integer sum = list.stream()            .reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x + y); <span class="hljs-comment">// identity起始值 binaryOperator二元运算 现将起始值作为x，从流中取出元素作为y</span>    System.out.println(sum);    System.out.println(<span class="hljs-string">"-----------------------------------------"</span>);        <span class="hljs-comment">// 获取当前所有员工工资总和</span>    Optional&lt;Double&gt; reduce = emps.stream()            .map(Employee::getSalary)            .reduce(Double::sum); <span class="hljs-comment">// 为什么这里返回Optional？因为这里没有设置起始值</span>&#125;</code></pre><p>map和reduce的连接通常称为map-reduce模式，现在大数据经常应用这种模式。</p><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><p>collect-将流转换为其他形式。接收一个Collection接口的实现，用于给stream中元素汇总的方法。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 把公司员工所有名字提取出来，放入集合中</span>        List&lt;String&gt; list = emps.stream()                .map(Employee::getName)                .collect(Collectors.toList());<span class="hljs-comment">// Collectors实现类提供了很多静态方法，创建常见的收集器实例</span>        list.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        Set&lt;String&gt; set = emps.stream()                .map(Employee::getName)                .collect(Collectors.toSet());        set.forEach(System.out::println);        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        HashSet&lt;String&gt; hs = emps.stream()                .map(Employee::getName)                .collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));        hs.forEach(System.out::println);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 收集总数</span>        Long collect = emps.stream()                .collect(Collectors.counting());        <span class="hljs-comment">// 平均值</span>        Double avg = emps.stream()                .collect(Collectors.averagingDouble(Employee::getSalary)); <span class="hljs-comment">// 指定了map</span>        System.out.println(avg);        <span class="hljs-comment">// 总和</span>        Double collect1 = emps.stream()                .collect(Collectors.summingDouble(Employee::getSalary));        System.out.println(collect1);        <span class="hljs-comment">// 最大值</span>        Optional&lt;Employee&gt; max = emps.stream()                .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));        System.out.println(max.get());        <span class="hljs-comment">// 最小值</span>        Optional&lt;Double&gt; min = emps.stream()                .map(Employee::getSalary)                .collect(Collectors.minBy(Double::compare));        System.out.println(min.get());        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);        <span class="hljs-comment">// 根据状态分组</span>        Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus));        System.out.println(map);        <span class="hljs-comment">// 多级分组</span>        Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; collect2 = emps.stream()                .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123;                    <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">35</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"青年"</span>;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getAge() &lt;= <span class="hljs-number">50</span>) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"中年"</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-string">"老年"</span>;                    &#125;                &#125;)));        <span class="hljs-comment">//分区</span>        Map&lt;Boolean, List&lt;Employee&gt;&gt; listMap = emps.stream()                .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; <span class="hljs-number">5000</span>)); <span class="hljs-comment">// 满足条件的一个区，不满足条件的在另一个区</span>        System.out.println(listMap);&#125;</code></pre><p>最后还有收集获取运算结果的其他方式和连接操作：</p><pre><code class="hljs java">DoubleSummaryStatistics dss = emps.stream()       .collect(Collectors.summarizingDouble(Employee::getSalary));   System.out.println(dss.getMax());   System.out.println(dss.getMin());   System.out.println(dss.getSum());   System.out.println(dss.getCount());   System.out.println(dss.getAverage());      <span class="hljs-comment">// 将参数连接起来</span>   String str = emps.stream()       .map(Employee::getName)       .collect(Collectors.joining(<span class="hljs-string">"-"</span>));  <span class="hljs-comment">// 可传入分隔符，首尾需要接着添加两个参数</span>   System.out.println(str);</code></pre><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><ul><li>并行流：就是把一个内容分成几个数据块，并用不同的线程分别处理每个数据块的流。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行操作；Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与串行流之间切换。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//串行流(单线程)：切换为并行流 parallel()</span>    <span class="hljs-comment">//并行流：切换为串行流 sequential()</span>    LongStream.rangeClosed(<span class="hljs-number">0</span>, <span class="hljs-number">100000000L</span>)            .parallel() <span class="hljs-comment">//底层：Fork Join</span>            .reduce(<span class="hljs-number">0</span>, Long::sum);&#125;</code></pre><p>fork join类似于归并排序，比较重要的思想就是工作窃取模式，它会将要执行的新任务，拆分为更小的任务执行，将小任务放入线程队列中，如果自己的线程空闲了，就会去别的线程偷取一个小任务放入自己的线程执行。这种方式减少了线程等待的时间，提高了性能。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075629.png" srcset="/img/loading.gif" alt=""></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>最后根据一个图更好的了解Stream 中间操作和结束操作的分类：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200719075903.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>无状态：指元素的处理不受之前元素的影响。</p></li><li><p>有状态：指该操作只有拿到所有元素之后才能继续下去。<br>（判断流操作是否有状态的判断标准，就是看是否需要知道先前的数据历史。前后数据是否有依赖关系来判断）</p></li><li><p>非短路操作：指必须处理所有元素才能得到最终结果。</p></li><li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p></li></ul><p>参考：<br><a href="https://blog.csdn.net/y_k_y/article/details/84633001" target="_blank" rel="noopener">https://blog.csdn.net/y_k_y/article/details/84633001</a></p>]]></content>
    
    
    <categories>
      
      <category>Java8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GateWay网关访问服务出现503的问题解决</title>
    <link href="/cxlittlecute/674d8191.html"/>
    <url>/cxlittlecute/674d8191.html</url>
    
    <content type="html"><![CDATA[<h1 id="GateWay网关访问服务出现503的问题解决"><a href="#GateWay网关访问服务出现503的问题解决" class="headerlink" title="GateWay网关访问服务出现503的问题解决"></a>GateWay网关访问服务出现503的问题解决</h1><p>对于这个问题也是困扰了自己很久，今天下定决定要把它干掉。这个问题很坑，建议使用IDEA的朋友都可以看一看。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在分布式服务中，使用GateWay网关进行服务请求路由的统一管理，它是系统对外的唯一入口。为了让网关能正常发送调用其他服务，我使用到了Nacos服务注册中心。</p><p>正是这样出现了，我通过服务端口，能正常访问接口返回数据，通过网关访问有时可以有时不行的情况（也就是出现503的状态码反馈）。</p><p>HTTP状态码503指的是web服务器不能处理HTTP请求。原因大致如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716131929.png" srcset="/img/loading.gif" alt="avator"></p><p>那么根据上面这四个原因我还是没有分析出为什么会出现这个问题。于是我开始一步步排查问题。</p><ol><li><p>我首先认为是我GateWay网关，拦截配置的问题，可是我的情况是有时出现503，有时又能通过网关正常访问，所以暂时排除了这种情况。</p></li><li><p>是否本身的单体服务有问题，但是通过postman的测试，通过服务的端口访问接口，都能正常返回数据。所以也暂时排除这种情况。</p></li><li><p>Nacos注册中心的问题。</p></li></ol><p>那基本能确定是Nacos注册中心的问题了，但也不完全是Nacos的锅。</p><p>再次分析：</p><p>F12查看Network，请求的发送情况，发现OPTIONS预检请求是正常发送的，但发送真正的请求的时候出现了503的错误。如下图:</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133417.png" srcset="/img/loading.gif" alt="avator"></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133338.png" srcset="/img/loading.gif" alt="avator"></p><p>接着我点开了Preview（预览功能），看到了错误提示：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716133611.png" srcset="/img/loading.gif" alt="avator"></p><p>我们可以通过错误提示很清晰的看到message的反馈，就是发现不了我的product服务。</p><p>和我们判断的没错是nacos的问题，于是我进入nacos查看服务是否注册成功。</p><p>这里就发现了一个很奇怪的现象，正常的我们刷新nacos的界面服务是不会掉的，但是我的product商品服务，一会有一会儿又没有，刚开始我发现了这个问题，但没有引起注意，也就导致这个问题之前一直没有得到解决。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是，我抱着再试一试的心态，将该服务的端口号从10000改为了8100，也就是改为了其他的数（或者修改一下服务名），这个服务就在nacos注册中心稳定了。（前提是确保你的服务Nacos配置没有问题）</p><p>这其实是一个很容易解决的bug，但是之前网上找过都没有得到好的解决。</p><p>让我想到了idea在使用过程中确实存在一些bug，常见的就是</p><ol><li><p>创建继承maven项目数量多了之后，项目结构就会不一样，需要手动修改，或者更换项目名才能解决。</p></li><li><p>使用springboot的过程中有些端口无法使用，这种无法使用是由于idea和系统的问题，你能正常跑通你的项目，但是这个项目你无法通过客户端访问，只要访问就是500服务器错误。</p></li></ol><hr><p>同时这里强调，不是因为什么端口被占用的问题，端口如果被占用，连服务都是无法启动的，所以这就是一些简单又很坑人的地方。</p><p>如果您有幸看到了这篇文章，希望对您有帮助，解决到您的问题。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
      <category>GateWay</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>GateWay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</title>
    <link href="/cxlittlecute/4e6c6273.html"/>
    <url>/cxlittlecute/4e6c6273.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题"><a href="#Springboot出现Possibly-consider-using-a-shorter-maxLifetime-value警告问题" class="headerlink" title="Springboot出现Possibly consider using a shorter maxLifetime value警告问题"></a>Springboot出现Possibly consider using a shorter maxLifetime value警告问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>这是我经常遇到的一个问题，当我们使用Springboot连接数据库的时候（Springboot默认使用的是HikariCP），如果长时间的静默没有请求连接池，那么就会出现如下warn：</p><pre><code class="hljs routeros">[http-nio-7003-exec-10] WARN  com.zaxxer.hikari.pool.PoolBase - HikariPool-1 - Failed <span class="hljs-keyword">to</span> validate<span class="hljs-built_in"> connection </span>com.mysql.cj.jdbc.ConnectionImpl@3987b59f (<span class="hljs-literal">No</span> operations allowed after<span class="hljs-built_in"> connection </span>closed.). Possibly consider using a shorter maxLifetime value.</code></pre><p>我们可以看到这个warn的最后一句话， Possibly consider using a shorter maxLifetime value（让我们考虑使用一个更小的maxLifetime值）。</p><p>看到这里大家肯定会疑惑maxLifeTime是什么？</p><p>我们先来看看官方文档对参数的说明：<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200716085042.png" srcset="/img/loading.gif" alt="avator"></p><p>此属性控制池中连接的最长生存期。一个正在使用的连接永远不会失效，只有当它关闭时，它才会被移除。在逐个连接的基础上，应用较小的负衰减以避免池中的大规模灭绝。我们强烈建议设置此值，并且它应该比任何数据库或基础设施施加的连接时间限制短几秒。值为0表示没有最长生存期（无限生存期），当然取决于idleTimeout设置。默认值：1800000（30分钟）。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>其实这个问题很好解决，就是在配置文件中添加HikariCP的参数设置，也就是将maxLifeTime的值变小。</p><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.datasource</span><span class="hljs-selector-class">.hikari</span><span class="hljs-selector-class">.max-lifetime</span> =<span class="hljs-number">120000</span></code></pre><p>同时这里需要注意的是，如果这样设置后出现另外的报错：</p><pre><code class="hljs applescript">idleTimeout <span class="hljs-keyword">is</span> close <span class="hljs-keyword">to</span> <span class="hljs-keyword">or</span> more than maxLifetime, disabling <span class="hljs-keyword">it</span>.</code></pre><p>说明你设置的maxLifeTime的值低于了idleTimeout。</p><p>ideaTimeOut是连接允许在池中闲置的最长时间，它有个规则：如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒。</p><p>所以最好是将maxLifeTime和idleTimeOut的值一起按照要求修改。</p><p>文档里面的参数都可以在配置文件中修改默认值，可以根据自己的需要来。</p><p>当然说到这里其实自己也是有疑问的，为什么降低了maxLifeTime就可以避免发生这个问题？现在只是找到方法解决掉了这个问题，但是原理不是很明白，查阅到了相关资料我会进行补充。有想法的朋友可以评论或私信我，互相交流。</p><hr><p>以上的理解如果有偏差，可以通过关于页的联系方式第一时间联系我，我将做好修改更正工作。期待您的回复和反馈。</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>HikariCP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>HikariCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云oss上传报错Invalid according to Policy Policy expired</title>
    <link href="/cxlittlecute/1d5383b1.html"/>
    <url>/cxlittlecute/1d5383b1.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"><a href="#阿里云oss上传报错Invalid-according-to-Policy-Policy-expired" class="headerlink" title="阿里云oss上传报错Invalid-according-to-Policy-Policy-expired"></a>阿里云oss上传报错Invalid-according-to-Policy-Policy-expired</h1><p>阿里云oss上传使用的是服务端签名后直传；通过服务端生成上传签名，前端使用服务端生成的签名上传文件。</p><p>同时，在这里先说一下为什么要使用服务端签名后直传。</p><p>之前使用OSS时，是让文件过自己的服务器，然后通过自己的服务器传到OSS的服务器，也就是这样：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175217.png" srcset="/img/loading.gif" alt="avator"></p><p>通过上面的这种直传的方式，导致我们的服务端压力很大。虽然我们可以使用JS直接前端传递，但是这样会暴露我们的AccessKeyID和AcessKeySecret，会有安全隐患。</p><p>所以选择了，接下来的这种服务端签名的方式上传：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715175427.png" srcset="/img/loading.gif" alt="avator"></p><p>正是使用了这种方式出现了以下这个问题：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174130.png" srcset="/img/loading.gif" alt="avator"></p><p>查询阿里云文档可知错误原因：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200715174653.png" srcset="/img/loading.gif" alt="avator"></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p> 生成签名时，官方代码中的参数expireTime默认是30秒，改为更大的时间。</p><h3 id="代码演示-解决办法"><a href="#代码演示-解决办法" class="headerlink" title="代码演示 解决办法"></a>代码演示 解决办法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Osscontroller</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.endpoint&#125;"</span>)    <span class="hljs-keyword">private</span> String endpoint;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.oss.bucket&#125;"</span>)    <span class="hljs-keyword">private</span> String bucket;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.access-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessId;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;spring.cloud.alicloud.secret-key&#125;"</span>)    <span class="hljs-keyword">private</span> String accessKey;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/oss/policy"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> R <span class="hljs-title">policy</span><span class="hljs-params">()</span> </span>&#123;        String host = <span class="hljs-string">"https://"</span> + bucket + <span class="hljs-string">"."</span> + endpoint; <span class="hljs-comment">// host的格式为 bucketname.endpoint</span>        <span class="hljs-comment">// callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。</span>        <span class="hljs-comment">//String callbackUrl = "http://88.88.88.88:8888";</span>        String format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(<span class="hljs-keyword">new</span> Date());        String dir = format+<span class="hljs-string">"/"</span>; <span class="hljs-comment">// 用户上传文件时指定的前缀。</span>        <span class="hljs-comment">// 创建OSSClient实例。</span>        OSS ossClient = <span class="hljs-keyword">new</span> OSSClientBuilder().build(endpoint, accessId, accessKey);        Map&lt;String, String&gt; respMap = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">long</span> expireTime = <span class="hljs-number">60</span>; <span class="hljs-comment">//增大这里的时间</span>            <span class="hljs-keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="hljs-number">1000</span>;            Date expiration = <span class="hljs-keyword">new</span> Date(expireEndTime);            <span class="hljs-comment">// PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span>            PolicyConditions policyConds = <span class="hljs-keyword">new</span> PolicyConditions();            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="hljs-number">0</span>, <span class="hljs-number">1048576000</span>);            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);            <span class="hljs-keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="hljs-string">"utf-8"</span>);            String encodedPolicy = BinaryUtil.toBase64String(binaryData);            String postSignature = ossClient.calculatePostSignature(postPolicy);            respMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();            respMap.put(<span class="hljs-string">"accessid"</span>, accessId);            respMap.put(<span class="hljs-string">"policy"</span>, encodedPolicy);            respMap.put(<span class="hljs-string">"signature"</span>, postSignature);            respMap.put(<span class="hljs-string">"dir"</span>, dir);            respMap.put(<span class="hljs-string">"host"</span>, host);            respMap.put(<span class="hljs-string">"expire"</span>, String.valueOf(expireEndTime / <span class="hljs-number">1000</span>));        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// Assert.fail(e.getMessage());</span>            System.out.println(e.getMessage());        &#125; <span class="hljs-keyword">finally</span> &#123;            ossClient.shutdown();        &#125;        <span class="hljs-keyword">return</span> R.ok().put(<span class="hljs-string">"data"</span>,respMap);    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo消除中文路径</title>
    <link href="/cxlittlecute/8ce042f1.html"/>
    <url>/cxlittlecute/8ce042f1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo消除中文路径"><a href="#Hexo消除中文路径" class="headerlink" title="Hexo消除中文路径"></a>Hexo消除中文路径</h1><p>我们博客中的文章标题，一般都会有中文出现，同时Hexo默认也是会把你的title放在路径访问的最后，也就是xxx.html。</p><p>由于路径中有中文的存在，如果你想根据URL进行操作的时候就会被浏览器编码，也就是URL code字符编码。</p><pre><code class="hljs llvm">https://ccctop.cn/<span class="hljs-number">2020</span>/<span class="hljs-number">07</span>/<span class="hljs-number">13</span>/Jenkins<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%89</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A1</span><span class="hljs-symbol">%8</span>Cshell<span class="hljs-symbol">%E5</span><span class="hljs-symbol">%91</span><span class="hljs-symbol">%BD</span><span class="hljs-symbol">%E4</span><span class="hljs-symbol">%BB</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%EF</span><span class="hljs-symbol">%BC</span><span class="hljs-symbol">%8</span>C<span class="hljs-symbol">%E6</span><span class="hljs-symbol">%8</span>F<span class="hljs-symbol">%90</span><span class="hljs-symbol">%E7</span><span class="hljs-symbol">%A4</span><span class="hljs-symbol">%BAcommand-not-found</span><span class="hljs-symbol">%E8</span><span class="hljs-symbol">%A7</span><span class="hljs-symbol">%A3</span><span class="hljs-symbol">%E5</span><span class="hljs-symbol">%86</span><span class="hljs-symbol">%B3</span>/</code></pre><h2 id="这种中文URL的不缺点："><a href="#这种中文URL的不缺点：" class="headerlink" title="这种中文URL的不缺点："></a>这种中文URL的不缺点：</h2><ol><li><p>关键词被编译后，URL会变得很长，这是搜索引擎不建议的，但并非不能使用;也就是不利于SEO。</p></li><li><p>使用被引用，中文URL在转码后会变成形如：%E5%A9%9A%E7%BA%B1 的结构，一些编辑器支持的问题会造成错误链接地址或错误的URL识别、分割 ，甚至有些网站会产生状态为404的引用指向。</p></li></ol><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>一种是把中文路径变为拼音，另一种就是进行转换编码。在 Hexo 根目录下的 _config.yml 文件中，修改或新增配置项：</p><p>拼音：</p><pre><code class="hljs ada">npm i hexo-permalink-pinyin <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-symbol">permalink_pinyin:</span><span class="hljs-symbol">  enable:</span> true<span class="hljs-symbol">  separator:</span> <span class="hljs-string">'-'</span> <span class="hljs-meta"># default: <span class="hljs-string">'-'</span></span></code></pre><p>编码：</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span></code></pre><pre><code class="hljs dts"><span class="hljs-meta"># permalink: :title/</span><span class="hljs-symbol">permalink:</span> archives/:abbrlink.html<span class="hljs-symbol">abbrlink:</span><span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta"># 算法：crc16(default) and crc32</span><span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta"># 进制：dec(default) and hex</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins执行shell命令，提示command not found解决</title>
    <link href="/cxlittlecute/61702.html"/>
    <url>/cxlittlecute/61702.html</url>
    
    <content type="html"><![CDATA[<h1 id="Command-not-found"><a href="#Command-not-found" class="headerlink" title="Command not found"></a>Command not found</h1><p>jenkins执行shell命令，有时会提示“Command not found”—-处理方案。</p><p>1.首先，分析是linux环境的问题还是Jenkins的问题。</p><p>如果登录linux，shell命令不可以执行，同样提示“Command not found”，则是环境变量设置失败，需要配置环境变量、/etc/profile。</p><p>如果登录linux，shell命令可以执行，则是jenkins没有加载/etc/profile导致。</p><p>我就是第二种情况。那就是得让jenkins执行我们实际的shell命令之前，执行识别环境变量的shell命令。让Jenkins先读取/etc/profile等的内容。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">source</span> ~/.bash_profile<span class="hljs-built_in">source</span> /etc/profile<span class="hljs-built_in">cd</span>..等其他shell命令</code></pre>]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云全站加速HTTPS证书无法开启问题解决</title>
    <link href="/cxlittlecute/10754.html"/>
    <url>/cxlittlecute/10754.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云全站加速HTTPS证书无法开启问题解决"><a href="#阿里云全站加速HTTPS证书无法开启问题解决" class="headerlink" title="阿里云全站加速HTTPS证书无法开启问题解决"></a>阿里云全站加速HTTPS证书无法开启问题解决</h1><p>全站加速（Dynamic Route for Content Delivery Network）是阿里云自主研发的融合了动态加速和静态加速技术的CDN产品。该产品一站式解决了页面动静态资源混杂、跨运营商、网络不稳定、单线源站、突发流量、网络拥塞等诸多因素导致的响应慢、丢包、服务不稳定的问题，提升全站性能和用户体验。</p><p>1.选择添加域名</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160216.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.添加域名 类型IP（IP就是你服务器IP）</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713160556.png" srcset="/img/loading.gif" alt="avatar"></p><p>3.HTTPS设置</p><p>我就是在这个地方出现问题的。</p><p>之前没有领取HTTPS证书，所以在这里想一起申请了，也就是选择</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162446.png" srcset="/img/loading.gif" alt="avatar"></p><p>免费证书，点击确定后，弹窗显示了设置成功，但是HTTPS的设置一直都是未开启的状态。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162917.png" srcset="/img/loading.gif" alt="avatar"></p><p>由于不知道问题出现在什么地方，所以找了一下客服。客服的回复如下：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713162759.png" srcset="/img/loading.gif" alt="avatar"></p><p>之后发现出现这个问题的原因是，我自己添加的域名为泛域名，也就是域名前我带了*，这样可能会导致无法颁发证书。</p><p>随后我将*去掉，配置为www或者直接解析域名@,再次去申请证书就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云域名配置</title>
    <link href="/cxlittlecute/202.html"/>
    <url>/cxlittlecute/202.html</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云域名配置"><a href="#阿里云域名配置" class="headerlink" title="阿里云域名配置"></a>阿里云域名配置</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>登录阿里云，选择域名服务，选择你要购买的域名类型进行购买。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152655.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p><a href="https://beian.aliyun.com/" target="_blank" rel="noopener">https://beian.aliyun.com/</a></p><p>必要进行域名备案才能真正使用上你的域名，备案需要填写你购买域名的用途和你个人信息等，然后进行申请，审批时长大概二十天左右。</p><p>期间保持电话畅通，因为阿里云的客服小姐姐小哥哥可能会给你打电话，如果你有什么信息需要修改的可以第一时间得到反馈。然后就是耐心的等待。</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713152836.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>当你把以上的步骤完成后，就可以进入域名的管理控制台。<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153119.png" srcset="/img/loading.gif" alt="avatar"></p><p>点击解析 配置你的解析设置：<br><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713153540.png" srcset="/img/loading.gif" alt="avatar"></p><p>这样只需要对应你的IP进行配置就可以实现使用你自己的域名解析到IP上了。</p>]]></content>
    
    
    <categories>
      
      <category>阿里云</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里云</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建与部署</title>
    <link href="/cxlittlecute/19858.html"/>
    <url>/cxlittlecute/19858.html</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客搭建与部署"><a href="#Hexo博客搭建与部署" class="headerlink" title="Hexo博客搭建与部署"></a>Hexo博客搭建与部署</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。</p><p>文档地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><h2 id="如何搭建（参照Hexo文档）"><a href="#如何搭建（参照Hexo文档）" class="headerlink" title="如何搭建（参照Hexo文档）"></a>如何搭建（参照Hexo文档）</h2><p>安装前提：node.js和Git</p><p>node: <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>Git: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre><pre><code class="hljs cmd">$ hexo init &lt;folder&gt;$ <span class="hljs-built_in">cd</span> &lt;folder&gt;$ npm install</code></pre><p>Hexo的安装过程比较简单，主要参照文档就行了。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>hexo项目结构安装好后，就可以选择一个合适的主题，官网有主题的选项，同时也可以去百度上看一下别人选择的主题做出来的效果，有看到喜欢的就用相同的主题。</p><p>我用的主题为：Fluid&emsp;&emsp;  <a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">https://hexo.fluid-dev.com/docs/</a></p><p>这个主题支持的插件基本还可以，界面还是简介大方。</p><p>那么我们只需要下载好相应的主题，按照Hexo官方文档（注意不是主题文档）修改_config.yml这个文件中的内容就可以了。</p><p>很多细小的配置在Fluid主题文档中都有，基本可以把文档看一遍，修改好你想要的设置。</p><h2 id="主题设置细节说明"><a href="#主题设置细节说明" class="headerlink" title="主题设置细节说明"></a>主题设置细节说明</h2><p>我的博客中使用了评论和统计插件。</p><p>评论-Valine <a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></p><p>统计-leancloud <a href="https://www.leancloud.cn/" target="_blank" rel="noopener">https://www.leancloud.cn/</a></p><p>评论和计数的后台都可以通过lencloud的后台系统管理，而且比较稳定。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>重点说一下部署，因为Hexo部署上去的其实就是Public下面的html静态文件，所以可以把public下的文件放置在任何地方。</p><p>文档推荐的是放github下，但是你会发现如果你不翻墙的话，图片很难加载出来，gitee也可以，但是如果你想配置自定义域名的话，就必须要购买gitee自定义域名的产品。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>我使用的是PicGo+Gitee(码云)搭建自己的图床。</p><p>1.将PicGO下载下来，然后安装插件</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713133658.png" srcset="/img/loading.gif" alt="avatar"></p><p>2.配置Gitee<br>点击自己gitee头像-&gt;设置，左边有一个私人令牌，点击右上角生成新令牌，只选择projects,如下图：</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150257.png" srcset="/img/loading.gif" alt="avatar"></p><p>注意：私人令牌token只会显示一次，如果没有复制成功只能删除后重新获取。</p><p>3.设置插件githubPlus</p><p><img src="https://gitee.com/ouyang_shenglin/blogImage/raw/master/img/20200713150827.png" srcset="/img/loading.gif" alt="avatar"></p><p>测试：记得修改PicGO中上传区中的图片上传改为:图片上床-githubLPlus这样就可以根据路径来访问你的图片了。</p><pre><code class="hljs stata">最后，感谢Yazzz带我入坑，友链里有<span class="hljs-keyword">ta</span>哦~</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
